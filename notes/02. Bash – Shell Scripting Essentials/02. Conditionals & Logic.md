# Shell Environment & Execution Model

It's Monday morning. Your deployment script has been running perfectly for six months. You tested it last week. It works on your machine. It works when you SSH in and run it manually.

But the cron job failed. Again. No errors in the script log â€” just... nothing happened. The backup didn't run. The database is unprotected. And you have no idea why.

You SSH in, run the script manually: works fine. Check the cron log: it ran. Check the script output: empty. What's going on?

Then you notice it. The script calls `aws s3 cp` to upload backups. When you run it manually, `aws` is in your PATH. But cron doesn't load your `.bashrc`. Cron's PATH is `/usr/bin:/bin`. The `aws` CLI lives in `/usr/local/bin`. The command silently wasn't found. The script silently continued. Your backups silently didn't happen.

This is why environment matters.

Every "works on my machine" bug, every "fails in CI" mystery, every "cron doesn't run my script" frustration â€” the answer is almost always environment. The shell execution model determines what your script sees, what commands it can find, and what context it inherits. Master this, and you'll debug in minutes what others debug for hours.

---

## Table of Contents

1. [Why Environment Breaks Everything](#why-environment-breaks-everything)
2. [How Bash Executes Commands](#how-bash-executes-commands)
3. [Shell Modes & Startup Files](#shell-modes--startup-files)
4. [Hands-On: Trace Your Environment](#hands-on-trace-your-environment)

---

<details>
<summary><strong>1. Why Environment Breaks Everything</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

> **Golden Rule:** *"If it works manually but breaks in CI, the environment is lying."*

The environment is invisible context. You don't see it, but every command you run depends on it. And different contexts have different environments.

---

### The Environment Is Implicit Context

When you type a command, dozens of invisible factors affect how it runs:

- **PATH** â€” Where to find executables
- **HOME** â€” What `~` expands to
- **USER** â€” Who you are
- **PWD** â€” Current directory
- **LANG/LC_*** â€” How to handle text encoding
- **Custom variables** â€” `AWS_PROFILE`, `KUBECONFIG`, `DATABASE_URL`

You set these once and forget them. Your interactive shell loads them from dotfiles. Everything works. You assume this is how the world works.

Then cron runs your script. Or CI runs it. Or systemd runs it. And suddenly none of those assumptions hold.

---

### ğŸ”¥ Real Incident: The Missing PATH

**What happened:** ChillSpot's backup script worked for months. Then backups silently stopped. No errors. No alerts. Just... no backups for three weeks until someone noticed.

**The cause:** An engineer updated the `aws` CLI using `pip install --user awscli`. This installed the new version in `~/.local/bin`. Their interactive shell included `~/.local/bin` in PATH (added in `.bashrc`). When they tested manually: worked fine.

But cron doesn't load `.bashrc`. Cron's PATH was the system default: `/usr/bin:/bin:/usr/sbin:/sbin`. No `~/.local/bin`. The `aws` command silently failed because it wasn't found. The script didn't use `set -e`, so it continued silently. Exit code 0. No backups.

**The fix:**
```bash
#!/bin/bash
# backup.sh â€” ALWAYS set explicit PATH at the top
export PATH="/usr/local/bin:/usr/bin:/bin:$HOME/.local/bin"
set -euo pipefail

aws s3 cp /var/backups/db.sql.gz "s3://chillspot-backups/$(date +%Y%m%d).sql.gz"
```

**The lesson:** Never assume PATH. Set it explicitly at the top of every script that runs unattended.

---

### Environment Differs By Context

| Context | PATH | Loads dotfiles? | Has terminal? |
|---------|------|-----------------|---------------|
| Interactive login shell | Full (from `.bash_profile`) | Yes | Yes |
| Interactive non-login | Full (from `.bashrc`) | Yes | Yes |
| Cron job | Minimal (`/usr/bin:/bin`) | No | No |
| Systemd service | Minimal or custom | No | No |
| CI/CD runner | Varies by platform | Sometimes | Usually no |
| Docker container | Depends on image | Depends | Usually no |
| SSH command (`ssh host 'cmd'`) | Minimal | No | No |

This is why the same script behaves differently in different places. The script didn't change. The environment did.

---

### What NOT To Do

âŒ **Don't assume PATH contains what you need** â€” CI runners, cron, and containers all have minimal PATH.

âŒ **Don't rely on environment variables being set** â€” If your script needs `DATABASE_URL`, check for it or set a default.

âŒ **Don't test only in your interactive shell** â€” Test in the actual environment: run via cron, run in CI, run in Docker.

</div>

</details>

---

<details>
<summary><strong>2. How Bash Executes Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Understanding execution isn't academic â€” it's how you debug. When you know how Bash finds and runs commands, you can trace exactly where things go wrong.

---

### Command Lookup Order

When you type a command, Bash searches in this exact order:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMMAND LOOKUP ORDER                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   1. ALIASES        â†’  Only in interactive shells               â”‚
â”‚                        (ignored in scripts)                     â”‚
â”‚                                                                 â”‚
â”‚   2. FUNCTIONS      â†’  Shell functions defined in current       â”‚
â”‚                        session or sourced files                 â”‚
â”‚                                                                 â”‚
â”‚   3. BUILTINS       â†’  Commands built into Bash itself          â”‚
â”‚                        (cd, echo, type, source, etc.)           â”‚
â”‚                                                                 â”‚
â”‚   4. HASH TABLE     â†’  Cached paths from previous lookups       â”‚
â”‚                        (speeds up repeated commands)            â”‚
â”‚                                                                 â”‚
â”‚   5. PATH SEARCH    â†’  Search each directory in $PATH           â”‚
â”‚                        Left to right, first match wins          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This order matters. If you define a function called `ls`, it shadows the external `ls` command. If you have multiple `python` binaries in different PATH directories, the first one wins.

---

### Builtins vs External Commands

Some commands are built into Bash. Others are separate programs.

```bash
$ type cd
cd is a shell builtin

$ type grep
grep is /usr/bin/grep

$ type echo
echo is a shell builtin

$ type -a echo
echo is a shell builtin
echo is /usr/bin/echo
```

**Why this matters:**

| Type | Speed | Can modify shell? | Spawns process? |
|------|-------|-------------------|-----------------|
| Builtin | Fast | Yes | No |
| External | Slower | No | Yes |

`cd` *must* be a builtin â€” an external program can't change the shell's current directory. `echo` is a builtin for speed, but there's also `/usr/bin/echo` for compatibility.

When you run an external command, Bash forks a child process and executes the program in that child. This is the fork/exec model.

---

### The Fork/Exec Model

When Bash runs an external command, two system calls happen:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      FORK/EXEC MODEL                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   PARENT SHELL (PID 1000)                                       â”‚
â”‚         â”‚                                                       â”‚
â”‚         â”‚ fork()                                                â”‚
â”‚         â–¼                                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚  CHILD PROCESS (PID 1001)               â”‚                   â”‚
â”‚   â”‚  - Copy of parent                       â”‚                   â”‚
â”‚   â”‚  - Same environment                     â”‚                   â”‚
â”‚   â”‚  - Same open files                      â”‚                   â”‚
â”‚   â”‚                                         â”‚                   â”‚
â”‚   â”‚         â”‚ exec()                        â”‚                   â”‚
â”‚   â”‚         â–¼                               â”‚                   â”‚
â”‚   â”‚  REPLACED WITH: /usr/bin/grep           â”‚                   â”‚
â”‚   â”‚  - New program code                     â”‚                   â”‚
â”‚   â”‚  - Keeps environment                    â”‚                   â”‚
â”‚   â”‚  - Keeps PID 1001                       â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                                                       â”‚
â”‚         â”‚ exit(0)                                               â”‚
â”‚         â–¼                                                       â”‚
â”‚   PARENT SHELL (PID 1000)                                       â”‚
â”‚   - Receives exit code                                          â”‚
â”‚   - Continues execution                                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**What this means in practice:**

1. **Child processes inherit environment variables** â€” But changes in the child don't affect the parent
2. **External commands run in isolation** â€” They can't modify your shell's variables or state
3. **Exit codes are how children communicate back** â€” That's all they can send: a number 0-255

---

### Subshells and Environment Inheritance

A subshell is a child copy of the current shell. Created by:

- Parentheses: `(commands)`
- Pipes: `cmd1 | cmd2` (each side is a subshell)
- Command substitution: `$(command)`
- Background: `command &`

```bash
# Parent sets a variable
my_var="parent"

# Subshell gets a copy, but changes don't come back
(
    my_var="child"
    echo "Inside subshell: $my_var"   # "child"
)
echo "Back in parent: $my_var"        # "parent" â€” unchanged!
```

This is the #1 source of "my variable disappeared" bugs.

```bash
# WRONG: Variable set in pipeline disappears
cat file.txt | while read line; do
    count=$((count + 1))
done
echo "Count: $count"   # Empty or 0! The while loop ran in a subshell.

# RIGHT: Use process substitution to keep loop in current shell
while read line; do
    count=$((count + 1))
done < <(cat file.txt)
echo "Count: $count"   # Correct count
```

---

### Environment vs Local Variables

Variables in Bash are local to the current shell by default. To pass them to child processes, you must `export` them.

```bash
# Local variable â€” only in current shell
db_host="localhost"
./my_script.sh          # my_script.sh does NOT see $db_host

# Exported variable â€” passed to children
export DB_HOST="localhost"
./my_script.sh          # my_script.sh sees $DB_HOST

# Export and assign in one line
export API_KEY="secret123"

# Check what's exported
export -p                # List all exported variables
```

**Convention:**
- Local variables: `lowercase_with_underscores`
- Environment variables: `UPPERCASE_WITH_UNDERSCORES`

---

### What NOT To Do

âŒ **Don't expect aliases to work in scripts** â€” They're interactive-only. Use functions instead.

âŒ **Don't modify variables in pipelines expecting them to persist** â€” Each pipe segment is a subshell.

âŒ **Don't assume child processes can affect the parent** â€” They can't. Export is one-way (parent â†’ child).

</div>

</details>

---

<details>
<summary><strong>3. Shell Modes & Startup Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Bash behaves differently depending on how it's started. Understanding the four modes explains why your dotfiles sometimes load and sometimes don't.

---

### The Four Shell Modes

Bash checks two things when it starts:

1. **Is it a login shell?** â€” First shell after authentication (ssh, console login, `bash --login`)
2. **Is it interactive?** â€” Connected to a terminal with a human typing commands

This creates four combinations:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SHELL MODE MATRIX                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚                    â”‚   Interactive    â”‚   Non-Interactive       â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                    â”‚                  â”‚                         â”‚
â”‚   Login            â”‚  SSH session     â”‚  ssh host 'command'     â”‚
â”‚                    â”‚  Console login   â”‚  bash --login script.sh â”‚
â”‚                    â”‚                  â”‚                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                    â”‚                  â”‚                         â”‚
â”‚   Non-Login        â”‚  New terminal    â”‚  ./script.sh            â”‚
â”‚                    â”‚  bash (in shell) â”‚  cron jobs              â”‚
â”‚                    â”‚  tmux/screen     â”‚  CI/CD pipelines        â”‚
â”‚                    â”‚                  â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Which Startup Files Load When

Each mode loads different files:

| Mode | Files Loaded | Common Use |
|------|--------------|------------|
| **Interactive Login** | `/etc/profile` â†’ `~/.bash_profile` (or `~/.profile`) | SSH, console login |
| **Interactive Non-Login** | `~/.bashrc` | Opening new terminal tab |
| **Non-Interactive Login** | `/etc/profile` â†’ `~/.bash_profile` | Rare (forced with `--login`) |
| **Non-Interactive Non-Login** | `$BASH_ENV` if set, otherwise nothing | Scripts, cron, CI |

**The critical insight:** Scripts (`./script.sh`) and cron jobs load **nothing**. No `.bashrc`. No `.bash_profile`. No PATH additions. No aliases. No functions. Nothing.

---

### Startup File Flowchart

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   BASH STARTUP SEQUENCE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   Is it a LOGIN shell?                                          â”‚
â”‚         â”‚                                                       â”‚
â”‚         â”œâ”€â”€ YES â”€â”€â–¶ /etc/profile                                â”‚
â”‚         â”‚              â”‚                                        â”‚
â”‚         â”‚              â–¼                                        â”‚
â”‚         â”‚          First found of:                              â”‚
â”‚         â”‚          ~/.bash_profile                              â”‚
â”‚         â”‚          ~/.bash_login                                â”‚
â”‚         â”‚          ~/.profile                                   â”‚
â”‚         â”‚                                                       â”‚
â”‚         â””â”€â”€ NO â”€â”€â”€â–¶ Is it INTERACTIVE?                          â”‚
â”‚                           â”‚                                     â”‚
â”‚                           â”œâ”€â”€ YES â”€â”€â–¶ ~/.bashrc                 â”‚
â”‚                           â”‚                                     â”‚
â”‚                           â””â”€â”€ NO â”€â”€â”€â–¶ $BASH_ENV (if set)        â”‚
â”‚                                       Otherwise: NOTHING        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### The Common Setup Pattern

Most people want the same environment everywhere. Here's the standard pattern:

**~/.bash_profile** (or ~/.profile):
```bash
# Load .bashrc if it exists (makes login shells consistent with non-login)
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
```

**~/.bashrc**:
```bash
# All your customizations go here
export PATH="$HOME/.local/bin:$HOME/bin:$PATH"
export EDITOR="vim"

# Aliases (interactive only, but harmless in scripts)
alias ll='ls -la'
alias gs='git status'

# Prompt customization
PS1='[\u@\h \W]\$ '
```

This way, both login and non-login interactive shells get the same setup.

---

### How to Check Your Shell Mode

```bash
# Check if login shell
shopt -q login_shell && echo "Login shell" || echo "Non-login shell"

# Check if interactive
[[ $- == *i* ]] && echo "Interactive" || echo "Non-interactive"

# See all shell options
echo $-    # 'himBH' means interactive, 'hB' usually means non-interactive
```

---

### Making Scripts Environment-Safe

Since scripts don't load dotfiles, you have two choices:

**Option 1: Set environment explicitly in the script (Recommended)**
```bash
#!/bin/bash
# Set up known-good environment
export PATH="/usr/local/bin:/usr/bin:/bin"
export LANG="en_US.UTF-8"

# Now your script is self-contained
```

**Option 2: Source a shared config file**
```bash
#!/bin/bash
# Load shared configuration
source /opt/chillspot/etc/script_env.sh

# Now use the shared setup
```

**Option 3: Force loading of bashrc (Use sparingly)**
```bash
#!/bin/bash
# Load user's bashrc
[[ -f ~/.bashrc ]] && source ~/.bashrc

# Now you have user's environment â€” but it's unpredictable
```

Option 1 is safest. Your script works regardless of user configuration.

---

### What NOT To Do

âŒ **Don't assume `.bashrc` is loaded** â€” Scripts and cron don't load it.

âŒ **Don't put script-critical setup only in dotfiles** â€” Scripts must be self-contained.

âŒ **Don't confuse `.bash_profile` and `.bashrc`** â€” Login shells read one, non-login interactive reads the other.

</div>

</details>

---

<details>
<summary><strong>4. Hands-On: Trace Your Environment</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Understanding comes from doing. These exercises take 10 minutes and will save you hours of debugging.

---

### Check Your Shell Mode

```bash
# What shell are you in?
echo "Shell: $0"
echo "SHELL variable: $SHELL"
ps -p $$

# Is it a login shell?
shopt -q login_shell && echo "Login shell" || echo "Non-login shell"

# Is it interactive?
[[ $- == *i* ]] && echo "Interactive" || echo "Non-interactive"
```

Now compare â€” open a new terminal tab and run the same commands. Then SSH to a server and run them again. Notice the differences.

---

### Trace Command Lookup

```bash
# Where does 'ls' come from?
type ls
type -a ls      # Show ALL matches

# Where does 'cd' come from?
type cd         # It's a builtin â€” has to be

# Create a function that shadows a command
ls() { echo "You called the function, not /bin/ls"; }
type ls         # Now it's a function
ls              # Calls your function
unset -f ls     # Remove the function
ls              # Back to normal
```

---

### See Environment Inheritance

Create a test script:

```bash
cat > /tmp/env_test.sh << 'EOF'
#!/bin/bash
echo "=== Environment Test ==="
echo "PATH: $PATH"
echo "HOME: $HOME"
echo "MY_VAR: $MY_VAR"
echo "EXPORTED_VAR: $EXPORTED_VAR"
EOF
chmod +x /tmp/env_test.sh
```

Now test inheritance:

```bash
# Local variable â€” NOT inherited
MY_VAR="local_value"
/tmp/env_test.sh
# MY_VAR is empty in the script

# Exported variable â€” inherited
export EXPORTED_VAR="exported_value"
/tmp/env_test.sh
# EXPORTED_VAR shows up

# One-time export for single command
MY_VAR="temp" /tmp/env_test.sh
# MY_VAR is "temp" just for this run
echo $MY_VAR
# Back to "local_value" in current shell
```

---

### Simulate Cron's Environment

Cron runs with minimal environment. Simulate it:

```bash
# See what cron sees (approximately)
env -i PATH=/usr/bin:/bin HOME=$HOME /tmp/env_test.sh

# Compare to your interactive shell
/tmp/env_test.sh
```

The difference is why scripts fail in cron. Your interactive shell has a rich PATH. Cron has almost nothing.

---

### Test Subshell Variable Isolation

```bash
# Set a variable
counter=0

# Modify in subshell
(
    counter=100
    echo "Inside subshell: $counter"    # 100
)
echo "Outside subshell: $counter"       # Still 0!

# The pipeline trap
echo "one
two
three" | while read line; do
    counter=$((counter + 1))
done
echo "After pipeline: $counter"         # Still 0! Pipeline runs in subshell

# Fix with process substitution
counter=0
while read line; do
    counter=$((counter + 1))
done < <(echo "one
two
three")
echo "With process substitution: $counter"   # 3 â€” correct!
```

---

### Debug a Script's Environment

Add this to the top of any script to see exactly what environment it's running with:

```bash
#!/bin/bash
# Debug block â€” remove in production
echo "=== DEBUG: Script Environment ===" >&2
echo "Script: $0" >&2
echo "PID: $$" >&2
echo "PWD: $PWD" >&2
echo "PATH: $PATH" >&2
echo "USER: $USER" >&2
echo "Interactive: $([[ $- == *i* ]] && echo yes || echo no)" >&2
echo "Login: $(shopt -q login_shell && echo yes || echo no)" >&2
echo "=== END DEBUG ===" >&2
```

Run the script normally, via cron, via SSH â€” compare the output.

---

### What You Should Now Be Able To Do

Before moving to File 03, verify you can:

- [ ] Explain why scripts fail in cron but work manually â€” environment differences
- [ ] Describe command lookup order â€” aliases â†’ functions â†’ builtins â†’ PATH
- [ ] Explain fork/exec â€” how external commands run in child processes
- [ ] Understand subshell isolation â€” why variables in pipelines disappear
- [ ] Know which dotfiles load when â€” `.bash_profile` vs `.bashrc` vs nothing
- [ ] Debug a script's environment â€” what PATH, variables, and mode it has
- [ ] Write environment-safe scripts â€” explicit PATH, no dotfile assumptions

</div>

</details>

---

## The System You're Building

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         BASH INSIDE-OUT FLOW                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚   01     â”‚    â”‚    02    â”‚    â”‚    03    â”‚    â”‚    04    â”‚               â”‚
â”‚  â”‚ Mindset  â”‚â”€â”€â”€â–¶â”‚   Env &  â”‚â”€â”€â”€â–¶â”‚  Script  â”‚â”€â”€â”€â–¶â”‚ Vars &   â”‚               â”‚
â”‚  â”‚ & Why    â”‚    â”‚   Exec   â”‚    â”‚ Structureâ”‚    â”‚ Quoting  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       âœ“          [YOU ARE HERE]                       â”‚                     â”‚
â”‚       â”‚         "How Bash thinks"                     â”‚                     â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                              â”‚                                              â”‚
â”‚                              â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚    08    â”‚    â”‚    07    â”‚    â”‚    06    â”‚    â”‚    05    â”‚               â”‚
â”‚  â”‚Productionâ”‚â—€â”€â”€â”€â”‚  Error   â”‚â—€â”€â”€â”€â”‚Functions â”‚â—€â”€â”€â”€â”‚  Control â”‚               â”‚
â”‚  â”‚ Patterns â”‚    â”‚ Handling â”‚    â”‚& Modules â”‚    â”‚   Flow   â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                               â”‚                     â”‚
â”‚       â”‚         "How scripts work"                    â”‚                     â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                              â”‚                                              â”‚
â”‚                              â–¼                                              â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚                    â”‚  PRODUCTION-READY â”‚                                    â”‚
â”‚                    â”‚      SCRIPTS      â”‚                                    â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## What's Next

You now understand the execution model: how Bash finds commands, how fork/exec creates child processes, why subshells isolate variables, and which startup files load in which contexts. You know why environment is the root cause of most "works locally, fails elsewhere" bugs.

But understanding execution isn't enough. You need to write scripts that work reliably. What makes a script file actually executable? What's the difference between running `./script.sh` and `source script.sh`? How do you structure a script so it's maintainable? What's this `set -euo pipefail` everyone talks about?

That's File 03 â€” **Scripts That Don't Break at 3 AM**. We'll cover the mechanics of creating executable scripts, proper structure, strict mode that catches errors, and the patterns that separate fragile scripts from production-ready automation.

---

*"If it works manually but breaks in CI, the environment is lying."*