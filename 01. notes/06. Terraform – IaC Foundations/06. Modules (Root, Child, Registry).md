# **06. Modules — Organizing and Reusing Terraform Code**

You've built VPCs, subnets, instances, security groups — all in one big file.
It works, but it doesn't scale.

What happens when you need to deploy the same VPC setup across 5 different projects?
Copy-paste 200 lines of code 5 times? Update all 5 copies when something changes?

**That's where modules come in.**

Modules let you package reusable infrastructure into components. Write once, use everywhere.
Think of them as functions in programming — you define the logic once, then call it with different parameters.

We'll explore what modules are, how to build them, how to use them from different sources, and how to design them for maximum reusability.

---

## Table of Contents
1. [What Are Modules & Why They Matter](#1-what-are-modules--why-they-matter)
2. [Root Module vs Child Modules](#2-root-module-vs-child-modules)
3. [Creating Your First Module](#3-creating-your-first-module)
4. [Module Inputs & Outputs](#4-module-inputs--outputs)
5. [Module Sources](#5-module-sources)
6. [Terraform Registry Modules](#6-terraform-registry-modules)
7. [Module Versioning](#7-module-versioning)
8. [Best Practices for Module Design](#8-best-practices-for-module-design)

---

<details>
<summary><strong>1. What Are Modules & Why They Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

A **module** is a container for multiple resources that are used together.

Every Terraform configuration is technically a module — even a single `main.tf` file.
But when people talk about "modules," they usually mean **reusable components** you call from other configurations.

**Without modules (repetitive):**

You need VPCs in 3 projects. Each project has this code:
```hcl
# project-a/main.tf
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
  
  tags = {
    Name = "project-a-vpc"
  }
}

resource "aws_subnet" "public" {
  count      = 3
  vpc_id     = aws_vpc.main.id
  cidr_block = "10.0.${count.index}.0/24"
  # ... more config
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
}

# ... 50 more lines
```

Same 50 lines copied to `project-b/`, `project-c/`, etc.

**With modules (reusable):**

```hcl
# project-a/main.tf
module "vpc" {
  source = "../modules/vpc"
  
  name       = "project-a"
  cidr_block = "10.0.0.0/16"
  az_count   = 3
}
```

3 lines instead of 50. The VPC logic lives in one place.

**Why Modules Matter:**

**DRY (Don't Repeat Yourself)** — Write once, use everywhere
**Consistency** — Same module = same configuration
**Maintainability** — Fix a bug once, all projects benefit
**Abstraction** — Hide complexity behind simple interfaces
**Sharing** — Distribute modules across teams or organizations
**Testing** — Test modules independently

**Real-World Example:**

Your company has a standard way to deploy web applications:
- VPC with public/private subnets
- Application Load Balancer
- Auto Scaling Group
- RDS database
- S3 bucket for assets

Without modules, every team copies this setup and modifies it slightly.
With a module, they call:

```hcl
module "web_app" {
  source = "git::https://github.com/company/terraform-modules//web-app"
  
  name        = "my-app"
  environment = "prod"
  domain      = "myapp.example.com"
}
```

One module encapsulates the entire pattern.

</div>

</details>

---

<details>
<summary><strong>2. Root Module vs Child Modules</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Root Module** — The configuration where you run `terraform apply`
**Child Module** — A module called by another module

**Example Structure:**

```
project/
├── main.tf              ← Root module
├── variables.tf         ← Root module
├── outputs.tf           ← Root module
└── modules/
    └── vpc/
        ├── main.tf      ← Child module
        ├── variables.tf ← Child module
        └── outputs.tf   ← Child module
```

**Root module (main.tf):**
```hcl
module "vpc" {
  source = "./modules/vpc"
  
  name       = "production"
  cidr_block = "10.0.0.0/16"
}

output "vpc_id" {
  value = module.vpc.vpc_id
}
```

**Child module (modules/vpc/main.tf):**
```hcl
resource "aws_vpc" "main" {
  cidr_block = var.cidr_block
  
  tags = {
    Name = var.name
  }
}
```

**The Flow:**

1. You run `terraform apply` in the root module
2. Root module calls child module: `module "vpc" { ... }`
3. Child module creates resources
4. Child module returns outputs
5. Root module uses those outputs

**Key Differences:**

| Aspect | Root Module | Child Module |
|--------|-------------|--------------|
| **Location** | Where you run terraform | Called by other modules |
| **Backend** | Configured here | Inherits from root |
| **State** | Has its own state | Resources tracked in root's state |
| **Providers** | Configured here | Can be passed down |
| **Variables** | Set via CLI/tfvars | Set by calling module |
| **Outputs** | Display in terminal | Returned to caller |

**Modules Can Call Modules:**

```hcl
# Root module
module "networking" {
  source = "./modules/networking"
}

# modules/networking/main.tf
module "vpc" {
  source = "./vpc"
}

module "subnets" {
  source = "./subnets"
  vpc_id = module.vpc.vpc_id
}
```

Root → networking → vpc/subnets

**When to Create a Module:**

✅ **Create modules for:**
- Reusable infrastructure patterns
- Complex multi-resource configurations
- Standard company patterns
- Shared team components

❌ **Don't create modules for:**
- Single resources (overkill)
- Project-specific one-offs
- When it adds unnecessary complexity

</div>

</details>

---

<details>
<summary><strong>3. Creating Your First Module</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Let's build a simple S3 bucket module step by step.

**Step 1: Create Module Directory**

```bash
mkdir -p modules/s3-bucket
cd modules/s3-bucket
```

**Step 2: Create modules/s3-bucket/main.tf**

```hcl
resource "aws_s3_bucket" "this" {
  bucket = var.bucket_name
  
  tags = var.tags
}

resource "aws_s3_bucket_versioning" "this" {
  bucket = aws_s3_bucket.this.id
  
  versioning_configuration {
    status = var.enable_versioning ? "Enabled" : "Disabled"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "this" {
  count  = var.enable_encryption ? 1 : 0
  bucket = aws_s3_bucket.this.id
  
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}
```

**Step 3: Create modules/s3-bucket/variables.tf**

```hcl
variable "bucket_name" {
  description = "Name of the S3 bucket"
  type        = string
}

variable "enable_versioning" {
  description = "Enable versioning for the bucket"
  type        = bool
  default     = false
}

variable "enable_encryption" {
  description = "Enable encryption for the bucket"
  type        = bool
  default     = true
}

variable "tags" {
  description = "Tags to apply to the bucket"
  type        = map(string)
  default     = {}
}
```

**Step 4: Create modules/s3-bucket/outputs.tf**

```hcl
output "bucket_id" {
  description = "ID of the S3 bucket"
  value       = aws_s3_bucket.this.id
}

output "bucket_arn" {
  description = "ARN of the S3 bucket"
  value       = aws_s3_bucket.this.arn
}

output "bucket_domain_name" {
  description = "Domain name of the bucket"
  value       = aws_s3_bucket.this.bucket_domain_name
}
```

**Step 5: Create modules/s3-bucket/README.md** (Optional but recommended)

```markdown
# S3 Bucket Module

Creates an S3 bucket with optional versioning and encryption.

## Usage

```hcl
module "my_bucket" {
  source = "./modules/s3-bucket"
  
  bucket_name        = "my-app-data"
  enable_versioning  = true
  enable_encryption  = true
  
  tags = {
    Environment = "prod"
    Project     = "my-app"
  }
}
```

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|----------|
| bucket_name | Name of the S3 bucket | string | n/a | yes |
| enable_versioning | Enable versioning | bool | false | no |
| enable_encryption | Enable encryption | bool | true | no |
| tags | Tags for the bucket | map(string) | {} | no |

## Outputs

| Name | Description |
|------|-------------|
| bucket_id | ID of the bucket |
| bucket_arn | ARN of the bucket |
| bucket_domain_name | Domain name of the bucket |
```

**Step 6: Use the Module**

Back in your root directory:

```hcl
# main.tf
module "data_bucket" {
  source = "./modules/s3-bucket"
  
  bucket_name       = "my-app-data-bucket"
  enable_versioning = true
  enable_encryption = true
  
  tags = {
    Environment = "production"
    Project     = "my-app"
  }
}

module "logs_bucket" {
  source = "./modules/s3-bucket"
  
  bucket_name       = "my-app-logs-bucket"
  enable_versioning = false
  enable_encryption = true
  
  tags = {
    Environment = "production"
    Type        = "logs"
  }
}

output "data_bucket_arn" {
  value = module.data_bucket.bucket_arn
}

output "logs_bucket_arn" {
  value = module.logs_bucket.bucket_arn
}
```

**Step 7: Initialize and Apply**

```bash
terraform init
terraform plan
terraform apply
```

**You just created and used your first module!**

Two buckets with different configurations, same underlying code.

</div>

</details>

---

<details>
<summary><strong>4. Module Inputs & Outputs</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Modules communicate through inputs (variables) and outputs.

**Inputs** — Parameters passed into the module
**Outputs** — Values returned from the module

**Input Variables:**

In the module:
```hcl
# modules/vpc/variables.tf
variable "cidr_block" {
  description = "CIDR block for the VPC"
  type        = string
}

variable "name" {
  description = "Name prefix for resources"
  type        = string
}

variable "az_count" {
  description = "Number of availability zones"
  type        = number
  default     = 3
}
```

When calling the module:
```hcl
module "vpc" {
  source = "./modules/vpc"
  
  cidr_block = "10.0.0.0/16"
  name       = "production"
  az_count   = 2
}
```

**You can't reference variables directly across modules.** You must pass them explicitly.

**Outputs:**

In the module:
```hcl
# modules/vpc/outputs.tf
output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}

output "public_subnet_ids" {
  description = "IDs of public subnets"
  value       = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  description = "IDs of private subnets"
  value       = aws_subnet.private[*].id
}
```

Using module outputs:
```hcl
module "vpc" {
  source = "./modules/vpc"
  # ... inputs
}

resource "aws_instance" "web" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  subnet_id     = module.vpc.public_subnet_ids[0]
}

output "vpc_id" {
  value = module.vpc.vpc_id
}
```

**Syntax:** `module.MODULE_NAME.OUTPUT_NAME`

**Passing Outputs Between Modules:**

```hcl
module "networking" {
  source = "./modules/networking"
  
  name       = "production"
  cidr_block = "10.0.0.0/16"
}

module "compute" {
  source = "./modules/compute"
  
  vpc_id     = module.networking.vpc_id
  subnet_ids = module.networking.public_subnet_ids
}
```

**Complex Input Types:**

```hcl
# modules/app/variables.tf
variable "instances" {
  description = "Instance configuration"
  type = map(object({
    instance_type = string
    ami           = string
    subnet_id     = string
  }))
}

# Calling the module
module "app" {
  source = "./modules/app"
  
  instances = {
    web = {
      instance_type = "t3.micro"
      ami           = "ami-abc123"
      subnet_id     = module.vpc.public_subnet_ids[0]
    }
    api = {
      instance_type = "t3.small"
      ami           = "ami-def456"
      subnet_id     = module.vpc.private_subnet_ids[0]
    }
  }
}
```

**Optional Inputs with Defaults:**

```hcl
variable "enable_monitoring" {
  description = "Enable CloudWatch monitoring"
  type        = bool
  default     = false
}

variable "tags" {
  description = "Tags to apply"
  type        = map(string)
  default     = {}
}
```

Caller can omit these if defaults are acceptable.

**Validating Module Inputs:**

```hcl
variable "environment" {
  description = "Environment name"
  type        = string
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "instance_count" {
  description = "Number of instances"
  type        = number
  
  validation {
    condition     = var.instance_count >= 1 && var.instance_count <= 10
    error_message = "Instance count must be between 1 and 10."
  }
}
```

**Sensitive Outputs:**

```hcl
output "db_password" {
  description = "Database password"
  value       = random_password.db.result
  sensitive   = true
}
```

Won't display in terminal output.

</div>

</details>

---

<details>
<summary><strong>5. Module Sources</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Terraform can load modules from multiple sources.

**Local Path:**
```hcl
module "vpc" {
  source = "./modules/vpc"
}

module "vpc_relative" {
  source = "../shared-modules/vpc"
}

module "vpc_absolute" {
  source = "/opt/terraform/modules/vpc"
}
```

**Git (HTTPS):**
```hcl
module "vpc" {
  source = "git::https://github.com/company/terraform-modules.git//vpc"
}
```

The `//` separates the repo from the subdirectory.

**Git (SSH):**
```hcl
module "vpc" {
  source = "git::ssh://git@github.com/company/terraform-modules.git//vpc"
}
```

**Git with Branch:**
```hcl
module "vpc" {
  source = "git::https://github.com/company/terraform-modules.git//vpc?ref=main"
}
```

**Git with Tag:**
```hcl
module "vpc" {
  source = "git::https://github.com/company/terraform-modules.git//vpc?ref=v1.2.0"
}
```

**Git with Commit:**
```hcl
module "vpc" {
  source = "git::https://github.com/company/terraform-modules.git//vpc?ref=abc123def"
}
```

**Terraform Registry:**
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.0"
}
```

**HTTP URL:**
```hcl
module "vpc" {
  source = "https://example.com/terraform-modules/vpc.zip"
}
```

**S3 Bucket:**
```hcl
module "vpc" {
  source = "s3::https://s3.amazonaws.com/my-bucket/vpc-module.zip"
}
```

**Bitbucket:**
```hcl
module "vpc" {
  source = "git::https://bitbucket.org/company/terraform-modules.git//vpc"
}
```

**GitLab:**
```hcl
module "vpc" {
  source = "git::https://gitlab.com/company/terraform-modules.git//vpc"
}
```

**Common Patterns:**

**Development (local):**
```hcl
module "vpc" {
  source = "./modules/vpc"
}
```

**Production (versioned Git):**
```hcl
module "vpc" {
  source = "git::https://github.com/company/terraform-modules.git//vpc?ref=v2.1.0"
}
```

**Public modules (Registry):**
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.0"
}
```

**When to Use Each:**

| Source | When to Use |
|--------|-------------|
| **Local** | Development, testing, single project |
| **Git (branch)** | Development, testing new module versions |
| **Git (tag)** | Production, stable versioned modules |
| **Registry** | Public modules, well-maintained packages |
| **HTTP/S3** | Distributing modules in restricted networks |

**Best Practice:**

In production, always use **versioned sources** (tags or Registry versions):
```hcl
# ✅ Good - pinned version
module "vpc" {
  source = "git::https://github.com/company/modules.git//vpc?ref=v1.2.0"
}

# ❌ Bad - unstable, can break
module "vpc" {
  source = "git::https://github.com/company/modules.git//vpc"
}
```

</div>

</details>

---

<details>
<summary><strong>6. Terraform Registry Modules</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The [Terraform Registry](https://registry.terraform.io/) hosts thousands of public modules.

**Why Use Registry Modules:**
- Maintained by community or vendors
- Well-documented
- Tested across many projects
- Versioned and stable
- Battle-tested patterns

**Using a Registry Module:**

```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.0"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["us-east-1a", "us-east-1b", "us-east-1c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = false
  
  tags = {
    Terraform   = "true"
    Environment = "prod"
  }
}
```

**Finding Modules:**

1. Go to [registry.terraform.io](https://registry.terraform.io/)
2. Search for service (e.g., "AWS VPC")
3. Review documentation, inputs, outputs
4. Check version history and downloads
5. Copy usage example

**Popular AWS Modules:**

| Module | Purpose |
|--------|---------|
| `terraform-aws-modules/vpc/aws` | VPC with subnets, NAT, etc. |
| `terraform-aws-modules/ec2-instance/aws` | EC2 instances |
| `terraform-aws-modules/rds/aws` | RDS databases |
| `terraform-aws-modules/eks/aws` | EKS clusters |
| `terraform-aws-modules/s3-bucket/aws` | S3 buckets |

**Module Naming Convention:**

```
terraform-<PROVIDER>-<NAME>
```

Examples:
- `terraform-aws-vpc`
- `terraform-azure-network`
- `terraform-google-kubernetes`

**Registry Source Syntax:**

```hcl
module "NAME" {
  source  = "NAMESPACE/NAME/PROVIDER"
  version = "VERSION"
}
```

Example:
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  #         └─ namespace  ─┘  └name┘ └provider┘
  version = "5.1.0"
}
```

**Checking Module Documentation:**

Before using a module:
1. **README** — Usage examples
2. **Inputs** — Required and optional variables
3. **Outputs** — What values are returned
4. **Resources** — What gets created
5. **Examples** — Real-world usage patterns
6. **Versions** — Release history

**Example: AWS VPC Module**

```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.0"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["us-east-1a", "us-east-1b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  
  enable_nat_gateway = true
  single_nat_gateway = true
  
  tags = {
    Environment = "dev"
  }
}

output "vpc_id" {
  value = module.vpc.vpc_id
}

output "private_subnet_ids" {
  value = module.vpc.private_subnets
}
```

**Private Registry (Enterprise):**

Organizations can host private modules:
```hcl
module "vpc" {
  source  = "app.terraform.io/my-org/vpc/aws"
  version = "1.0.0"
}
```

**When to Use Public Modules:**

✅ **Use when:**
- Module is well-maintained (recent updates)
- Many downloads and stars
- Good documentation
- Matches your needs closely

❌ **Don't use when:**
- Unmaintained or abandoned
- Overly complex for your needs
- Security concerns
- Lacks flexibility you need

**Build your own module if public ones don't fit.**

</div>

</details>

---

<details>
<summary><strong>7. Module Versioning</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Versioning prevents breaking changes from affecting your infrastructure.

**Semantic Versioning (SemVer):**

```
MAJOR.MINOR.PATCH
  1  .  2  .  3
```

- **MAJOR** — Breaking changes (1.x → 2.0)
- **MINOR** — New features, backward compatible (1.1 → 1.2)
- **PATCH** — Bug fixes, backward compatible (1.2.0 → 1.2.1)

**Registry Module Versions:**

```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.0"  # Exact version
}
```

**Version Constraints:**

```hcl
# Exact version
version = "5.1.0"

# Greater than or equal
version = ">= 5.0.0"

# Pessimistic constraint (recommended)
version = "~> 5.1"   # Allows 5.1.x, blocks 5.2.x
version = "~> 5.0"   # Allows 5.x.x, blocks 6.0.0

# Range
version = ">= 5.0.0, < 6.0.0"
```

**Git Module Versions:**

**Tag-based (recommended):**
```hcl
module "vpc" {
  source = "git::https://github.com/company/modules.git//vpc?ref=v1.2.0"
}
```

**Branch-based (not recommended for prod):**
```hcl
module "vpc" {
  source = "git::https://github.com/company/modules.git//vpc?ref=main"
}
```

**Commit-based (for specific fixes):**
```hcl
module "vpc" {
  source = "git::https://github.com/company/modules.git//vpc?ref=abc123def"
}
```

**Upgrading Modules:**

**Step 1: Check Changelog**
Review what changed between versions:
```
v1.2.0 → v2.0.0
- Breaking: Removed deprecated `enable_dns` variable
- Added: New `dns_support` variable
- Fixed: Subnet tagging bug
```

**Step 2: Update Version**
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.2.0"  # Was 5.1.0
}
```

**Step 3: Run terraform init -upgrade**
```bash
terraform init -upgrade
```

Downloads the new version.

**Step 4: Plan and Review**
```bash
terraform plan
```

Check for unexpected changes.

**Step 5: Test in Non-Prod First**
Always test upgrades in dev/staging before production.

**Step 6: Apply**
```bash
terraform apply
```

**Lock File for Modules:**

When you run `terraform init`, Terraform creates `.terraform.lock.hcl`:
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.0"
}
```

Lock file ensures everyone uses the same version.

**Best Practices:**

1. **Pin versions in production**
```hcl
# ✅ Good
version = "5.1.0"

# ❌ Bad - unpredictable
version = ">= 5.0.0"
```

2. **Use pessimistic constraints for flexibility**
```hcl
version = "~> 5.1"  # Safe minor/patch updates
```

3. **Test upgrades in lower environments first**

4. **Document breaking changes**
```hcl
# Upgrading from v1.x to v2.0:
# - Replace enable_dns with dns_support
# - Update subnet CIDR calculations
```

5. **Commit lock file**
```bash
git add .terraform.lock.hcl
git commit -m "Lock module versions"
```

**Publishing Your Own Versioned Modules:**

**Git Tags:**
```bash
git tag -a v1.0.0 -m "Initial release"
git push origin v1.0.0
```

**GitHub Releases:**
Create a release from the tag with changelog.

**Users reference by tag:**
```hcl
module "my_module" {
  source = "git::https://github.com/myorg/modules.git//vpc?ref=v1.0.0"
}
```

</div>

</details>

---

<details>
<summary><strong>8. Best Practices for Module Design</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Building good modules requires thoughtful design.

**Principle 1: Single Responsibility**

Each module should do one thing well.

**Good:**
- `vpc` module — Creates VPC, subnets, gateways
- `ec2-instance` module — Creates EC2 instances
- `rds` module — Creates RDS databases

**Bad:**
- `infrastructure` module — Creates VPC, EC2, RDS, S3, everything

**Principle 2: Composition Over Monoliths**

Build small modules and compose them.

```hcl
# ✅ Good - composable
module "vpc" {
  source = "./modules/vpc"
}

module "compute" {
  source = "./modules/compute"
  vpc_id = module.vpc.vpc_id
}

module "database" {
  source    = "./modules/database"
  vpc_id    = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnet_ids
}
```

```hcl
# ❌ Bad - monolithic
module "everything" {
  source = "./modules/infrastructure"
  # Too many inputs, too inflexible
}
```

**Principle 3: Sensible Defaults**

Provide defaults for common scenarios.

```hcl
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "enable_monitoring" {
  description = "Enable CloudWatch monitoring"
  type        = bool
  default     = true
}
```

Users can override when needed.

**Principle 4: Validate Inputs**

Catch errors early.

```hcl
variable "environment" {
  type = string
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Must be dev, staging, or prod."
  }
}
```

**Principle 5: Document Everything**

```hcl
variable "cidr_block" {
  description = "CIDR block for the VPC. Must be a valid IPv4 CIDR (e.g., 10.0.0.0/16)"
  type        = string
}

output "vpc_id" {
  description = "ID of the created VPC. Use this to reference the VPC in other modules."
  value       = aws_vpc.main.id
}
```

**Include README.md:**
- Purpose of the module
- Usage examples
- Input variables table
- Output values table
- Requirements (provider versions, etc.)

**Principle 6: Use Locals for Calculations**

Keep resource blocks clean.

```hcl
locals {
  name_prefix = "${var.project_name}-${var.environment}"
  
  common_tags = {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
  
  subnet_cidrs = [
    for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i)
  ]
}

resource "aws_vpc" "main" {
  cidr_block = var.vpc_cidr
  
  tags = merge(
    local.common_tags,
    { Name = "${local.name_prefix}-vpc" }
  )
}
```

**Principle 7: Expose Useful Outputs**

Return values users might need.

```hcl
output "vpc_id" {
  value = aws_vpc.main.id
}

output "public_subnet_ids" {
  value = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  value = aws_subnet.private[*].id
}

output "nat_gateway_ips" {
  value = aws_nat_gateway.main[*].public_ip
}
```

**Principle 8: Make It Flexible**

Support common variations.

```hcl
variable "create_nat_gateway" {
  description = "Whether to create NAT gateway"
  type        = bool
  default     = true
}

resource "aws_nat_gateway" "main" {
  count = var.create_nat_gateway ? length(var.public_subnets) : 0
  
  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id
}
```

**Principle 9: Avoid Provider Configuration in Modules**

Let the root module configure providers.

**Bad:**
```hcl
# modules/vpc/main.tf
provider "aws" {
  region = "us-east-1"  # ❌ Hardcoded
}
```

**Good:**
```hcl
# Root module
provider "aws" {
  region = var.aws_region
}

module "vpc" {
  source = "./modules/vpc"
}
```

**Principle 10: Test Your Modules**

Create example configurations:
```
modules/vpc/
├── main.tf
├── variables.tf
├── outputs.tf
├── README.md
└── examples/
    ├── basic/
    │   └── main.tf
    └── complete/
        └── main.tf
```

**Example Structure:**

```
terraform-modules/
├── modules/
│   ├── vpc/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── examples/
│   │       └── basic/
│   │           └── main.tf
│   └── ec2/
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       └── README.md
└── README.md
```

**Module Checklist:**

Before publishing or sharing a module:
- [ ] Single, clear responsibility
- [ ] Sensible defaults for common cases
- [ ] Input validation where appropriate
- [ ] Comprehensive documentation (README)
- [ ] Useful outputs
- [ ] Example usage
- [ ] Version tagged (if in Git)
- [ ] Tested in real scenario

</div>

</details>

---

**You've mastered the art of reusable infrastructure.**

Modules let you package patterns into components. Root modules orchestrate. Child modules encapsulate. Registry modules save time. Versioning prevents breakage. Good design makes modules maintainable and shareable.

Next, we'll tackle **workspaces and environment management** — how to handle dev, staging, and production with the same codebase, and why directory-based separation often beats workspaces.