# Shell Scripting

Every command you've learned — navigating filesystems, managing processes, configuring networks, handling storage — can be combined into scripts. Instead of typing the same sequence repeatedly, you write it once and run it forever. Instead of remembering complex procedures, you encode them in files that document themselves.

Shell scripting is where Linux mastery compounds. A backup that takes 15 manual steps becomes one command. A deployment that requires careful sequencing becomes reliable automation. Health checks that you'd forget to run become scheduled tasks that alert you before problems escalate.

This file teaches you to write shell scripts — from basic syntax through conditionals, loops, functions, and the patterns that production scripts use. By the end, you'll automate confidently, handle errors gracefully, and write scripts others can maintain.

---

## Table of Contents

1. [Script Basics](#1-script-basics)
2. [Variables](#2-variables)
3. [Input and Arguments](#3-input-and-arguments)
4. [Conditionals](#4-conditionals)
5. [Loops](#5-loops)
6. [Functions](#6-functions)
7. [Working with Text](#7-working-with-text)
8. [Error Handling](#8-error-handling)
9. [Practical Script Patterns](#9-practical-script-patterns)
10. [Where We Go From Here](#10-where-we-go-from-here)

---

<details>
<summary><strong>1. Script Basics</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

A shell script is a text file containing commands. The shell reads and executes them in order.

### Creating your first script

```bash
#!/bin/bash
# My first script

echo "Hello from ChillSpot!"
date
whoami
```

Save as `hello.sh`, then:

```bash
chmod +x hello.sh                    # Make executable
./hello.sh                           # Run it
```

### The shebang

The first line `#!/bin/bash` is the shebang. It tells the system which interpreter to use. Common options:

```bash
#!/bin/bash                          # Bash (most common)
#!/bin/sh                            # POSIX shell (more portable)
#!/usr/bin/env bash                  # Find bash in PATH (most portable)
```

Without a shebang, the script runs in whatever shell invokes it — potentially causing compatibility issues.

### Comments

```bash
# This is a comment
echo "Hello"  # Inline comment

# Multi-line comments aren't built-in, but you can use:
: '
This is a
multi-line comment
'
```

### Running scripts

Three ways to execute:

```bash
./script.sh                          # Direct (needs execute permission)
bash script.sh                       # Explicit interpreter (no permission needed)
source script.sh                     # Run in current shell (affects your environment)
```

`source` (or `.`) is special — variables set in the script persist in your shell. Useful for loading configurations.

### Exit status

Every command returns an exit status: 0 for success, non-zero for failure.

```bash
ls /tmp
echo $?                              # 0 — success

ls /nonexistent
echo $?                              # 2 — failure
```

Scripts should exit with appropriate status:

```bash
#!/bin/bash
if [ -f /important/file ]; then
    echo "File exists"
    exit 0
else
    echo "File missing!" >&2
    exit 1
fi
```

</div>
</details>

---

<details>
<summary><strong>2. Variables</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Variables store data for later use. No declaration needed — just assign.

### Basic variables

```bash
NAME="ChillSpot"
VERSION=2.5
LOG_DIR="/var/log/chillspot"

echo "Deploying $NAME version $VERSION"
echo "Logs go to ${LOG_DIR}"
```

**No spaces around `=`** — `NAME = "value"` is wrong.

**Quote variables** — `"$VAR"` prevents word splitting issues.

**Braces for clarity** — `${VAR}` distinguishes `${VAR}name` from `$VARname`.

### Environment variables

Variables are local to the script by default. Export to make them available to child processes:

```bash
export DATABASE_URL="postgres://localhost/chillspot"
./app.sh                             # app.sh can now see DATABASE_URL
```

Common environment variables:

| Variable | Purpose |
|----------|---------|
| PATH | Directories to search for commands |
| HOME | User's home directory |
| USER | Current username |
| PWD | Current directory |
| SHELL | User's default shell |

### Command substitution

Capture command output in a variable:

```bash
CURRENT_DATE=$(date +%Y-%m-%d)
FILE_COUNT=$(ls -1 | wc -l)
HOSTNAME=$(hostname)

echo "Backup on $HOSTNAME at $CURRENT_DATE"
```

Old syntax uses backticks: `` `date` ``. Prefer `$(...)` — it's clearer and nests properly.

### Arithmetic

Bash does integer arithmetic with `$((...))`:

```bash
COUNT=5
NEXT=$((COUNT + 1))
DOUBLED=$((COUNT * 2))

echo "$COUNT + 1 = $NEXT"
```

For floating point, use `bc`:

```bash
RESULT=$(echo "scale=2; 10 / 3" | bc)
echo $RESULT                         # 3.33
```

### Arrays

```bash
SERVERS=("web01" "web02" "web03")

echo ${SERVERS[0]}                   # First element: web01
echo ${SERVERS[@]}                   # All elements
echo ${#SERVERS[@]}                  # Count: 3

# Loop through array
for SERVER in "${SERVERS[@]}"; do
    echo "Checking $SERVER"
done
```

### Special variables

| Variable | Meaning |
|----------|---------|
| $0 | Script name |
| $1, $2... | Positional arguments |
| $# | Number of arguments |
| $@ | All arguments (as separate words) |
| $* | All arguments (as single string) |
| $? | Exit status of last command |
| $$ | Current process ID |
| $! | PID of last background process |

</div>
</details>

---

<details>
<summary><strong>3. Input and Arguments</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Scripts need to accept input — from arguments, user interaction, or files.

### Positional arguments

```bash
#!/bin/bash
# deploy.sh — Deploy an application

APP_NAME=$1
ENVIRONMENT=$2

echo "Deploying $APP_NAME to $ENVIRONMENT"
```

Run with:

```bash
./deploy.sh chillspot production
```

### Checking arguments

```bash
#!/bin/bash

if [ $# -lt 2 ]; then
    echo "Usage: $0 <app_name> <environment>"
    exit 1
fi

APP_NAME=$1
ENVIRONMENT=$2
```

### Default values

```bash
ENVIRONMENT=${2:-staging}            # Default to "staging" if $2 is empty
LOG_LEVEL=${LOG_LEVEL:-info}         # Use env var or default
```

### Reading user input

```bash
#!/bin/bash

read -p "Enter your name: " NAME
echo "Hello, $NAME"

read -sp "Enter password: " PASSWORD    # -s for silent (no echo)
echo                                     # Newline after hidden input
```

### Reading from files

```bash
# Read entire file
CONTENT=$(cat config.txt)

# Read line by line
while IFS= read -r LINE; do
    echo "Processing: $LINE"
done < input.txt

# Read specific fields
while IFS=: read -r USER PASS UID GID DESC HOME SHELL; do
    echo "User $USER has home $HOME"
done < /etc/passwd
```

### Here documents

Embed multi-line text:

```bash
cat << EOF
Welcome to ChillSpot Deployment
================================
App: $APP_NAME
Environment: $ENVIRONMENT
Date: $(date)
EOF
```

Use `<<'EOF'` (quoted) to prevent variable expansion.

### Parsing options with getopts

For more complex argument handling:

```bash
#!/bin/bash

while getopts "e:v:h" opt; do
    case $opt in
        e) ENVIRONMENT=$OPTARG ;;
        v) VERSION=$OPTARG ;;
        h) echo "Usage: $0 [-e env] [-v version]"; exit 0 ;;
        ?) echo "Invalid option"; exit 1 ;;
    esac
done

echo "Environment: ${ENVIRONMENT:-production}"
echo "Version: ${VERSION:-latest}"
```

Run with: `./script.sh -e staging -v 2.5`

</div>
</details>

---

<details>
<summary><strong>4. Conditionals</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Conditionals let scripts make decisions based on conditions.

### Basic if statement

```bash
if [ condition ]; then
    # commands
fi

if [ condition ]; then
    # commands
else
    # alternative
fi

if [ condition1 ]; then
    # commands
elif [ condition2 ]; then
    # commands
else
    # default
fi
```

### Test operators

**File tests:**

| Operator | True if |
|----------|---------|
| -e FILE | File exists |
| -f FILE | Is regular file |
| -d FILE | Is directory |
| -r FILE | Is readable |
| -w FILE | Is writable |
| -x FILE | Is executable |
| -s FILE | File has size > 0 |

```bash
if [ -f /etc/nginx/nginx.conf ]; then
    echo "Nginx config exists"
fi

if [ -d /srv/chillspot-streaming ]; then
    echo "App directory exists"
fi
```

**String tests:**

| Operator | True if |
|----------|---------|
| -z STRING | String is empty |
| -n STRING | String is not empty |
| S1 = S2 | Strings are equal |
| S1 != S2 | Strings are not equal |

```bash
if [ -z "$ENVIRONMENT" ]; then
    echo "ENVIRONMENT not set"
    exit 1
fi

if [ "$USER" = "root" ]; then
    echo "Running as root"
fi
```

**Numeric tests:**

| Operator | Meaning |
|----------|---------|
| -eq | Equal |
| -ne | Not equal |
| -lt | Less than |
| -le | Less or equal |
| -gt | Greater than |
| -ge | Greater or equal |

```bash
if [ $COUNT -gt 10 ]; then
    echo "Count exceeds 10"
fi
```

### Combining conditions

```bash
# AND
if [ -f config.yaml ] && [ -r config.yaml ]; then
    echo "Config file exists and is readable"
fi

# OR
if [ "$ENV" = "dev" ] || [ "$ENV" = "staging" ]; then
    echo "Non-production environment"
fi

# NOT
if [ ! -d /backup ]; then
    mkdir /backup
fi
```

### Double brackets (Bash extension)

`[[ ]]` is more powerful and forgiving:

```bash
# Pattern matching
if [[ "$FILE" == *.log ]]; then
    echo "It's a log file"
fi

# Regex matching
if [[ "$EMAIL" =~ ^[a-z]+@[a-z]+\.[a-z]+$ ]]; then
    echo "Valid email format"
fi

# No need to quote variables
if [[ $VAR == "value" ]]; then
    echo "Match"
fi
```

### Case statement

For multiple conditions on one variable:

```bash
case $ENVIRONMENT in
    production|prod)
        echo "Production deployment"
        REPLICAS=5
        ;;
    staging)
        echo "Staging deployment"
        REPLICAS=2
        ;;
    dev|development)
        echo "Development deployment"
        REPLICAS=1
        ;;
    *)
        echo "Unknown environment: $ENVIRONMENT"
        exit 1
        ;;
esac
```

</div>
</details>

---

<details>
<summary><strong>5. Loops</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Loops repeat commands — over lists, counts, or until conditions change.

### For loops

**Iterate over list:**

```bash
for SERVER in web01 web02 web03; do
    echo "Pinging $SERVER"
    ping -c 1 $SERVER
done
```

**Iterate over array:**

```bash
SERVERS=("web01" "web02" "web03")
for SERVER in "${SERVERS[@]}"; do
    ssh $SERVER "systemctl status nginx"
done
```

**Iterate over files:**

```bash
for FILE in /var/log/*.log; do
    echo "Processing $FILE"
    gzip "$FILE"
done
```

**Iterate over command output:**

```bash
for USER in $(cat /etc/passwd | cut -d: -f1); do
    echo "Found user: $USER"
done
```

**C-style for loop:**

```bash
for ((i=1; i<=5; i++)); do
    echo "Iteration $i"
done
```

### While loops

**Basic while:**

```bash
COUNT=0
while [ $COUNT -lt 5 ]; do
    echo "Count: $COUNT"
    COUNT=$((COUNT + 1))
done
```

**Read file line by line:**

```bash
while IFS= read -r LINE; do
    echo "Line: $LINE"
done < /etc/hosts
```

**Wait for condition:**

```bash
while ! curl -s http://localhost:8080/health > /dev/null; do
    echo "Waiting for service..."
    sleep 2
done
echo "Service is up!"
```

### Until loops

Opposite of while — runs until condition becomes true:

```bash
until [ -f /tmp/ready.flag ]; do
    echo "Waiting for ready flag..."
    sleep 5
done
echo "Ready!"
```

### Loop control

**Break — exit loop:**

```bash
for SERVER in "${SERVERS[@]}"; do
    if ! ping -c 1 $SERVER > /dev/null; then
        echo "$SERVER is down!"
        break
    fi
done
```

**Continue — skip to next iteration:**

```bash
for FILE in *.log; do
    if [ ! -s "$FILE" ]; then
        continue                     # Skip empty files
    fi
    gzip "$FILE"
done
```

### Practical example

Health check with retry:

```bash
MAX_ATTEMPTS=5
ATTEMPT=1

while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
    if curl -sf http://localhost:8080/health > /dev/null; then
        echo "Service healthy after $ATTEMPT attempts"
        exit 0
    fi
    echo "Attempt $ATTEMPT failed, retrying..."
    ATTEMPT=$((ATTEMPT + 1))
    sleep 5
done

echo "Service failed to become healthy"
exit 1
```

</div>
</details>

---

<details>
<summary><strong>6. Functions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Functions organize code into reusable blocks.

### Defining functions

```bash
# Style 1
function greet() {
    echo "Hello, $1!"
}

# Style 2 (POSIX compatible)
greet() {
    echo "Hello, $1!"
}

# Call the function
greet "ChillSpot"
```

### Arguments in functions

Functions receive arguments like scripts — via `$1`, `$2`, etc.:

```bash
deploy() {
    local APP=$1
    local ENV=$2
    
    echo "Deploying $APP to $ENV"
    # deployment logic here
}

deploy "chillspot" "production"
```

### Local variables

Variables inside functions are global by default. Use `local` to scope them:

```bash
process_file() {
    local FILENAME=$1
    local LINE_COUNT=$(wc -l < "$FILENAME")
    
    echo "$FILENAME has $LINE_COUNT lines"
}
```

Without `local`, `FILENAME` would pollute the global namespace.

### Return values

Functions return exit status (0-255), not arbitrary values:

```bash
is_running() {
    pgrep -x "$1" > /dev/null
    return $?
}

if is_running nginx; then
    echo "Nginx is running"
fi
```

To return data, echo it and capture with command substitution:

```bash
get_memory_usage() {
    free | awk '/Mem:/ {printf "%.1f", $3/$2 * 100}'
}

USAGE=$(get_memory_usage)
echo "Memory usage: ${USAGE}%"
```

### Practical functions

```bash
#!/bin/bash

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

die() {
    log "ERROR: $1" >&2
    exit 1
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        die "This script must be run as root"
    fi
}

backup_file() {
    local FILE=$1
    local BACKUP="${FILE}.bak.$(date +%Y%m%d)"
    
    if [ -f "$FILE" ]; then
        cp "$FILE" "$BACKUP"
        log "Backed up $FILE to $BACKUP"
    fi
}

# Usage
check_root
backup_file /etc/nginx/nginx.conf
log "Starting deployment"
```

</div>
</details>

---

<details>
<summary><strong>7. Working with Text</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Shell scripts often process text — logs, configs, command output. These tools are essential.

### grep — Filter lines

```bash
grep "error" /var/log/app.log        # Lines containing "error"
grep -i "error" /var/log/app.log     # Case insensitive
grep -v "debug" /var/log/app.log     # Lines NOT containing "debug"
grep -c "error" /var/log/app.log     # Count matches
grep -n "error" /var/log/app.log     # Show line numbers
grep -r "TODO" /src                  # Recursive search
```

### sed — Stream editor

```bash
# Replace first occurrence per line
sed 's/old/new/' file.txt

# Replace all occurrences
sed 's/old/new/g' file.txt

# Replace in place
sed -i 's/old/new/g' file.txt

# Delete lines matching pattern
sed '/pattern/d' file.txt

# Print specific lines
sed -n '5,10p' file.txt              # Lines 5-10
```

### awk — Column processing

```bash
# Print specific columns
awk '{print $1, $3}' file.txt

# With custom delimiter
awk -F: '{print $1, $7}' /etc/passwd

# Filter and print
awk '$3 > 100 {print $1}' data.txt

# Calculate sum
awk '{sum += $1} END {print sum}' numbers.txt

# Formatted output
awk '{printf "%-10s %5d\n", $1, $2}' data.txt
```

### cut — Extract columns

```bash
cut -d: -f1 /etc/passwd              # First field, colon delimiter
cut -d, -f1,3 data.csv               # Fields 1 and 3
cut -c1-10 file.txt                  # Characters 1-10
```

### sort and uniq

```bash
sort file.txt                        # Sort lines
sort -r file.txt                     # Reverse sort
sort -n numbers.txt                  # Numeric sort
sort -k2 data.txt                    # Sort by second column

uniq file.txt                        # Remove adjacent duplicates
sort file.txt | uniq                 # Remove all duplicates
sort file.txt | uniq -c              # Count occurrences
```

### Combining tools

Parse Apache access log for top IPs:

```bash
awk '{print $1}' access.log | sort | uniq -c | sort -rn | head -10
```

Find errors in the last hour:

```bash
grep "$(date -d '1 hour ago' '+%Y-%m-%d %H')" app.log | grep -i error
```

Extract and count HTTP status codes:

```bash
awk '{print $9}' access.log | sort | uniq -c | sort -rn
```

</div>
</details>

---

<details>
<summary><strong>8. Error Handling</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Production scripts must handle errors gracefully.

### Exit on error

```bash
#!/bin/bash
set -e                               # Exit immediately on error
```

With `set -e`, any command returning non-zero stops the script. Usually what you want.

### Strict mode

A robust starting point:

```bash
#!/bin/bash
set -euo pipefail

# -e: Exit on error
# -u: Error on undefined variables
# -o pipefail: Pipeline fails if any command fails
```

### Trapping errors

Run cleanup code on exit:

```bash
#!/bin/bash
set -e

cleanup() {
    echo "Cleaning up..."
    rm -f /tmp/lockfile
}

trap cleanup EXIT                    # Run cleanup on any exit

# Script logic here
touch /tmp/lockfile
# ... more commands ...
```

Trap specific signals:

```bash
trap 'echo "Interrupted!"; exit 1' INT TERM
trap cleanup EXIT
```

### Checking command success

```bash
# Method 1: Check $?
command
if [ $? -ne 0 ]; then
    echo "Command failed"
    exit 1
fi

# Method 2: Direct check
if ! command; then
    echo "Command failed"
    exit 1
fi

# Method 3: Short-circuit
command || { echo "Command failed"; exit 1; }
```

### Handling expected failures

Sometimes failures are OK:

```bash
set -e

# This might fail, and that's fine
rm -f /tmp/optional-file || true

# Continue with script
```

Or disable temporarily:

```bash
set +e                               # Disable exit-on-error
risky_command
RESULT=$?
set -e                               # Re-enable

if [ $RESULT -ne 0 ]; then
    echo "Handled the failure"
fi
```

### Logging and debugging

```bash
#!/bin/bash
set -x                               # Print commands before executing (debug)

LOG_FILE="/var/log/deploy.log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "Deployment started"
# Commands here are both executed and printed
```

### Timeout for commands

Prevent hanging:

```bash
timeout 30 curl http://slow-server/api || {
    echo "Request timed out"
    exit 1
}
```

</div>
</details>

---

<details>
<summary><strong>9. Practical Script Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Real-world scripts follow common patterns. Here are templates you'll reuse.

### Script template

```bash
#!/bin/bash
set -euo pipefail

# ============================================================
# ChillSpot Deployment Script
# ============================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="/var/log/chillspot/deploy.log"

# ------------------------------------------------------------
# Functions
# ------------------------------------------------------------

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

die() {
    log "ERROR: $1"
    exit 1
}

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Options:
    -e, --environment   Environment (dev|staging|production)
    -v, --version       Version to deploy
    -h, --help          Show this help

Example:
    $(basename "$0") -e production -v 2.5.0
EOF
    exit 0
}

# ------------------------------------------------------------
# Parse Arguments
# ------------------------------------------------------------

ENVIRONMENT=""
VERSION=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -e|--environment) ENVIRONMENT="$2"; shift 2 ;;
        -v|--version) VERSION="$2"; shift 2 ;;
        -h|--help) usage ;;
        *) die "Unknown option: $1" ;;
    esac
done

[[ -z "$ENVIRONMENT" ]] && die "Environment is required"
[[ -z "$VERSION" ]] && die "Version is required"

# ------------------------------------------------------------
# Main
# ------------------------------------------------------------

log "Starting deployment: $VERSION to $ENVIRONMENT"

# Your deployment logic here

log "Deployment complete"
```

### Backup script

```bash
#!/bin/bash
set -euo pipefail

BACKUP_DIR="/backup"
SOURCE_DIR="/srv/chillspot-streaming"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/chillspot_${DATE}.tar.gz"
RETENTION_DAYS=7

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Create backup
log "Creating backup: $BACKUP_FILE"
tar czf "$BACKUP_FILE" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")"

# Verify backup
if tar tzf "$BACKUP_FILE" > /dev/null 2>&1; then
    log "Backup verified successfully"
else
    log "ERROR: Backup verification failed"
    exit 1
fi

# Cleanup old backups
log "Removing backups older than $RETENTION_DAYS days"
find "$BACKUP_DIR" -name "chillspot_*.tar.gz" -mtime +$RETENTION_DAYS -delete

log "Backup complete: $(du -h "$BACKUP_FILE" | cut -f1)"
```

### Health check script

```bash
#!/bin/bash
set -euo pipefail

SERVICES=("nginx" "postgresql" "chillspot-streaming")
ENDPOINTS=("http://localhost/health" "http://localhost:8080/api/health")
ALERT_EMAIL="ops@chillspot.io"

check_service() {
    local SERVICE=$1
    if systemctl is-active --quiet "$SERVICE"; then
        echo "✓ $SERVICE is running"
        return 0
    else
        echo "✗ $SERVICE is not running"
        return 1
    fi
}

check_endpoint() {
    local URL=$1
    if curl -sf --max-time 5 "$URL" > /dev/null; then
        echo "✓ $URL is responding"
        return 0
    else
        echo "✗ $URL is not responding"
        return 1
    fi
}

FAILURES=()

for SERVICE in "${SERVICES[@]}"; do
    check_service "$SERVICE" || FAILURES+=("Service: $SERVICE")
done

for ENDPOINT in "${ENDPOINTS[@]}"; do
    check_endpoint "$ENDPOINT" || FAILURES+=("Endpoint: $ENDPOINT")
done

if [ ${#FAILURES[@]} -gt 0 ]; then
    echo ""
    echo "FAILURES DETECTED:"
    printf '%s\n' "${FAILURES[@]}"
    
    # Send alert
    printf '%s\n' "${FAILURES[@]}" | mail -s "ChillSpot Health Check Failed" "$ALERT_EMAIL"
    exit 1
fi

echo ""
echo "All checks passed"
```

### Locking to prevent concurrent runs

```bash
#!/bin/bash
set -euo pipefail

LOCK_FILE="/var/run/deploy.lock"

cleanup() {
    rm -f "$LOCK_FILE"
}

# Check for existing lock
if [ -f "$LOCK_FILE" ]; then
    PID=$(cat "$LOCK_FILE")
    if kill -0 "$PID" 2>/dev/null; then
        echo "Another instance is running (PID: $PID)"
        exit 1
    else
        echo "Removing stale lock file"
        rm -f "$LOCK_FILE"
    fi
fi

# Create lock
echo $$ > "$LOCK_FILE"
trap cleanup EXIT

# Your script logic here
echo "Running with lock..."
sleep 10
```

</div>
</details>

---

## 10. Where We Go From Here

You now write shell scripts — automating backups, deployments, health checks, and routine tasks. You handle arguments, make decisions with conditionals, repeat with loops, organize with functions, and manage errors gracefully.

But scripts produce output, and systems produce logs. When ChillSpot has issues at 3 AM, you need to find what went wrong. Log files hold the answers — if you know how to read them. Monitoring shows system health — if you know what to watch.

File 09 covers **Logs, Monitoring & Troubleshooting** — understanding log systems, querying journals, monitoring resources, and the systematic approach to diagnosing problems.

Your automation is ready. Let's learn to see what it's doing.
