# **07. Workspaces & Environment Management — Managing Multiple Environments**

You've built modules. Your code is clean and reusable.
But now you face a new challenge: you need to deploy the same infrastructure across dev, staging, and production — with different configurations for each.

Same VPC structure, different CIDR blocks.
Same EC2 instances, different counts and types.
Same RDS database, different storage and backup settings.

How do you manage multiple environments without duplicating code?

**Terraform offers workspaces.** But here's the truth: workspaces look convenient, but they create problems at scale.
We'll explore how workspaces work, then show you a better way — **directory-based environment separation** that gives you safety, clarity, and control.

---

## Table of Contents
1. [The Multi-Environment Problem](#1-the-multi-environment-problem)
2. [Terraform Workspaces](#2-terraform-workspaces)
3. [Workspace Commands](#3-workspace-commands)
4. [Environment Strategies](#4-environment-strategies)
5. [Workspace Variables](#5-workspace-variables)
6. [When to Use Workspaces (and when NOT to)](#6-when-to-use-workspaces-and-when-not-to)
7. [Production Environment Patterns](#7-production-environment-patterns)

---

<details>
<summary><strong>1. The Multi-Environment Problem</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every organization runs multiple environments:
- **Dev** — Developers test features
- **Staging** — QA validates before production
- **Production** — Real users, real data

Each environment needs the same infrastructure pattern, but with different configurations.

**The naive approach:**

Copy-paste everything:
```
project/
├── dev/
│   ├── main.tf       # Copy of code
│   ├── variables.tf  # Copy of code
│   └── outputs.tf    # Copy of code
├── staging/
│   ├── main.tf       # Same code, slightly different
│   ├── variables.tf
│   └── outputs.tf
└── prod/
    ├── main.tf       # Same code again
    ├── variables.tf
    └── outputs.tf
```

**Problems:**
- Fix a bug in dev? Copy-paste to staging and prod.
- Three copies of the same logic.
- Drift happens — prod slowly diverges from dev.
- Hard to maintain.

**What you actually want:**

One codebase, multiple deployments.
```
infrastructure/
├── modules/         # Shared logic
└── environments/    # Different configs
    ├── dev/
    ├── staging/
    └── prod/
```

**The question is: how do you separate environments?**

Two main approaches:
1. **Workspaces** — Same code, same directory, switch context
2. **Directories** — Same code (modules), separate root modules per environment

Let's explore both, then make an opinionated recommendation.

</div>

</details>

---

<details>
<summary><strong>2. Terraform Workspaces</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Workspaces let you manage multiple state files from one configuration.

**How it works:**

You write your Terraform code once.
You create multiple workspaces (dev, staging, prod).
Each workspace has its own state file.
You switch between workspaces to deploy to different environments.

**Default workspace:**

Every Terraform project starts with a workspace called `default`.

```bash
terraform workspace list
# * default
```

The `*` shows which workspace is active.

**Creating workspaces:**

```bash
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod
```

Now you have:
```
terraform.tfstate.d/
├── dev/
│   └── terraform.tfstate
├── staging/
│   └── terraform.tfstate
└── prod/
    └── terraform.tfstate
```

**Switching workspaces:**

```bash
terraform workspace select dev
terraform apply  # Deploys to dev

terraform workspace select prod
terraform apply  # Deploys to prod
```

Same code, different state files.

**Accessing current workspace in code:**

```hcl
resource "aws_instance" "web" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name        = "web-${terraform.workspace}"
    Environment = terraform.workspace
  }
}
```

In `dev` workspace → creates `web-dev`
In `prod` workspace → creates `web-prod`

**Example with configuration per workspace:**

```hcl
locals {
  env_config = {
    dev = {
      instance_type  = "t3.micro"
      instance_count = 1
    }
    staging = {
      instance_type  = "t3.small"
      instance_count = 2
    }
    prod = {
      instance_type  = "t3.large"
      instance_count = 5
    }
  }
  
  config = local.env_config[terraform.workspace]
}

resource "aws_instance" "app" {
  count         = local.config.instance_count
  ami           = "ami-abc123"
  instance_type = local.config.instance_type
}
```

Switch workspace → different configuration → different resources.

**Looks convenient, right?**

It is — for simple cases. But it breaks down in real production environments.

</div>

</details>

---

<details>
<summary><strong>3. Workspace Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Here are all the workspace commands you need to know.

**List workspaces:**
```bash
terraform workspace list
```

Output:
```
  default
* dev
  staging
  prod
```

The `*` indicates the current workspace.

**Show current workspace:**
```bash
terraform workspace show
```

Output:
```
dev
```

**Create new workspace:**
```bash
terraform workspace new staging
```

Creates workspace and switches to it.

**Switch workspace:**
```bash
terraform workspace select prod
```

**Delete workspace:**
```bash
terraform workspace delete staging
```

**You can't delete the current workspace.** Switch first, then delete.

**Can't delete a workspace with resources:**
```bash
terraform workspace select staging
terraform destroy  # Remove all resources first
terraform workspace select dev
terraform workspace delete staging  # Now it works
```

**Typical workflow:**

```bash
# Create and deploy to dev
terraform workspace new dev
terraform apply

# Create and deploy to staging
terraform workspace new staging
terraform apply

# Deploy to prod
terraform workspace new prod
terraform apply

# Switch between them
terraform workspace select dev
terraform plan

terraform workspace select prod
terraform plan
```

**Hidden danger:**

You're in the `prod` workspace. You forget. You run `terraform destroy`.
Prod is gone.

**There's no safety check. Workspaces are silent about which environment you're affecting.**

</div>

</details>

---

<details>
<summary><strong>4. Environment Strategies</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Let's compare the two main strategies for managing environments.

**Strategy 1: Workspaces (Same Directory)**

```
project/
├── main.tf
├── variables.tf
├── outputs.tf
└── terraform.tfstate.d/
    ├── dev/
    ├── staging/
    └── prod/
```

**Pros:**
- One codebase
- Fast switching between environments
- Less duplication

**Cons:**
- Same backend for all environments (shared failure point)
- Easy to accidentally destroy wrong environment
- Hard to have different configurations (becomes messy with conditionals)
- Can't review prod changes separately from dev
- Git history mixed across environments
- Team collaboration issues (who's in which workspace?)

**Strategy 2: Directory-Based (Separate Root Modules)**

```
infrastructure/
├── modules/
│   ├── vpc/
│   ├── compute/
│   └── database/
└── environments/
    ├── dev/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── terraform.tfvars
    │   └── backend.tf
    ├── staging/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── terraform.tfvars
    │   └── backend.tf
    └── prod/
        ├── main.tf
        ├── variables.tf
        ├── terraform.tfvars
        └── backend.tf
```

**Pros:**
- Clear separation of environments
- Independent state files (different backends)
- Explicit — you're always in a specific directory
- Easy to enforce different permissions (prod locked down)
- Git history per environment
- Can have different provider configs
- Team can work on dev without touching prod
- CI/CD friendly (different pipelines per directory)

**Cons:**
- Slightly more code (but modules reduce duplication)
- Must `cd` between directories

**OPINIONATED RECOMMENDATION:**

**Use directory-based separation for production environments.**

Workspaces are fine for temporary testing or personal dev environments, but for real dev/staging/prod infrastructure:

**❌ Don't do this:**
```bash
terraform workspace select prod
terraform apply  # Hope you didn't mean dev
```

**✅ Do this:**
```bash
cd environments/prod
terraform apply  # Explicit. Safe. Clear.
```

**Why directories win:**

1. **Explicitness** — You always know where you are
2. **Safety** — Can't accidentally affect prod when working in dev/
3. **Independent backends** — Prod state in separate S3 bucket with stricter access
4. **Clear Git history** — Changes to prod are in environments/prod/
5. **Different configurations** — Prod can use different provider versions, regions, accounts
6. **Team collaboration** — Junior devs can't access prod/ directory
7. **CI/CD clarity** — Different pipelines for each environment

**When workspaces are okay:**

- Personal experimentation
- Temporary feature testing
- Non-critical environments
- Single-developer projects

**Example of directory-based structure:**

```
infrastructure/
├── modules/
│   └── web-app/
│       ├── main.tf
│       ├── variables.tf
│       └── outputs.tf
└── environments/
    ├── dev/
    │   ├── main.tf
    │   ├── terraform.tfvars
    │   └── backend.tf
    ├── staging/
    │   ├── main.tf
    │   ├── terraform.tfvars
    │   └── backend.tf
    └── prod/
        ├── main.tf
        ├── terraform.tfvars
        └── backend.tf
```

**environments/dev/main.tf:**
```hcl
module "web_app" {
  source = "../../modules/web-app"
  
  environment    = "dev"
  instance_type  = "t3.micro"
  instance_count = 1
}
```

**environments/prod/main.tf:**
```hcl
module "web_app" {
  source = "../../modules/web-app"
  
  environment    = "prod"
  instance_type  = "t3.large"
  instance_count = 5
}
```

Same module, different parameters, completely separate state.

</div>

</details>

---

<details>
<summary><strong>5. Workspace Variables</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

If you do use workspaces, here's how to configure per-workspace settings.

**Method 1: Conditional Locals**

```hcl
locals {
  env_config = {
    dev = {
      instance_type = "t3.micro"
      db_storage    = 20
    }
    staging = {
      instance_type = "t3.small"
      db_storage    = 50
    }
    prod = {
      instance_type = "t3.large"
      db_storage    = 100
    }
  }
  
  config = local.env_config[terraform.workspace]
}

resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = local.config.instance_type
}
```

**Method 2: Workspace-Specific tfvars Files**

```
project/
├── main.tf
├── dev.tfvars
├── staging.tfvars
└── prod.tfvars
```

**dev.tfvars:**
```hcl
environment    = "dev"
instance_type  = "t3.micro"
instance_count = 1
```

**prod.tfvars:**
```hcl
environment    = "prod"
instance_type  = "t3.large"
instance_count = 5
```

**Deploy:**
```bash
terraform workspace select dev
terraform apply -var-file="dev.tfvars"

terraform workspace select prod
terraform apply -var-file="prod.tfvars"
```

**Method 3: Lookup from Workspace Name**

```hcl
variable "instance_types" {
  type = map(string)
  default = {
    dev     = "t3.micro"
    staging = "t3.small"
    prod    = "t3.large"
  }
}

resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = var.instance_types[terraform.workspace]
}
```

**Problem with all these approaches:**

Your code becomes a maze of conditionals and lookups.
The more environments you add, the messier it gets.

**With directories, each environment has clean, explicit values:**

**environments/dev/terraform.tfvars:**
```hcl
instance_type = "t3.micro"
```

**environments/prod/terraform.tfvars:**
```hcl
instance_type = "t3.large"
```

No conditionals. No lookups. Just values.

</div>

</details>

---

<details>
<summary><strong>6. When to Use Workspaces (and when NOT to)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Let's be clear about when workspaces are appropriate.

**✅ Use workspaces for:**

**Temporary environments:**
```bash
terraform workspace new feature-xyz
terraform apply  # Test your feature
terraform destroy
terraform workspace delete feature-xyz
```

**Personal dev environments:**
```bash
terraform workspace new alice-test
# Alice's sandbox
```

**A/B testing infrastructure:**
```bash
terraform workspace new config-a
terraform workspace new config-b
# Compare performance
```

**Non-critical experimentation:**
When destroying everything is no big deal.

**❌ DON'T use workspaces for:**

**Production environments:**
```bash
# ❌ Bad
terraform workspace select prod
terraform destroy  # Oops
```

**Long-lived environments (dev, staging, prod):**
Too easy to make mistakes over time.

**When different environments need different:**
- Backend configurations
- Provider versions
- AWS accounts
- Regions

**When multiple people manage infrastructure:**
Workspaces create coordination problems.

**Critical infrastructure:**
Where mistakes have high costs.

**The core issue:**

Workspaces share:
- Same code directory
- Same backend configuration
- Same provider setup
- Same Git history

For production, you want these separated.

**Real-world failure scenario:**

```bash
# Developer thinks they're in dev
terraform workspace show
# prod  ← Oh no

terraform apply  # Changes prod
# Or worse:
terraform destroy  # Destroys prod
```

**With directories, this doesn't happen:**

```bash
pwd
# /infrastructure/environments/dev

terraform apply  # Clearly in dev/

# To affect prod, must explicitly:
cd ../prod
terraform apply
```

**The principle:**

**Workspaces = runtime switching**
**Directories = compile-time separation**

For production, prefer compile-time separation.

</div>

</details>

---

<details>
<summary><strong>7. Production Environment Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Here's how to structure environments properly for production use.

**Pattern 1: Directory-Based with Shared Modules**

```
infrastructure/
├── modules/
│   ├── networking/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   ├── compute/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   └── database/
│       ├── main.tf
│       ├── variables.tf
│       └── outputs.tf
└── environments/
    ├── dev/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── terraform.tfvars
    │   ├── backend.tf
    │   └── outputs.tf
    ├── staging/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── terraform.tfvars
    │   ├── backend.tf
    │   └── outputs.tf
    └── prod/
        ├── main.tf
        ├── variables.tf
        ├── terraform.tfvars
        ├── backend.tf
        └── outputs.tf
```

**environments/dev/main.tf:**
```hcl
terraform {
  required_version = ">= 1.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = {
      Environment = "dev"
      ManagedBy   = "Terraform"
      Project     = var.project_name
    }
  }
}

module "networking" {
  source = "../../modules/networking"
  
  environment = "dev"
  vpc_cidr    = "10.0.0.0/16"
  az_count    = 2
}

module "compute" {
  source = "../../modules/compute"
  
  environment    = "dev"
  vpc_id         = module.networking.vpc_id
  subnet_ids     = module.networking.private_subnet_ids
  instance_type  = "t3.micro"
  instance_count = 1
}

module "database" {
  source = "../../modules/database"
  
  environment   = "dev"
  vpc_id        = module.networking.vpc_id
  subnet_ids    = module.networking.private_subnet_ids
  instance_class = "db.t3.micro"
  storage_gb     = 20
}
```

**environments/dev/backend.tf:**
```hcl
terraform {
  backend "s3" {
    bucket         = "company-terraform-state-dev"
    key            = "infrastructure/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock-dev"
  }
}
```

**environments/prod/backend.tf:**
```hcl
terraform {
  backend "s3" {
    bucket         = "company-terraform-state-prod"
    key            = "infrastructure/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock-prod"
  }
}
```

**Notice:**
- Different state buckets per environment
- Different DynamoDB tables for locking
- Can restrict prod bucket access via IAM

**Pattern 2: Multi-Account Structure**

For enterprises, each environment lives in a separate AWS account.

```
infrastructure/
├── modules/
└── accounts/
    ├── dev/
    │   └── 123456789012/  # Dev AWS account
    ├── staging/
    │   └── 234567890123/  # Staging AWS account
    └── prod/
        └── 345678901234/  # Prod AWS account
```

**accounts/prod/main.tf:**
```hcl
provider "aws" {
  region = "us-east-1"
  
  assume_role {
    role_arn = "arn:aws:iam::345678901234:role/TerraformRole"
  }
}
```

Each account has its own IAM permissions, billing, and isolation.

**Pattern 3: Region-Based Structure**

For multi-region deployments:

```
infrastructure/
├── modules/
└── environments/
    └── prod/
        ├── us-east-1/
        │   ├── main.tf
        │   └── backend.tf
        ├── us-west-2/
        │   ├── main.tf
        │   └── backend.tf
        └── eu-west-1/
            ├── main.tf
            └── backend.tf
```

**Deployment Workflow:**

```bash
# Deploy to dev
cd environments/dev
terraform init
terraform plan
terraform apply

# Deploy to staging
cd ../staging
terraform init
terraform plan
terraform apply

# Deploy to prod (separate approval process)
cd ../prod
terraform init
terraform plan -out=tfplan
# Review plan, get approval
terraform apply tfplan
```

**Benefits:**

1. **Explicit** — Always know which environment you're in
2. **Safe** — Can't accidentally affect prod from dev/
3. **Independent** — Each environment has its own state, backend, provider config
4. **Git-friendly** — Changes to prod are isolated in Git history
5. **CI/CD ready** — Easy to build separate pipelines per environment
6. **Access control** — Lock down prod/ directory via IAM or file permissions
7. **Maintainable** — Clear structure scales to dozens of environments

**Access Control Example:**

```bash
# Dev team can access dev and staging
chmod 755 environments/dev
chmod 755 environments/staging

# Only ops team can access prod
chmod 700 environments/prod
chown ops:ops environments/prod
```

**CI/CD Pipeline Example:**

```yaml
# .github/workflows/dev.yml
on:
  push:
    paths:
      - 'environments/dev/**'
jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - working-directory: environments/dev
        run: |
          terraform init
          terraform plan
          terraform apply -auto-approve
```

```yaml
# .github/workflows/prod.yml
on:
  push:
    paths:
      - 'environments/prod/**'
jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - working-directory: environments/prod
        run: |
          terraform init
          terraform plan -out=tfplan
          # Require manual approval
          terraform apply tfplan
```

**Summary:**

- **Modules** hold reusable logic
- **Environments** hold configurations
- Each environment is a separate root module
- Shared code through modules, isolated deployment through directories

**This is the pattern used by most production Terraform teams.**

</div>

</details>

---

**Environment separation is critical.**

Workspaces offer convenience but hide danger. Directory-based separation gives you clarity, safety, and control.
For production infrastructure, choose explicitness over convenience. Your future self — and your team — will thank you.

Next, we'll tackle **remote state and backends** — how to store state safely in S3 with DynamoDB locking, share state across teams, and migrate from local to remote state.