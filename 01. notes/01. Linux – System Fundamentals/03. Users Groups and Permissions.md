# Users, Groups & Permissions

Linux is a multi-user operating system. This isn't a historical footnote — it's a core design principle that shapes everything. Multiple users can log in simultaneously, run processes, and access files, all on the same machine. Servers routinely handle dozens of services, each running as different users, all isolated from each other.

This multi-user reality creates a problem: how do you control who can access what? You don't want a web server reading your private SSH keys. You don't want a junior admin accidentally deleting production configs. You don't want one customer's data accessible to another customer's application.

The answer is Linux's permission system — a simple but powerful model built on three concepts: users, groups, and permission bits. Master these, and you'll never be confused by "Permission denied" again. You'll know exactly why access was blocked and how to fix it properly.

---

## Table of Contents

1. [Users — Identity on Linux](#1-users--identity-on-linux)
2. [Groups — Collective Access](#2-groups--collective-access)
3. [How Permissions Work](#3-how-permissions-work)
4. [Reading Permission Strings](#4-reading-permission-strings)
5. [Changing Permissions with chmod](#5-changing-permissions-with-chmod)
6. [Changing Ownership with chown and chgrp](#6-changing-ownership-with-chown-and-chgrp)
7. [Special Permissions — setuid, setgid, sticky bit](#7-special-permissions--setuid-setgid-sticky-bit)
8. [Default Permissions and umask](#8-default-permissions-and-umask)
9. [Real-World Permission Patterns](#9-real-world-permission-patterns)
10. [Where We Go From Here](#10-where-we-go-from-here)

---

<details>
<summary><strong>1. Users — Identity on Linux</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every process runs as a user. Every file is owned by a user. When you log in, you become a user. This identity determines what you can do.

### Human users vs system users

**Human users** are people who log in — `d.akhilteja`, `t.charan`, the actual humans using the system.

**System users** are created for services. When ChillSpot Streaming runs, it doesn't run as `root` or as your personal account. It runs as a dedicated user like `chillspot` — an account that exists solely for that service. This isolation means if the service gets compromised, the attacker only has access to what that service user can touch.

### The root user

User ID 0 is `root` — the superuser with unlimited power. Root can read any file, kill any process, modify any setting. This power is dangerous, which is why you don't run as root for daily work. You use a regular account and escalate privileges with `sudo` only when necessary.

### Where user info lives

User accounts are defined in `/etc/passwd`:

```bash
cat /etc/passwd
```

Each line represents a user:

```
d.akhilteja:x:1000:1000:Akhil Teja:/home/d.akhilteja:/bin/bash
```

| Field | Meaning |
|-------|---------|
| `d.akhilteja` | Username |
| `x` | Password placeholder (actual hash in `/etc/shadow`) |
| `1000` | User ID (UID) |
| `1000` | Primary group ID (GID) |
| `Akhil Teja` | Comment/full name |
| `/home/d.akhilteja` | Home directory |
| `/bin/bash` | Default shell |

System users typically have UIDs below 1000 and often have `/usr/sbin/nologin` as their shell — they can't log in interactively.

### Managing users

```bash
# Create a user
sudo useradd -m -s /bin/bash t.charan    # -m creates home dir, -s sets shell

# Set password
sudo passwd t.charan

# Delete a user
sudo userdel -r t.charan                  # -r removes home directory too

# Modify a user
sudo usermod -aG docker t.charan          # add to docker group

# See who you are
whoami

# See your full identity
id
```

The `id` command shows your UID, GID, and all groups you belong to:

```
uid=1000(d.akhilteja) gid=1000(d.akhilteja) groups=1000(d.akhilteja),27(sudo),999(docker)
```

</div>
</details>

---

<details>
<summary><strong>2. Groups — Collective Access</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Giving permissions to individual users doesn't scale. If ten developers need access to the same project directory, you don't want to manage ten separate permission entries. Groups solve this.

A group is a named collection of users. Files can grant permissions to a group, and all members of that group get that access.

### Primary vs supplementary groups

Every user has one **primary group** — usually a group with the same name as the user. When you create files, they're owned by your primary group by default.

Users can also belong to **supplementary groups** — additional groups that grant extra access. A developer might be in `developers`, `docker`, and `sudo` groups simultaneously.

### Where group info lives

Groups are defined in `/etc/group`:

```bash
cat /etc/group
```

```
developers:x:1001:d.akhilteja,t.charan,m.priya
docker:x:999:d.akhilteja,t.charan
sudo:x:27:d.akhilteja
```

Format: `groupname:password:GID:members`

### Managing groups

```bash
# Create a group
sudo groupadd developers

# Add user to group
sudo usermod -aG developers t.charan       # -a = append, -G = supplementary group

# Remove user from group
sudo gpasswd -d t.charan developers

# See your groups
groups

# See another user's groups
groups t.charan

# Delete a group
sudo groupdel developers
```

**Important:** After adding a user to a group, they need to log out and back in for the change to take effect. Or use `newgrp groupname` to activate it in the current session.

### Practical example

ChillSpot Streaming has developers who need access to application files:

```bash
sudo groupadd chillspot-dev
sudo usermod -aG chillspot-dev d.akhilteja
sudo usermod -aG chillspot-dev t.charan
sudo chown -R chillspot:chillspot-dev /srv/chillspot-streaming
sudo chmod -R 775 /srv/chillspot-streaming
```

Now anyone in `chillspot-dev` can read and write to the project directory.

</div>
</details>

---

<details>
<summary><strong>3. How Permissions Work</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every file and directory has three permission sets:

1. **Owner** — what the file's owner can do
2. **Group** — what members of the file's group can do
3. **Others** — what everyone else can do

Each set contains three permissions:

| Permission | On Files | On Directories |
|------------|----------|----------------|
| **r** (read) | View contents | List contents (`ls`) |
| **w** (write) | Modify contents | Create/delete files inside |
| **x** (execute) | Run as program | Enter directory (`cd`) |

### The mental model

Think of a directory as a room. Read permission lets you look through the window and see what's inside. Execute permission lets you walk into the room. Write permission lets you add or remove furniture.

For files: read lets you open the document, write lets you edit it, execute lets you run it as a program.

### The check sequence

When you access a file, Linux checks permissions in order:

1. Are you the owner? → Use owner permissions
2. Are you in the file's group? → Use group permissions
3. Neither? → Use others permissions

It stops at the first match. If you're the owner, only owner permissions matter — group and others are ignored.

### A common confusion

You own a file with permissions `r--------`. Can you write to it? **No.** Being the owner doesn't grant automatic full access — it just means owner permissions apply to you. And owner permissions here are read-only.

But as the owner, you *can* change the permissions. Others cannot.

</div>
</details>

---

<details>
<summary><strong>4. Reading Permission Strings</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The `ls -l` output shows permissions as a 10-character string:

```
-rwxr-xr--
```

Breaking it down:

| Position | Meaning |
|----------|---------|
| 1 | File type (`-` = file, `d` = directory, `l` = link) |
| 2-4 | Owner permissions (rwx) |
| 5-7 | Group permissions (r-x) |
| 8-10 | Others permissions (r--) |

A dash means that permission is not granted.

### Examples decoded

```
-rw-r--r--    # File: owner can read/write, everyone else read-only
drwxr-xr-x    # Directory: owner full access, others can enter and list
-rwx------    # File: owner can do everything, others nothing
-rw-rw----    # File: owner and group can read/write, others nothing
```

### Numeric representation

Permissions also have numeric values:

- r = 4
- w = 2
- x = 1

Add them up for each set:

| Permission | Calculation | Value |
|------------|-------------|-------|
| rwx | 4+2+1 | 7 |
| rw- | 4+2+0 | 6 |
| r-x | 4+0+1 | 5 |
| r-- | 4+0+0 | 4 |
| --- | 0+0+0 | 0 |

So `rwxr-xr--` becomes `754`:
- Owner: rwx = 7
- Group: r-x = 5
- Others: r-- = 4

You'll use these numbers with `chmod`.

### Common permission patterns

| Numeric | Symbolic | Use Case |
|---------|----------|----------|
| 644 | rw-r--r-- | Regular files (configs, documents) |
| 755 | rwxr-xr-x | Executables, directories |
| 600 | rw------- | Private files (SSH keys) |
| 700 | rwx------ | Private directories |
| 775 | rwxrwxr-x | Shared project directories |
| 777 | rwxrwxrwx | **Avoid** — everyone can do everything |

</div>
</details>

---

<details>
<summary><strong>5. Changing Permissions with chmod</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

`chmod` (change mode) modifies permissions. Two syntaxes: numeric and symbolic.

### Numeric mode

Set exact permissions:

```bash
chmod 755 script.sh        # rwxr-xr-x
chmod 644 config.yaml      # rw-r--r--
chmod 600 ~/.ssh/id_rsa    # rw------- (private key must be this)
```

### Symbolic mode

Add, remove, or set permissions relatively:

```bash
chmod +x script.sh         # add execute for everyone
chmod u+x script.sh        # add execute for owner only
chmod g+w file.txt         # add write for group
chmod o-r file.txt         # remove read from others
chmod u=rwx,g=rx,o= file   # set exact permissions
```

Symbolic targets:
- `u` = user (owner)
- `g` = group
- `o` = others
- `a` = all (default if omitted)

Operators:
- `+` = add permission
- `-` = remove permission
- `=` = set exactly

### Recursive changes

Apply to directory and everything inside:

```bash
chmod -R 755 /srv/chillspot-streaming/
```

Be careful with recursive chmod. You often want different permissions for files vs directories.

### Files vs directories pattern

Directories need execute permission to enter. Files usually don't (unless they're scripts). A common pattern:

```bash
# Directories: 755, Files: 644
find /srv/chillspot-streaming -type d -exec chmod 755 {} \;
find /srv/chillspot-streaming -type f -exec chmod 644 {} \;

# Then make scripts executable
chmod +x /srv/chillspot-streaming/start.sh
```

</div>
</details>

---

<details>
<summary><strong>6. Changing Ownership with chown and chgrp</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Permissions define what can be done. Ownership defines who the permissions apply to. Changing ownership requires root (or sudo).

### chown — Change owner

```bash
sudo chown t.charan file.txt                # change owner
sudo chown t.charan:developers file.txt     # change owner and group
sudo chown :developers file.txt             # change group only
```

### Recursive ownership

```bash
sudo chown -R chillspot:chillspot /srv/chillspot-streaming/
```

This is common when deploying applications — the service user needs to own its files.

### chgrp — Change group only

```bash
sudo chgrp developers project/
sudo chgrp -R developers project/           # recursive
```

`chown :group` does the same thing, but `chgrp` is more explicit.

### Practical deployment flow

When setting up ChillSpot Streaming on a new server:

```bash
# Create service user
sudo useradd -r -s /usr/sbin/nologin chillspot    # -r = system user

# Create application directory
sudo mkdir -p /srv/chillspot-streaming

# Set ownership
sudo chown -R chillspot:chillspot /srv/chillspot-streaming

# Set permissions
sudo chmod -R 755 /srv/chillspot-streaming
sudo chmod 600 /srv/chillspot-streaming/config/secrets.yaml
```

The service runs as `chillspot`, owns its files, and sensitive configs are locked down.

</div>
</details>

---

<details>
<summary><strong>7. Special Permissions — setuid, setgid, sticky bit</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Beyond the basic rwx, three special permission bits handle edge cases.

### setuid (Set User ID)

When set on an executable, it runs as the file's owner, not the user running it.

Why this exists: `passwd` needs to modify `/etc/shadow`, which only root can write. But regular users need to change their own passwords. Solution: `passwd` is owned by root with setuid set. When you run it, it executes with root privileges.

```bash
ls -l /usr/bin/passwd
```

```
-rwsr-xr-x 1 root root 68208 Mar 14 2023 /usr/bin/passwd
```

The `s` in the owner's execute position indicates setuid.

### setgid (Set Group ID)

On files: runs with the file's group privileges.

On directories: files created inside inherit the directory's group (not the creator's primary group). This is useful for shared project directories.

```bash
chmod g+s /srv/chillspot-streaming/shared/
```

Now when anyone creates a file in `shared/`, it belongs to the directory's group, keeping permissions consistent.

### Sticky bit

On directories: only the file owner (or root) can delete files inside, even if others have write permission.

Classic example: `/tmp` is world-writable, but you can't delete other users' files.

```bash
ls -ld /tmp
```

```
drwxrwxrwt 15 root root 4096 Mar 15 12:00 /tmp
```

The `t` in the others' execute position indicates the sticky bit.

### Setting special permissions

```bash
chmod u+s file         # setuid
chmod g+s directory    # setgid
chmod +t directory     # sticky bit

# Numeric: prepend a digit
chmod 4755 file        # setuid + rwxr-xr-x
chmod 2755 directory   # setgid + rwxr-xr-x
chmod 1777 directory   # sticky + rwxrwxrwx
```

The fourth digit: 4 = setuid, 2 = setgid, 1 = sticky.

</div>
</details>

---

<details>
<summary><strong>8. Default Permissions and umask</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When you create a file, it doesn't get 777 permissions by default. The `umask` determines what's subtracted from the maximum.

### How umask works

Default maximum permissions:
- Files: 666 (no execute by default — you add it explicitly)
- Directories: 777

The umask is subtracted:

```bash
umask
```

Common output: `0022`

With umask 022:
- Files: 666 - 022 = 644 (rw-r--r--)
- Directories: 777 - 022 = 755 (rwxr-xr-x)

### Setting umask

```bash
umask 027
```

Now:
- Files: 666 - 027 = 640 (rw-r-----)
- Directories: 777 - 027 = 750 (rwxr-x---)

Others get no access.

### Persistent umask

Set in `~/.bashrc` or `~/.profile` for per-user:

```bash
umask 027
```

Set in `/etc/profile` or `/etc/login.defs` for system-wide defaults.

### Practical consideration

For servers handling sensitive data, a restrictive umask like 027 or 077 prevents accidental exposure. New files are private by default — you explicitly open access when needed.

</div>
</details>

---

<details>
<summary><strong>9. Real-World Permission Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Understanding permissions conceptually is one thing. Knowing how to apply them in production is another.

### Web application files

```bash
# Application owned by service user
sudo chown -R www-data:www-data /var/www/app

# Directories navigable, files readable
sudo find /var/www/app -type d -exec chmod 755 {} \;
sudo find /var/www/app -type f -exec chmod 644 {} \;

# Upload directory writable by web server
sudo chmod 775 /var/www/app/uploads
```

### SSH key permissions

SSH is strict about permissions. Wrong permissions = connection refused.

```bash
chmod 700 ~/.ssh                    # directory
chmod 600 ~/.ssh/id_rsa            # private key
chmod 644 ~/.ssh/id_rsa.pub        # public key
chmod 600 ~/.ssh/authorized_keys   # authorized keys
chmod 644 ~/.ssh/known_hosts       # known hosts
```

### Shared project directory

Multiple developers need access:

```bash
sudo groupadd projectteam
sudo usermod -aG projectteam dev1
sudo usermod -aG projectteam dev2

sudo mkdir /srv/project
sudo chown root:projectteam /srv/project
sudo chmod 2775 /srv/project        # setgid so new files inherit group
```

Now any team member can create and edit files, and new files automatically belong to `projectteam`.

### Secrets and credentials

Config files with passwords, API keys, certificates:

```bash
chmod 600 /srv/app/config/secrets.yaml
chmod 600 /etc/ssl/private/server.key
chown root:root /etc/ssl/private/server.key
```

No group access, no others access. Only the owner (usually root or the service user) can read.

### Debugging permission issues

When something fails with "Permission denied":

```bash
# Check who you are
id

# Check file permissions and ownership
ls -la /path/to/file

# Check directory permissions (can you enter?)
ls -la /path/to/

# Check if any parent directory blocks access
namei -l /full/path/to/file
```

`namei` shows permissions along the entire path — useful when access fails due to a restrictive parent directory.

</div>
</details>

---

## 10. Where We Go From Here

You now understand how Linux controls access. Users have identities. Groups collect users. Permissions define what each can do. Special bits handle edge cases. The umask sets defaults.

This security model protects every file in the filesystem you learned to navigate. But files are just static data. The real action happens in **processes** — running programs that read files, use CPU, consume memory, and interact with the system.

File 04 covers **Processes, Jobs & systemd** — how programs run, how to monitor them, how to control them, and how systemd orchestrates everything on modern Linux systems.

Every service you deploy becomes a process. Every container runs processes. Every debugging session involves inspecting processes. Let's understand them.
