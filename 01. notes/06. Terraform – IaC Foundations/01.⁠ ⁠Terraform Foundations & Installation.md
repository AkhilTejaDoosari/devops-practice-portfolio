# **01. Terraform Foundations & Installation** 

The year is 2024. You're managing 50 AWS EC2 instances across three environments — dev, staging, production.
One day your CTO says: *"We need to replicate this entire setup in a new region by Friday."*

You open the AWS console. Click. Click. Click. Security group. Click. Subnet. Click. Instance. Click.
Three hours later, you've created 5 instances... and you still have 45 to go.

Now imagine this instead:
You open a text file. Change one line: `region = "us-west-2"`.
You run one command: `terraform apply`.
Five minutes later, all 50 instances — perfectly configured — are running in the new region.

**That's Terraform.** And that's where your journey starts.

---

## Table of Contents
1. [What Is Terraform & Why It Exists](#what-is-terraform--why-it-exists)
2. [Infrastructure as Code (IaC) Philosophy](#infrastructure-as-code-iac-philosophy)
3. [Understanding Environments](#understanding-environments)
4. [Declarative vs Imperative](#declarative-vs-imperative)
5. [Installation](#installation)
6. [Verify Installation](#verify-installation)

---

<details>
<summary><strong>1. What Is Terraform & Why It Exists</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

That Friday deadline scenario? It's not fictional. It happens all the time.

Your team needs to launch a new app. You open AWS, create a VPC, spin up subnets, add security groups, launch EC2 instances, connect them to RDS, set up Load Balancers — all through the console. It works. But then your manager asks you to replicate the exact setup in another region. Or your teammate needs to recreate the environment for testing. Or you need to tear it all down and rebuild it next month.

Suddenly, clicking becomes painful. You're trying to remember every setting, every configuration, every little detail. One wrong click and your staging environment doesn't match production. Documentation is outdated. Knowledge lives in your head, not in a system.

**Three problems emerge:**

**Problem 1: Knowledge Lives in Someone's Head**
Sarah from DevOps set up the production VPC six months ago. She configured security groups, routing tables, NAT gateways — all through the console. Then Sarah left the company. Now when you need to replicate that setup, you're staring at the AWS console trying to reverse-engineer her decisions. Which CIDR blocks? Which route goes where? Why is this security group attached here?
The infrastructure exists. The knowledge doesn't.

**Problem 2: Changes Are Invisible**
Someone made a change to production last night. Was it intentional? Was it approved? What exactly changed? You check CloudTrail logs... 47 API calls. Good luck figuring out which one matters. There's no pull request. No code review. No "git log" showing what changed and why.
Infrastructure drift happens in silence.

**Problem 3: Scaling Humans Doesn't Scale**
Your startup is growing. You need dev, staging, and production environments. Then you add a second region for DR. Then a third for GDPR compliance. Each environment needs the exact same setup. Now you're asking your team to manually replicate infrastructure across 9 environments. Even if they get it right the first time, they won't get it right the ninth time.
Human consistency breaks at scale.

**That's exactly why Terraform exists.**

Here's the simplest explanation:
**Terraform is a tool that builds infrastructure from code.**

Instead of clicking through cloud provider consoles, you write what you want in a `.tf` file:
```hcl
resource "aws_instance" "web" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

Then run: `terraform apply`

Terraform reads your code, talks to the cloud provider's API, and creates that EC2 instance for you.

**But here's where it gets powerful:**
That same code can create:
- 1 instance or 100 instances
- In one region or ten regions
- In one account or multiple accounts
- Today, or destroyed tomorrow, or recreated next week

All from that same simple text file.

**The shift:**
- Before: Infrastructure exists in the cloud. Documentation exists in your head (maybe).
- After: Infrastructure exists as **code**. Code is **version controlled** (Git). Changes are **reviewable** (pull requests). History is **tracked** (commits). **Anyone** can see what's deployed. **Everyone** can propose changes. **Everything** is reproducible.

Suddenly, managing infrastructure feels like... writing software.
And that's exactly the point.

</div>

</details>

---

<details>
<summary><strong>2. Infrastructure as Code (IaC) Philosophy</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Infrastructure as Code means managing your cloud resources through files instead of manual steps.
You describe what you want, commit it to version control, and let the tool make it happen.

**Why this matters:**
When infrastructure is code, it becomes testable, auditable, and collaborative. You can review it in pull requests. You can roll back mistakes. You can see exactly who changed what and when. If something breaks, you can rebuild it from the same blueprint that worked last time.

**The Benefits:**

**Automation** — No more clicking through wizards. Write once, deploy anywhere.  
**Consistency** — Dev, staging, and production are built from the same code.  
**Version Control** — Every change is tracked in Git with context and history.  
**Collaboration** — Multiple teams can work on infrastructure together.  
**Documentation** — The code IS the documentation. It never goes stale.  
**Disaster Recovery** — Rebuild everything in minutes, not weeks.  

**The IaC Landscape**

| Tool | Approach | Best For |
|------|----------|----------|
| **Terraform** | Declarative, multi-cloud | Cross-cloud infrastructure |
| **CloudFormation** | Declarative, AWS-only | Deep AWS integration |
| **Pulumi** | Declarative, real languages | Developers who prefer Python/TypeScript |
| **Ansible** | Imperative, config management | Server configuration + some infrastructure |

Terraform stands out because it's **cloud-agnostic** (AWS, Azure, GCP, and more), has a massive ecosystem, and focuses purely on infrastructure, not configuration.

**Terraform's Core Philosophy:**

Terraform doesn't care which cloud you use. It provides a consistent workflow:
- Write `.tf` files describing your infrastructure   
- Terraform translates that into API calls   
- Works the same way on AWS, Azure, Google Cloud, Kubernetes, or all of them together   

You learn Terraform once, and you can manage infrastructure anywhere.

</div>

</details>

---

<details>
<summary><strong>3. Understanding Environments</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

You'll hear "dev, staging, production" constantly in DevOps. Before we go further, let's understand what these are and why they exist.

**The Problem: You Can't Experiment on Live Users**

Imagine you're running a banking app. You want to add a new feature — maybe a button that transfers money. You write the code, deploy it directly to the live app, and... it has a bug. Users click the button, money disappears, and your phone starts ringing.

You can't test changes on real users with real data. You need a safe place to experiment.

**The Solution: Multiple Copies of Your Infrastructure**

Instead of one environment, you create several — each serving a different purpose:

**Development (Dev)**
Your playground. Developers test new features here. It breaks constantly, and that's fine. No real users, no real data, no real consequences. When something crashes, you fix it and move on.

**Staging**
A near-perfect copy of production. Before any change goes live, it runs here first. QA teams test it. Performance is validated. If staging works, production will probably work. Think of it as a dress rehearsal.

**Production (Prod)**
The real thing. Real users, real data, real money. Changes here are carefully controlled. A bug in production means angry customers, lost revenue, and 3 AM phone calls.

**Why This Matters for Terraform**

Each environment needs the same infrastructure — same VPCs, same load balancers, same databases. But with different configurations:

| Aspect | Dev | Staging | Production |
|--------|-----|---------|------------|
| **Instance size** | t3.micro (cheap) | t3.small | t3.large (powerful) |
| **Instance count** | 1 | 2 | 10 |
| **Database** | Small, no backups | Medium, daily backups | Large, multi-AZ, hourly backups |
| **Monitoring** | Basic | Standard | Full alerting |
| **Cost** | $50/month | $200/month | $2000/month |

Same architecture, different scale. Same code, different values.

**Without Terraform:**
You manually create each environment. Dev drifts from staging. Staging drifts from production. A feature works in dev but breaks in production because someone forgot to open a port in the security group.

**With Terraform:**
One codebase defines all environments. The same VPC module, the same compute module, the same database module — just different input values. When you fix a bug in the VPC config, all environments get the fix.

**The Goal:**
Your staging environment should be close enough to production that if something works in staging, you're confident it'll work in production. Terraform makes this achievable.

Throughout this series, you'll see "dev, staging, production" referenced often. Now you know why they exist — and later (File 07), you'll learn exactly how to structure Terraform code to manage them.

</div>

</details>

---

<details>
<summary><strong>4. Declarative vs Imperative</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

This is the most important concept to understand about how Terraform works.

**Imperative (Step-by-step instructions):**
```bash
1. Create a VPC with CIDR 10.0.0.0/16
2. Create a subnet inside that VPC with CIDR 10.0.1.0/24
3. Create an internet gateway
4. Attach the internet gateway to the VPC
5. Create a route table
6. Add a route to the route table pointing to the internet gateway
7. Associate the route table with the subnet
```

You're telling the system **how** to do something, step by step. Like giving driving directions: "Turn left, go 2 blocks, turn right."

**Declarative (Describe the end state):**
```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id
  cidr_block = "10.0.1.0/24"
}

resource "aws_internet_gateway" "gw" {
  vpc_id = aws_vpc.main.id
}
```

You're telling the system **what** you want, not how to build it. Like giving a destination: "Get me to 123 Main Street."

**What Terraform Figures Out:**
- What order to create resources (VPC before subnet)
- What dependencies exist (subnet needs VPC ID)
- What to create, update, or delete
- How to handle failures and retries

You describe the **destination**. Terraform figures out the **route**.

**Why This Matters:**

**With imperative code:**
- You run the script once, it creates everything
- You run it again, it tries to create everything again (errors or duplicates)
- You change line 3, you have to manually figure out what to update
- Removing resources means writing new deletion scripts

**With declarative code:**
- You describe what you want
- Terraform compares it to what exists
- Terraform only changes what's different
- Remove a resource from code, Terraform deletes it automatically

**Example in Action:**

Your code says: "I want 3 EC2 instances"
Reality says: "2 instances exist"
Terraform: "I'll create 1 more instance"

You update your code: "I want 2 EC2 instances"
Reality says: "3 instances exist"
Terraform: "I'll delete 1 instance"

You didn't write "create instance" or "delete instance" commands. You just declared the desired state, and Terraform made it happen.

**This is Terraform's superpower.**

</div>

</details>

---

<details>
<summary><strong>5. Installation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Let's get Terraform running on your machine.

**macOS:**
```bash
brew tap hashicorp/tap
brew install hashicorp/tap/terraform
```

**Linux (Ubuntu/Debian):**
```bash
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
```

**Linux (CentOS/RHEL):**
```bash
sudo yum install -y yum-utils
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo
sudo yum -y install terraform
```

**Windows (Chocolatey):**
```powershell
choco install terraform
```

**Windows (Manual):**
1. Download from [terraform.io/downloads](https://www.terraform.io/downloads)
2. Extract the `.zip` file
3. Add the extracted folder to your system PATH
4. Restart your terminal

</div>

</details>

---

<details>
<summary><strong>6. Verify Installation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

After installation, verify Terraform is working:

```bash
terraform version
```

**Expected output:**
```
Terraform v1.9.0
on darwin_amd64
```

You should see:
- Terraform version number (v1.x.x)
- Your operating system and architecture

**If you see an error:**
- Make sure Terraform is in your PATH
- Restart your terminal
- Try running the installation command again

**Check available commands:**
```bash
terraform
```

**Output:**
```
Usage: terraform [global options] <subcommand> [args]

Common commands:
    init          Prepare your working directory
    validate      Check configuration syntax
    plan          Show changes required by current config
    apply         Create or update infrastructure
    destroy       Destroy previously-created infrastructure
```

If you see this list, you're ready to start building infrastructure as code.

---

**What You've Accomplished:**

✅ You understand why Terraform exists (manual infrastructure doesn't scale). 
✅ You understand the IaC philosophy (code over clicking). 
✅ You understand declarative vs imperative (describe what, not how)  
✅ You have Terraform installed and verified  
✅ You're ready to start writing Terraform code  

---

**You're ready.** The foundation is set.

Terraform is installed. You understand why it exists and how it thinks differently from traditional scripting.
But Terraform doesn't work alone — it needs something to remember what it created, track changes, and calculate differences.

That memory system is called **state**, and understanding it unlocks everything else.
Next, we'll see how Terraform's core engine works under the hood.
</div>

</details>

---