# **05. Loops & Conditionals — Creating Multiple Resources Dynamically**

You've learned how to create single resources. But what if you need to create 10 EC2 instances? Or 3 subnets across different availability zones? Or apply the same configuration to a list of environments?

Copying and pasting resource blocks doesn't scale. It's error-prone, hard to maintain, and violates the DRY principle (Don't Repeat Yourself).

**Terraform gives you loops and conditionals to create infrastructure dynamically.**

You can generate multiple resources from a list, create resources conditionally based on variables, build nested configuration blocks dynamically, and transform data with expressions.

This file covers **all** the loop and conditional syntax in Terraform. Master these patterns, and you'll build scalable, maintainable infrastructure.

---

## Table of Contents
1. [The Need for Repetition](#1-the-need-for-repetition)
2. [count — Basic Loops](#2-count--basic-loops)
3. [for_each — Advanced Loops](#3-for_each--advanced-loops)
4. [Conditional Resources](#4-conditional-resources)
5. [Dynamic Blocks](#5-dynamic-blocks)
6. [for Expressions](#6-for-expressions)
7. [Ternary Operators](#7-ternary-operators)
8. [Real-World Patterns](#8-real-world-patterns)

---

<details>
<summary><strong>1. The Need for Repetition</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Let's say you need to create 3 subnets across 3 availability zones.

**Without loops (repetitive):**
```hcl
resource "aws_subnet" "subnet_1" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.1.0/24"
  availability_zone = "us-east-1a"
}

resource "aws_subnet" "subnet_2" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.2.0/24"
  availability_zone = "us-east-1b"
}

resource "aws_subnet" "subnet_3" {
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.3.0/24"
  availability_zone = "us-east-1c"
}
```

**Problems:**
- 30 lines for 3 subnets
- Need to update all 3 if VPC changes
- Want 5 subnets? Copy-paste 2 more blocks
- Hard to maintain

**With loops (clean):**
```hcl
resource "aws_subnet" "public" {
  count             = 3
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]
}
```

**Benefits:**
- 6 lines for 3 subnets
- One place to change VPC
- Want 5 subnets? Change `count = 5`
- Easy to maintain

**When You Need Loops:**
- Creating multiple similar resources (instances, subnets, security groups)
- Deploying across multiple availability zones or regions
- Applying the same configuration to different environments
- Building resources from a list of values

**When You Need Conditionals:**
- Creating resources only in certain environments
- Enabling features based on variables
- Different configurations for different scenarios

Terraform provides several mechanisms for repetition and logic. Let's explore each one.

</div>

</details>

---

<details>
<summary><strong>2. count — Basic Loops</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

`count` is the simplest way to create multiple instances of a resource.

**Basic Syntax:**

```hcl
resource "TYPE" "NAME" {
  count = NUMBER
  
  # Use count.index to differentiate instances
}
```

**Example 1: Create 3 EC2 Instances**

```hcl
resource "aws_instance" "web" {
  count         = 3
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  
  tags = {
    Name = "WebServer-${count.index}"
  }
}
```

Creates:
- `aws_instance.web[0]` → "WebServer-0"
- `aws_instance.web[1]` → "WebServer-1"
- `aws_instance.web[2]` → "WebServer-2"

**The count Object:**

| Expression | Value | Description |
|------------|-------|-------------|
| `count.index` | 0, 1, 2... | Current iteration index (0-based) |

**Example 2: Create Subnets Across AZs**

```hcl
data "aws_availability_zones" "available" {
  state = "available"
}

resource "aws_subnet" "public" {
  count             = 3
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index + 1}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]
  
  tags = {
    Name = "public-subnet-${count.index + 1}"
  }
}
```

Creates:
- Subnet 1: `10.0.1.0/24` in `us-east-1a`
- Subnet 2: `10.0.2.0/24` in `us-east-1b`
- Subnet 3: `10.0.3.0/24` in `us-east-1c`

**Example 3: Variable-Based Count**

```hcl
variable "instance_count" {
  type    = number
  default = 3
}

resource "aws_instance" "app" {
  count         = var.instance_count
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
}
```

Change the variable, change the count.

**Referencing count Resources:**

**Single instance:**
```hcl
# Reference specific instance
output "first_instance_id" {
  value = aws_instance.web[0].id
}
```

**All instances (splat):**
```hcl
# Get all instance IDs
output "all_instance_ids" {
  value = aws_instance.web[*].id
}
```

Returns: `["i-abc123", "i-def456", "i-ghi789"]`

**Example 4: Conditional Creation with count**

```hcl
variable "create_monitoring" {
  type    = bool
  default = false
}

resource "aws_cloudwatch_alarm" "cpu" {
  count = var.create_monitoring ? 1 : 0
  
  alarm_name          = "high-cpu"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "CPUUtilization"
  threshold           = 80
}
```

If `create_monitoring = true` → creates 1 alarm
If `create_monitoring = false` → creates 0 alarms (resource doesn't exist)

**Limitations of count:**

❌ **Can't use maps directly** — count works with numbers, not keys
❌ **Order matters** — Removing item from middle shifts indices
❌ **Limited metadata** — Only have index, not original value

**Example of the ordering problem:**

```hcl
resource "aws_instance" "web" {
  count = 3
  ami   = "ami-abc123"
  
  tags = {
    Name = "server-${count.index}"
  }
}
```

Creates: `server-0`, `server-1`, `server-2`

**Now remove count = 2 (make it 2):**
```
Terraform will DESTROY server-2
```

But if `server-1` was removed from your list, Terraform doesn't know that.
It just sees "count decreased" and removes the last one.

**For complex scenarios, use for_each instead.**

</div>

</details>

---

<details>
<summary><strong>3. for_each — Advanced Loops</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

`for_each` creates resource instances based on a **map** or **set**, using unique keys instead of indices.

**Why for_each is Better:**
- Resources identified by key, not index
- Removing an item doesn't affect others
- Can use maps with metadata
- More maintainable for complex scenarios

**Basic Syntax:**

```hcl
resource "TYPE" "NAME" {
  for_each = MAP_OR_SET
  
  # Use each.key and each.value
}
```

**The each Object:**

| Expression | Description | Example |
|------------|-------------|---------|
| `each.key` | Current key | "web", "db", "cache" |
| `each.value` | Current value | "t3.micro", "t3.large" |

**Example 1: Create Buckets from a Set**

```hcl
resource "aws_s3_bucket" "apps" {
  for_each = toset(["app1", "app2", "app3"])
  
  bucket = "${each.key}-bucket"
  
  tags = {
    Name = each.key
  }
}
```

Creates:
- `aws_s3_bucket.apps["app1"]` → "app1-bucket"
- `aws_s3_bucket.apps["app2"]` → "app2-bucket"
- `aws_s3_bucket.apps["app3"]` → "app3-bucket"

**Example 2: Create Instances from a Map**

```hcl
variable "instances" {
  type = map(string)
  default = {
    web   = "t3.micro"
    api   = "t3.small"
    cache = "t3.medium"
  }
}

resource "aws_instance" "servers" {
  for_each = var.instances
  
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = each.value
  
  tags = {
    Name = each.key
    Type = each.value
  }
}
```

Creates:
- `aws_instance.servers["web"]` → t3.micro
- `aws_instance.servers["api"]` → t3.small
- `aws_instance.servers["cache"]` → t3.medium

**Remove "api" from the map:**
Only `aws_instance.servers["api"]` is destroyed.
Web and cache instances are untouched.

**Example 3: Complex Map with Objects**

```hcl
variable "users" {
  type = map(object({
    role  = string
    email = string
  }))
  
  default = {
    alice = {
      role  = "admin"
      email = "alice@example.com"
    }
    bob = {
      role  = "developer"
      email = "bob@example.com"
    }
  }
}

resource "aws_iam_user" "users" {
  for_each = var.users
  
  name = each.key
  
  tags = {
    Role  = each.value.role
    Email = each.value.email
  }
}
```

**Referencing for_each Resources:**

**Single resource:**
```hcl
output "web_instance_id" {
  value = aws_instance.servers["web"].id
}
```

**All resources:**
```hcl
output "all_instance_ids" {
  value = {
    for k, v in aws_instance.servers : k => v.id
  }
}
```

Returns: `{ web = "i-abc", api = "i-def", cache = "i-ghi" }`

**Example 4: Create IAM Users with Policies**

```hcl
variable "users" {
  type = map(object({
    path   = string
    policy = string
  }))
  
  default = {
    developer1 = {
      path   = "/developers/"
      policy = "arn:aws:iam::aws:policy/ReadOnlyAccess"
    }
    admin1 = {
      path   = "/admins/"
      policy = "arn:aws:iam::aws:policy/AdministratorAccess"
    }
  }
}

resource "aws_iam_user" "users" {
  for_each = var.users
  
  name = each.key
  path = each.value.path
}

resource "aws_iam_user_policy_attachment" "users" {
  for_each = var.users
  
  user       = aws_iam_user.users[each.key].name
  policy_arn = each.value.policy
}
```

**Converting Lists to Sets:**

`for_each` requires a map or set, not a list.

```hcl
variable "subnet_ids" {
  type    = list(string)
  default = ["subnet-abc", "subnet-def", "subnet-ghi"]
}

resource "aws_route_table_association" "public" {
  for_each = toset(var.subnet_ids)
  
  subnet_id      = each.key
  route_table_id = aws_route_table.public.id
}
```

**count vs for_each Decision:**

| Use count when | Use for_each when |
|----------------|-------------------|
| Creating N identical resources | Each resource has unique metadata |
| Index-based logic | Key-based identification |
| Simple repetition | Items might be added/removed |
| Order doesn't matter | Stability matters |

**Rule of thumb:** If you're using a list of strings/objects with meaningful identifiers, use `for_each`.

</div>

</details>

---

<details>
<summary><strong>4. Conditional Resources</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Sometimes you want to create a resource only under certain conditions.

**Pattern: count = condition ? 1 : 0**

If condition is true → count = 1 → resource created
If condition is false → count = 0 → resource not created

**Example 1: Create Resource Based on Environment**

```hcl
variable "environment" {
  type = string
}

resource "aws_instance" "bastion" {
  count = var.environment == "prod" ? 1 : 0
  
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  
  tags = {
    Name = "Bastion"
  }
}
```

Production → bastion created
Dev/Staging → no bastion

**Example 2: Create Resource Based on Boolean**

```hcl
variable "enable_monitoring" {
  type    = bool
  default = false
}

resource "aws_cloudwatch_dashboard" "main" {
  count = var.enable_monitoring ? 1 : 0
  
  dashboard_name = "monitoring-dashboard"
  dashboard_body = jsonencode({
    widgets = []
  })
}
```

**Example 3: Multiple Conditions**

```hcl
variable "environment" {
  type = string
}

variable "enable_backups" {
  type = bool
}

locals {
  should_create_backups = (
    var.environment == "prod" && 
    var.enable_backups
  )
}

resource "aws_backup_plan" "main" {
  count = local.should_create_backups ? 1 : 0
  
  name = "production-backup-plan"
  
  rule {
    rule_name         = "daily_backup"
    target_vault_name = "production-vault"
    schedule          = "cron(0 2 * * ? *)"
  }
}
```

Only creates backup plan if both conditions are true.

**Example 4: Conditional Configuration**

```hcl
variable "environment" {
  type = string
}

resource "aws_db_instance" "main" {
  allocated_storage = 20
  engine            = "postgres"
  instance_class    = "db.t3.micro"
  
  # Enable backups only in prod
  backup_retention_period = var.environment == "prod" ? 7 : 0
  
  # Enable Multi-AZ only in prod
  multi_az = var.environment == "prod"
  
  # More storage in prod
  allocated_storage = var.environment == "prod" ? 100 : 20
}
```

**Pattern: Conditional for_each**

```hcl
variable "enable_alarms" {
  type = bool
}

variable "alarm_configs" {
  type = map(object({
    metric    = string
    threshold = number
  }))
}

resource "aws_cloudwatch_alarm" "alarms" {
  for_each = var.enable_alarms ? var.alarm_configs : {}
  
  alarm_name          = each.key
  comparison_operator = "GreaterThanThreshold"
  metric_name         = each.value.metric
  threshold           = each.value.threshold
}
```

If `enable_alarms = false` → `for_each = {}` → no alarms created

**Referencing Conditional Resources:**

```hcl
resource "aws_instance" "bastion" {
  count = var.create_bastion ? 1 : 0
  
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}

output "bastion_ip" {
  value = var.create_bastion ? aws_instance.bastion[0].public_ip : null
}
```

Check condition before accessing to avoid errors.

</div>

</details>

---

<details>
<summary><strong>5. Dynamic Blocks</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Dynamic blocks generate nested configuration blocks based on collections.

**Use case:** Security group rules, route table routes, IAM policy statements — anything that can repeat inside a resource.

**Without dynamic blocks (repetitive):**

```hcl
resource "aws_security_group" "web" {
  name = "web-sg"
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"]
  }
}
```

**With dynamic blocks (clean):**

```hcl
variable "ingress_rules" {
  type = list(object({
    port        = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  
  default = [
    { port = 80,  protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] },
    { port = 443, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] },
    { port = 22,  protocol = "tcp", cidr_blocks = ["10.0.0.0/8"] }
  ]
}

resource "aws_security_group" "web" {
  name = "web-sg"
  
  dynamic "ingress" {
    for_each = var.ingress_rules
    
    content {
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
}
```

**Dynamic Block Syntax:**

```hcl
dynamic "BLOCK_NAME" {
  for_each = COLLECTION
  
  content {
    # Use BLOCK_NAME.value or BLOCK_NAME.key
  }
}
```

**The iterator Object:**

| Expression | Description |
|------------|-------------|
| `BLOCK_NAME.key` | Current key (if using map) |
| `BLOCK_NAME.value` | Current value |

**Example 1: Dynamic Egress Rules**

```hcl
variable "egress_rules" {
  type = list(object({
    port     = number
    protocol = string
    cidr     = string
  }))
  
  default = [
    { port = 443, protocol = "tcp", cidr = "0.0.0.0/0" },
    { port = 80,  protocol = "tcp", cidr = "0.0.0.0/0" }
  ]
}

resource "aws_security_group" "app" {
  name = "app-sg"
  
  dynamic "egress" {
    for_each = var.egress_rules
    
    content {
      from_port   = egress.value.port
      to_port     = egress.value.port
      protocol    = egress.value.protocol
      cidr_blocks = [egress.value.cidr]
    }
  }
}
```

**Example 2: Custom Iterator Name**

```hcl
resource "aws_security_group" "web" {
  name = "web-sg"
  
  dynamic "ingress" {
    for_each = var.ingress_rules
    iterator = rule
    
    content {
      from_port   = rule.value.port
      to_port     = rule.value.port
      protocol    = rule.value.protocol
      cidr_blocks = rule.value.cidr_blocks
    }
  }
}
```

Use `iterator` when the block name is confusing or used elsewhere.

**Example 3: Nested Dynamic Blocks**

```hcl
variable "route_tables" {
  type = map(object({
    routes = list(object({
      cidr_block = string
      gateway_id = string
    }))
  }))
  
  default = {
    public = {
      routes = [
        { cidr_block = "0.0.0.0/0", gateway_id = "igw-abc123" }
      ]
    }
    private = {
      routes = [
        { cidr_block = "0.0.0.0/0", gateway_id = "nat-def456" }
      ]
    }
  }
}

resource "aws_route_table" "tables" {
  for_each = var.route_tables
  
  vpc_id = aws_vpc.main.id
  
  dynamic "route" {
    for_each = each.value.routes
    
    content {
      cidr_block = route.value.cidr_block
      gateway_id = route.value.gateway_id
    }
  }
  
  tags = {
    Name = each.key
  }
}
```

**Example 4: Conditional Dynamic Blocks**

```hcl
variable "enable_ssh" {
  type = bool
}

variable "ssh_cidrs" {
  type    = list(string)
  default = ["10.0.0.0/8"]
}

resource "aws_security_group" "web" {
  name = "web-sg"
  
  # Only create SSH rule if enabled
  dynamic "ingress" {
    for_each = var.enable_ssh ? [1] : []
    
    content {
      from_port   = 22
      to_port     = 22
      protocol    = "tcp"
      cidr_blocks = var.ssh_cidrs
    }
  }
}
```

If `enable_ssh = false` → `for_each = []` → no ingress block created

**When to Use Dynamic Blocks:**

✅ **Use when:**
- You have varying numbers of nested blocks
- Configuration comes from variables
- Rules/routes/blocks are data-driven

❌ **Don't use when:**
- You have 1-2 static blocks (just write them out)
- It makes code harder to read
- The configuration is simple and fixed

**Dynamic blocks add complexity. Use them when the flexibility is worth it.**

</div>

</details>

---

<details>
<summary><strong>6. for Expressions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

`for` expressions transform and filter collections — like `map()` and `filter()` in programming languages.

**Syntax:**

```hcl
# Transform a list
[for ITEM in LIST : EXPRESSION]

# Transform a map (to list)
[for KEY, VALUE in MAP : EXPRESSION]

# Transform a map (to map)
{for KEY, VALUE in MAP : NEW_KEY => NEW_VALUE}
```

**Example 1: Transform List**

```hcl
variable "instance_names" {
  default = ["web", "api", "cache"]
}

locals {
  instance_tags = [
    for name in var.instance_names : {
      Name        = name
      Environment = "prod"
    }
  ]
}
```

Result:
```
[
  { Name = "web",   Environment = "prod" },
  { Name = "api",   Environment = "prod" },
  { Name = "cache", Environment = "prod" }
]
```

**Example 2: Extract Values**

```hcl
resource "aws_instance" "web" {
  count = 3
  ami   = "ami-abc123"
  # ... other config
}

output "instance_ips" {
  value = [for instance in aws_instance.web : instance.public_ip]
}
```

Result: `["54.1.2.3", "54.4.5.6", "54.7.8.9"]`

**Example 3: Transform Map**

```hcl
variable "users" {
  default = {
    alice = "admin"
    bob   = "developer"
    carol = "viewer"
  }
}

locals {
  user_emails = {
    for name, role in var.users : name => "${name}@example.com"
  }
}
```

Result:
```
{
  alice = "alice@example.com"
  bob   = "bob@example.com"
  carol = "carol@example.com"
}
```

**Example 4: Filtering with if**

```hcl
variable "users" {
  default = {
    alice = "admin"
    bob   = "developer"
    carol = "viewer"
  }
}

locals {
  admin_users = {
    for name, role in var.users : name => role
    if role == "admin"
  }
}
```

Result: `{ alice = "admin" }`

**Example 5: Create CIDR Blocks**

```hcl
locals {
  subnet_cidrs = [
    for i in range(3) : cidrsubnet("10.0.0.0/16", 8, i)
  ]
}
```

Result: `["10.0.0.0/24", "10.0.1.0/24", "10.0.2.0/24"]`

**Example 6: Complex Transformation**

```hcl
variable "instances" {
  type = map(object({
    type = string
    zone = string
  }))
  
  default = {
    web   = { type = "t3.micro",  zone = "us-east-1a" }
    api   = { type = "t3.small",  zone = "us-east-1b" }
    cache = { type = "t3.medium", zone = "us-east-1a" }
  }
}

locals {
  # Group instances by zone
  instances_by_zone = {
    for zone in distinct([for k, v in var.instances : v.zone]) : zone => {
      for name, config in var.instances : name => config
      if config.zone == zone
    }
  }
}
```

Result:
```
{
  "us-east-1a" = {
    web   = { type = "t3.micro",  zone = "us-east-1a" }
    cache = { type = "t3.medium", zone = "us-east-1a" }
  }
  "us-east-1b" = {
    api = { type = "t3.small", zone = "us-east-1b" }
  }
}
```

**Example 7: Flatten Nested Lists**

```hcl
variable "subnets" {
  default = [
    ["10.0.1.0/24", "10.0.2.0/24"],
    ["10.0.3.0/24", "10.0.4.0/24"]
  ]
}

locals {
  all_cidrs = flatten([
    for subnet_group in var.subnets : [
      for cidr in subnet_group : cidr
    ]
  ])
}
```

Result: `["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24", "10.0.4.0/24"]`

**for Expression Cheat Sheet:**

| Pattern | Syntax | Result |
|---------|--------|--------|
| Transform list | `[for x in list : f(x)]` | New list |
| Filter list | `[for x in list : x if condition]` | Filtered list |
| Transform map to list | `[for k, v in map : v]` | List of values |
| Transform map to map | `{for k, v in map : k => f(v)}` | New map |
| Extract attribute | `[for x in list : x.attr]` | List of attributes |
| Range | `[for i in range(5) : i]` | [0, 1, 2, 3, 4] |

</div>

</details>

---

<details>
<summary><strong>7. Ternary Operators</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Ternary operators provide inline conditional logic.

**Syntax:**

```hcl
condition ? true_value : false_value
```

**Example 1: Conditional Instance Type**

```hcl
variable "environment" {
  type = string
}

resource "aws_instance" "app" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = var.environment == "prod" ? "t3.large" : "t3.micro"
}
```

Production → t3.large
Dev/Staging → t3.micro

**Example 2: Conditional Tag**

```hcl
resource "aws_instance" "web" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name        = "WebServer"
    Environment = var.environment
    Backup      = var.environment == "prod" ? "enabled" : "disabled"
  }
}
```

**Example 3: Nested Ternary**

```hcl
variable "environment" {
  type = string
}

locals {
  instance_type = (
    var.environment == "prod" ? "t3.large" :
    var.environment == "staging" ? "t3.medium" :
    "t3.micro"
  )
}
```

**Example 4: Conditional CIDR**

```hcl
variable "use_large_network" {
  type = bool
}

resource "aws_vpc" "main" {
  cidr_block = var.use_large_network ? "10.0.0.0/8" : "10.0.0.0/16"
}
```

**Example 5: Null Handling**

```hcl
variable "custom_ami" {
  type    = string
  default = null
}

resource "aws_instance" "app" {
  ami           = var.custom_ami != null ? var.custom_ami : "ami-default123"
  instance_type = "t3.micro"
}
```

**Example 6: Complex Condition**

```hcl
variable "environment" {
  type = string
}

variable "enable_backups" {
  type = bool
}

resource "aws_db_instance" "main" {
  allocated_storage = 20
  engine            = "postgres"
  
  backup_retention_period = (
    var.environment == "prod" && var.enable_backups ? 7 : 0
  )
}
```

**Combining with Locals:**

```hcl
variable "environment" {
  type = string
}

locals {
  is_production = var.environment == "prod"
  is_staging    = var.environment == "staging"
  
  instance_count = local.is_production ? 5 : local.is_staging ? 2 : 1
  enable_monitoring = local.is_production || local.is_staging
}

resource "aws_instance" "app" {
  count         = local.instance_count
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  monitoring    = local.enable_monitoring
}
```

**Common Patterns:**

**Default value:**
```hcl
value = var.custom_value != null ? var.custom_value : "default"
```

**Boolean to string:**
```hcl
status = var.enabled ? "enabled" : "disabled"
```

**Environment-based:**
```hcl
size = var.env == "prod" ? "large" : "small"
```

**Multiple conditions:**
```hcl
tier = var.env == "prod" ? "premium" : var.env == "staging" ? "standard" : "basic"
```

</div>

</details>

---

<details>
<summary><strong>8. Real-World Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Let's combine everything into practical patterns you'll use in real projects.

**Pattern 1: Multi-AZ Subnets**

```hcl
variable "vpc_cidr" {
  default = "10.0.0.0/16"
}

variable "az_count" {
  default = 3
}

data "aws_availability_zones" "available" {
  state = "available"
}

locals {
  # Create subnet CIDRs dynamically
  public_subnet_cidrs = [
    for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i)
  ]
  
  private_subnet_cidrs = [
    for i in range(var.az_count) : cidrsubnet(var.vpc_cidr, 8, i + 10)
  ]
}

resource "aws_vpc" "main" {
  cidr_block = var.vpc_cidr
}

resource "aws_subnet" "public" {
  count             = var.az_count
  vpc_id            = aws_vpc.main.id
  cidr_block        = local.public_subnet_cidrs[count.index]
  availability_zone = data.aws_availability_zones.available.names[count.index]
  
  tags = {
    Name = "public-${count.index + 1}"
    Type = "public"
  }
}

resource "aws_subnet" "private" {
  count             = var.az_count
  vpc_id            = aws_vpc.main.id
  cidr_block        = local.private_subnet_cidrs[count.index]
  availability_zone = data.aws_availability_zones.available.names[count.index]
  
  tags = {
    Name = "private-${count.index + 1}"
    Type = "private"
  }
}
```

**Pattern 2: Environment-Based Configuration**

```hcl
variable "environment" {
  type = string
}

locals {
  env_config = {
    dev = {
      instance_type  = "t3.micro"
      instance_count = 1
      enable_backups = false
      storage_gb     = 20
    }
    staging = {
      instance_type  = "t3.small"
      instance_count = 2
      enable_backups = true
      storage_gb     = 50
    }
    prod = {
      instance_type  = "t3.large"
      instance_count = 5
      enable_backups = true
      storage_gb     = 100
    }
  }
  
  config = local.env_config[var.environment]
}

resource "aws_instance" "app" {
  count         = local.config.instance_count
  ami           = "ami-abc123"
  instance_type = local.config.instance_type
  
  tags = {
    Name        = "app-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_db_instance" "main" {
  allocated_storage       = local.config.storage_gb
  engine                  = "postgres"
  instance_class          = "db.t3.micro"
  backup_retention_period = local.config.enable_backups ? 7 : 0
}
```

**Pattern 3: Dynamic Security Group Rules**

```hcl
variable "allowed_ports" {
  type = map(object({
    port        = number
    protocol    = string
    description = string
    cidrs       = list(string)
  }))
  
  default = {
    http = {
      port        = 80
      protocol    = "tcp"
      description = "HTTP access"
      cidrs       = ["0.0.0.0/0"]
    }
    https = {
      port        = 443
      protocol    = "tcp"
      description = "HTTPS access"
      cidrs       = ["0.0.0.0/0"]
    }
    ssh = {
      port        = 22
      protocol    = "tcp"
      description = "SSH access"
      cidrs       = ["10.0.0.0/8"]
    }
  }
}

resource "aws_security_group" "web" {
  name        = "web-sg"
  description = "Web server security group"
  
  dynamic "ingress" {
    for_each = var.allowed_ports
    
    content {
      description = ingress.value.description
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidrs
    }
  }
}
```

**Pattern 4: Conditional Resources with for_each**

```hcl
variable "environment" {
  type = string
}

variable "monitoring_configs" {
  type = map(object({
    metric    = string
    threshold = number
  }))
  
  default = {
    cpu = {
      metric    = "CPUUtilization"
      threshold = 80
    }
    memory = {
      metric    = "MemoryUtilization"
      threshold = 85
    }
  }
}

locals {
  # Only create alarms in prod and staging
  should_create_alarms = contains(["prod", "staging"], var.environment)
}

resource "aws_cloudwatch_alarm" "alarms" {
  for_each = local.should_create_alarms ? var.monitoring_configs : {}
  
  alarm_name          = "${var.environment}-${each.key}"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = each.value.metric
  threshold           = each.value.threshold
  
  dimensions = {
    Environment = var.environment
  }
}
```

**Pattern 5: Creating Resources from Complex Data**

```hcl
variable "applications" {
  type = map(object({
    instance_type = string
    instance_count = number
    subnets       = list(string)
    ports         = list(number)
  }))
  
  default = {
    web = {
      instance_type  = "t3.micro"
      instance_count = 2
      subnets        = ["subnet-abc", "subnet-def"]
      ports          = [80, 443]
    }
    api = {
      instance_type  = "t3.small"
      instance_count = 3
      subnets        = ["subnet-ghi", "subnet-jkl"]
      ports          = [8080, 8443]
    }
  }
}

resource "aws_instance" "apps" {
  for_each = {
    for app_key, app_config in var.applications :
    app_key => app_config
  }
  
  count         = each.value.instance_count
  ami           = "ami-abc123"
  instance_type = each.value.instance_type
  subnet_id     = each.value.subnets[count.index % length(each.value.subnets)]
  
  tags = {
    Name        = "${each.key}-${count.index + 1}"
    Application = each.key
  }
}

resource "aws_security_group" "apps" {
  for_each = var.applications
  
  name = "${each.key}-sg"
  
  dynamic "ingress" {
    for_each = each.value.ports
    
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
}
```

**Pattern 6: Filtering and Transforming**

```hcl
variable "instances" {
  type = map(object({
    type        = string
    environment = string
    backup      = bool
  }))
}

locals {
  # Get only production instances
  prod_instances = {
    for k, v in var.instances : k => v
    if v.environment == "prod"
  }
  
  # Get instances that need backups
  backup_instances = {
    for k, v in var.instances : k => v
    if v.backup == true
  }
  
  # Extract instance types
  instance_types = distinct([
    for k, v in var.instances : v.type
  ])
}

resource "aws_backup_selection" "backups" {
  count = length(local.backup_instances) > 0 ? 1 : 0
  
  name         = "backup-selection"
  plan_id      = aws_backup_plan.main.id
  iam_role_arn = aws_iam_role.backup.arn
  
  resources = [
    for k, v in local.backup_instances : aws_instance.apps[k].arn
  ]
}
```

</div>

</details>

---

**You now control the flow of your infrastructure.**

With count, you create multiple similar resources. With for_each, you build resources from maps with stability. Dynamic blocks generate nested configuration. for expressions transform data. Ternary operators add inline logic.

These are the building blocks of scalable Terraform code. Master them, and you'll write infrastructure that adapts to any scenario.

Next, we'll organize and reuse this code through **modules** — the key to building maintainable, shareable infrastructure configurations.