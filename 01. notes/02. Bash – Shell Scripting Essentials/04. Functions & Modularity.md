# **04. Functions & Modularity — Building Reusable Code Blocks**
> How to organize scripts into maintainable, reusable functions.

---

## Table of Contents
- [1. Why Functions Matter](#1-why-functions-matter)
- [2. Defining Functions](#2-defining-functions)
- [3. Function Parameters](#3-function-parameters)
- [4. Return Values](#4-return-values)
- [5. Variable Scope](#5-variable-scope)
- [6. Function Libraries](#6-function-libraries)
- [7. Error Handling in Functions](#7-error-handling-in-functions)
- [8. Best Practices](#8-best-practices)
- [9. Testing Functions](#9-testing-functions)
- [10. Advanced Function Techniques](#10-advanced-function-techniques)
- [11. Common Function Patterns](#11-common-function-patterns)
- [12. Real-World Scenarios](#12-real-world-scenarios)
- [13. Commands Reference](#13-commands-reference)
- [14. Quick Reference](#14-quick-reference)

---

<details>
<summary><strong>1. Why Functions Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Good code is organized code.

Without functions, scripts become:
- difficult to read
- hard to maintain
- impossible to test
- full of repetition

With functions, scripts become:
- modular and testable
- easy to understand
- simple to maintain
- reusable across projects

Understanding functions means:
- you can write cleaner scripts
- you can build reusable libraries
- you can test components individually
- you can collaborate effectively

This isn't about memorizing syntax.
It's about organizing code so it makes sense — to you, to your team, and to future maintainers.

</div>

</details>

---

<details>
<summary><strong>2. Defining Functions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-153 — Function Syntax

```bash copy
# Method 1: function keyword
function greet() {
    echo "Hello, World!"
}

# Method 2: without function keyword (POSIX)
greet() {
    echo "Hello, World!"
}

# Call the function
greet
```

**Both work identically.**
Most scripts use Method 2 for POSIX compatibility.

---

### BASH-154 — Basic Function Example

```bash copy
#!/bin/bash

check_service() {
    local service=$1
    
    if systemctl is-active "$service" &>/dev/null; then
        echo "✓ $service is running"
        return 0
    else
        echo "✗ $service is not running"
        return 1
    fi
}

# Use the function
check_service nginx
check_service postgresql
```

---

### BASH-155 — Function Naming Conventions

```bash copy
# Good names (descriptive, lowercase, underscores)
check_disk_space() { :; }
deploy_application() { :; }
send_notification() { :; }
validate_config() { :; }

# Avoid (unclear, abbreviated)
chkdsk() { :; }
dply() { :; }
snd() { :; }
val() { :; }
```

**Convention:**
- Use lowercase with underscores
- Start with verb (check, deploy, validate, send)
- Be descriptive but concise

---

### BASH-156 — Functions Must Be Defined Before Use

```bash copy
#!/bin/bash

# WRONG - function called before definition
greet
function greet() {
    echo "Hello"
}

# RIGHT - function defined before use
function greet() {
    echo "Hello"
}
greet
```

**Best Practice:**
Define all functions at the top of the script, then call them in the main logic at the bottom.

</div>

</details>

---

<details>
<summary><strong>3. Function Parameters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-157 — Accessing Parameters

```bash copy
greet() {
    local name=$1
    echo "Hello, $name!"
}

greet "Alice"  # Hello, Alice!
```

**Inside functions:**
- `$1`, `$2`, etc. → function parameters (not script parameters)
- `$@` → all function parameters
- `$#` → number of function parameters

---

### BASH-158 — Multiple Parameters

```bash copy
deploy() {
    local environment=$1
    local version=$2
    local replicas=$3
    
    echo "Deploying $version to $environment with $replicas replicas"
}

deploy staging v1.2.3 3
```

---

### BASH-159 — Parameter Validation

```bash copy
deploy() {
    # Check parameter count
    if [ $# -lt 2 ]; then
        echo "Usage: deploy <environment> <version> [replicas]" >&2
        return 1
    fi
    
    local environment=$1
    local version=$2
    local replicas=${3:-3}  # Default to 3 if not provided
    
    # Validate environment
    case $environment in
        dev|staging|production)
            ;;
        *)
            echo "Invalid environment: $environment" >&2
            return 1
            ;;
    esac
    
    echo "Deploying $version to $environment..."
}
```

---

### BASH-160 — Using $@ for All Parameters

```bash copy
log_message() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $@"
}

log_message "Server" "started" "successfully"
# [2024-11-19 10:30:45] Server started successfully
```

---

### BASH-161 — Named Parameters Pattern

```bash copy
# Using associative array for named parameters
configure_app() {
    local -A config
    
    # Parse named parameters
    while [ $# -gt 0 ]; do
        case $1 in
            --host)
                config[host]=$2
                shift 2
                ;;
            --port)
                config[port]=$2
                shift 2
                ;;
            --database)
                config[database]=$2
                shift 2
                ;;
            *)
                echo "Unknown parameter: $1" >&2
                return 1
                ;;
        esac
    done
    
    # Use configuration
    echo "Host: ${config[host]}"
    echo "Port: ${config[port]}"
    echo "Database: ${config[database]}"
}

# Usage
configure_app --host localhost --port 5432 --database myapp
```

</div>

</details>

---

<details>
<summary><strong>4. Return Values</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-162 — Return Status Codes

```bash copy
check_file() {
    local file=$1
    
    if [ -f "$file" ]; then
        echo "File exists: $file"
        return 0  # Success
    else
        echo "File not found: $file" >&2
        return 1  # Failure
    fi
}

# Check return status
if check_file "config.txt"; then
    echo "Proceeding with config"
else
    echo "Cannot proceed without config"
    exit 1
fi
```

**Return Values:**
- `return 0` → success
- `return 1-255` → failure (various error codes)
- No return → returns status of last command

---

### BASH-163 — Capturing Function Output

```bash copy
get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Capture output
timestamp=$(get_timestamp)
echo "Current time: $timestamp"
```

**Key Insight:**
Functions return status codes, but output strings via stdout.

---

### BASH-164 — Returning Complex Data

```bash copy
# Method 1: Global variable
get_server_info() {
    local server=$1
    SERVER_IP=$(dig +short "$server" | head -n1)
    SERVER_STATUS=$(ping -c 1 "$server" &>/dev/null && echo "up" || echo "down")
}

get_server_info "example.com"
echo "IP: $SERVER_IP"
echo "Status: $SERVER_STATUS"

# Method 2: Print and capture
get_server_info() {
    local server=$1
    local ip=$(dig +short "$server" | head -n1)
    local status=$(ping -c 1 "$server" &>/dev/null && echo "up" || echo "down")
    echo "$ip|$status"
}

result=$(get_server_info "example.com")
ip="${result%|*}"
status="${result#*|}"
```

---

### BASH-165 — Return Status with Output

```bash copy
validate_and_parse() {
    local input=$1
    
    # Validate
    if [[ ! "$input" =~ ^[0-9]+$ ]]; then
        echo "Invalid input: not a number" >&2
        return 1
    fi
    
    # Process and output
    local result=$((input * 2))
    echo "$result"
    return 0
}

# Use both status and output
if result=$(validate_and_parse "42"); then
    echo "Result: $result"
else
    echo "Validation failed"
fi
```

</div>

</details>

---

<details>
<summary><strong>5. Variable Scope</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-166 — Local vs Global Variables

```bash copy
#!/bin/bash

# Global variable
global_var="I'm global"

test_scope() {
    # Local variable (only in function)
    local local_var="I'm local"
    
    # Accessing global
    echo "Inside function:"
    echo "  Global: $global_var"
    echo "  Local: $local_var"
    
    # Modifying global
    global_var="Modified inside function"
}

test_scope

echo "Outside function:"
echo "  Global: $global_var"  # Modified value
echo "  Local: $local_var"    # Empty (not accessible)
```

---

### BASH-167 — Always Use local

```bash copy
# BAD - modifies global accidentally
counter=0

increment() {
    counter=$((counter + 1))  # Modifies global!
}

increment
echo $counter  # 1 (global was modified)

# GOOD - uses local
counter=0

increment() {
    local counter=$1
    echo $((counter + 1))
}

result=$(increment $counter)
echo "Global: $counter"  # Still 0
echo "Result: $result"   # 1
```

**Critical Rule:**
Always use `local` for function variables to prevent side effects.

---

### BASH-168 — Shadowing Global Variables

```bash copy
name="Global"

test_shadow() {
    local name="Local"
    echo "Inside function: $name"  # Local
}

test_shadow
echo "Outside function: $name"  # Global
```

---

### BASH-169 — Readonly Variables in Functions

```bash copy
readonly MAX_RETRIES=5

test_readonly() {
    # Can read readonly variables
    echo "Max retries: $MAX_RETRIES"
    
    # Cannot modify them
    # MAX_RETRIES=10  # Error: readonly variable
}
```

</div>

</details>

---

<details>
<summary><strong>6. Function Libraries</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-170 — Creating a Library File

```bash copy
# File: lib/utils.sh

log() {
    local level=$1
    shift
    local message="$@"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message"
}

check_command() {
    local cmd=$1
    if ! command -v "$cmd" &>/dev/null; then
        log ERROR "Command not found: $cmd"
        return 1
    fi
    return 0
}

retry() {
    local max_attempts=$1
    shift
    local attempt=1
    
    until "$@" || [ $attempt -eq $max_attempts ]; do
        log WARN "Attempt $attempt failed, retrying..."
        sleep 2
        ((attempt++))
    done
    
    [ $attempt -le $max_attempts ]
}
```

---

### BASH-171 — Sourcing Library Files

```bash copy
#!/bin/bash
# Main script

# Source library
source lib/utils.sh

# Or with error checking
if [ -f lib/utils.sh ]; then
    source lib/utils.sh
else
    echo "Library not found: lib/utils.sh" >&2
    exit 1
fi

# Use library functions
log INFO "Script started"
check_command docker || exit 1
retry 3 curl -s http://example.com
```

---

### BASH-172 — Multiple Library Files

```bash copy
#!/bin/bash
# Organized project structure

# Source all libraries
for lib in lib/*.sh; do
    [ -f "$lib" ] && source "$lib"
done

# Now use any function from any library
log INFO "Starting deployment"
validate_environment prod
deploy_application v1.2.3
send_notification "Deployment complete"
```

---

### BASH-173 — Library Best Practices

**Directory Structure:**
```
project/
├── main.sh
└── lib/
    ├── logging.sh
    ├── validation.sh
    ├── deployment.sh
    └── notifications.sh
```

**Example - lib/logging.sh:**
```bash copy
#!/bin/bash
# Logging utilities

readonly LOG_FILE="${LOG_FILE:-/var/log/myapp.log}"

log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $@" | tee -a "$LOG_FILE"
}

log_warn() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARN] $@" | tee -a "$LOG_FILE" >&2
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $@" | tee -a "$LOG_FILE" >&2
}

log_debug() {
    if [ "${DEBUG:-0}" = "1" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [DEBUG] $@" | tee -a "$LOG_FILE"
    fi
}
```

---

### BASH-174 — Preventing Multiple Sourcing

```bash copy
# lib/utils.sh

# Guard against multiple sourcing
if [ -n "${_UTILS_SH_LOADED}" ]; then
    return 0
fi
readonly _UTILS_SH_LOADED=1

# Library functions here
log() {
    echo "[$@]"
}
```

</div>

</details>

---

<details>
<summary><strong>7. Error Handling in Functions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-175 — Basic Error Handling

```bash copy
backup_database() {
    local database=$1
    local backup_file=$2
    
    # Validate parameters
    if [ -z "$database" ] || [ -z "$backup_file" ]; then
        echo "Usage: backup_database <database> <backup_file>" >&2
        return 1
    fi
    
    # Perform backup
    if pg_dump "$database" > "$backup_file"; then
        echo "Backup successful: $backup_file"
        return 0
    else
        echo "Backup failed" >&2
        return 1
    fi
}

# Use with error handling
if backup_database myapp /backups/myapp.sql; then
    echo "Proceeding with next step"
else
    echo "Cannot continue after backup failure"
    exit 1
fi
```

---

### BASH-176 — Error Codes

```bash copy
# Define error codes as constants
readonly ERR_INVALID_ARGS=1
readonly ERR_FILE_NOT_FOUND=2
readonly ERR_NETWORK_ERROR=3
readonly ERR_PERMISSION_DENIED=4

validate_file() {
    local file=$1
    
    if [ $# -eq 0 ]; then
        echo "Error: No file specified" >&2
        return $ERR_INVALID_ARGS
    fi
    
    if [ ! -e "$file" ]; then
        echo "Error: File not found: $file" >&2
        return $ERR_FILE_NOT_FOUND
    fi
    
    if [ ! -r "$file" ]; then
        echo "Error: Permission denied: $file" >&2
        return $ERR_PERMISSION_DENIED
    fi
    
    return 0
}

# Handle different errors
validate_file "config.txt"
case $? in
    0)
        echo "File is valid"
        ;;
    $ERR_INVALID_ARGS)
        echo "Invalid arguments"
        exit 1
        ;;
    $ERR_FILE_NOT_FOUND)
        echo "Creating default config..."
        ;;
    $ERR_PERMISSION_DENIED)
        echo "Please check file permissions"
        exit 1
        ;;
esac
```

---

### BASH-177 — Try-Catch Pattern

```bash copy
try() {
    "$@"
    local status=$?
    if [ $status -ne 0 ]; then
        return $status
    fi
}

catch() {
    local status=$?
    if [ $status -ne 0 ]; then
        echo "Error occurred with status: $status" >&2
        "$@"
    fi
}

# Usage
try deploy_application v1.2.3
catch cleanup_failed_deployment
```

---

### BASH-178 — Function with Cleanup

```bash copy
process_file() {
    local file=$1
    local temp_file=$(mktemp)
    
    # Ensure cleanup happens
    trap "rm -f '$temp_file'" RETURN
    
    # Process file
    if ! transform_data "$file" > "$temp_file"; then
        echo "Transformation failed" >&2
        return 1
    fi
    
    # Validate result
    if ! validate_output "$temp_file"; then
        echo "Validation failed" >&2
        return 1
    fi
    
    # Success - move to final location
    mv "$temp_file" "${file}.processed"
    return 0
}
```

</div>

</details>

---

<details>
<summary><strong>8. Best Practices</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-179 — Single Responsibility

```bash copy
# BAD - function does too much
deploy() {
    validate_environment
    build_application
    run_tests
    push_to_registry
    update_kubernetes
    send_notification
}

# GOOD - separate concerns
deploy() {
    validate_environment || return 1
    build_application || return 1
    run_tests || return 1
    push_to_registry || return 1
    update_kubernetes || return 1
    send_notification
    return 0
}
```

---

### BASH-180 — Descriptive Function Names

```bash copy
# BAD - unclear names
chk() { :; }
dpl() { :; }
proc() { :; }

# GOOD - clear intent
check_prerequisites() { :; }
deploy_application() { :; }
process_log_files() { :; }
```

---

### BASH-181 — Document Functions

```bash copy
# Function documentation pattern
#
# Deploys application to specified environment
#
# Arguments:
#   $1 - environment (dev|staging|production)
#   $2 - version (e.g., v1.2.3)
#   $3 - replicas (optional, default: 3)
#
# Returns:
#   0 - success
#   1 - invalid arguments
#   2 - deployment failed
#
# Example:
#   deploy_application production v1.2.3 5
#
deploy_application() {
    local environment=$1
    local version=$2
    local replicas=${3:-3}
    
    # Implementation
}
```

---

### BASH-182 — Keep Functions Small

```bash copy
# GOOD - small, focused functions
validate_environment() {
    case $1 in
        dev|staging|production)
            return 0
            ;;
        *)
            echo "Invalid environment: $1" >&2
            return 1
            ;;
    esac
}

check_prerequisites() {
    command -v docker &>/dev/null || return 1
    command -v kubectl &>/dev/null || return 1
    return 0
}

deploy() {
    validate_environment "$1" || return 1
    check_prerequisites || return 1
    # Deploy logic
}
```

---

### BASH-183 — Use Constants

```bash copy
# Define constants at top
readonly MAX_RETRIES=3
readonly TIMEOUT_SECONDS=30
readonly BACKUP_DIR="/var/backups"

retry_command() {
    local attempt=1
    
    while [ $attempt -le $MAX_RETRIES ]; do
        if timeout $TIMEOUT_SECONDS "$@"; then
            return 0
        fi
        ((attempt++))
    done
    
    return 1
}
```

---

### BASH-184 — Avoid Global State

```bash copy
# BAD - modifies global state
counter=0

process_item() {
    ((counter++))  # Side effect!
}

# GOOD - pure function
count_items() {
    local items=("$@")
    echo ${#items[@]}
}

count=$(count_items item1 item2 item3)
```

</div>

</details>

---

<details>
<summary><strong>9. Testing Functions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-185 — Simple Function Tests

```bash copy
#!/bin/bash
# test_utils.sh

# Source the functions
source lib/utils.sh

# Test counter
tests_passed=0
tests_failed=0

# Test helper
assert_equals() {
    local expected=$1
    local actual=$2
    local test_name=$3
    
    if [ "$expected" = "$actual" ]; then
        echo "✓ PASS: $test_name"
        ((tests_passed++))
    else
        echo "✗ FAIL: $test_name"
        echo "  Expected: $expected"
        echo "  Actual: $actual"
        ((tests_failed++))
    fi
}

# Test cases
test_add() {
    local result=$(add 2 3)
    assert_equals 5 "$result" "add 2 3"
}

test_multiply() {
    local result=$(multiply 4 5)
    assert_equals 20 "$result" "multiply 4 5"
}

# Run tests
test_add
test_multiply

# Summary
echo ""
echo "Tests passed: $tests_passed"
echo "Tests failed: $tests_failed"

[ $tests_failed -eq 0 ] && exit 0 || exit 1
```

---

### BASH-186 — Testing with Mock Functions

```bash copy
#!/bin/bash

# Original function
deploy() {
    docker push myapp:latest
    kubectl apply -f deployment.yaml
}

# Mock for testing
mock_docker() {
    echo "[MOCK] docker $@"
    return 0
}

mock_kubectl() {
    echo "[MOCK] kubectl $@"
    return 0
}

# Test function
test_deploy() {
    # Replace commands with mocks
    docker() { mock_docker "$@"; }
    kubectl() { mock_kubectl "$@"; }
    
    # Run function
    if deploy; then
        echo "✓ Deploy test passed"
    else
        echo "✗ Deploy test failed"
    fi
}

test_deploy
```

---

### BASH-187 — Test Different Scenarios

```bash copy
#!/bin/bash

# Function to test
divide() {
    local a=$1
    local b=$2
    
    if [ $b -eq 0 ]; then
        echo "Error: Division by zero" >&2
        return 1
    fi
    
    echo $((a / b))
    return 0
}

# Test success case
test_divide_success() {
    local result=$(divide 10 2)
    [ "$result" = "5" ] && echo "✓ Success case passed"
}

# Test error case
test_divide_by_zero() {
    if ! divide 10 0 &>/dev/null; then
        echo "✓ Error case passed"
    else
        echo "✗ Error case failed"
    fi
}

test_divide_success
test_divide_by_zero
```

</div>

</details>

---

<details>
<summary><strong>10. Advanced Function Techniques</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-188 — Recursive Functions

```bash copy
# Calculate factorial recursively
factorial() {
    local n=$1
    
    if [ $n -le 1 ]; then
        echo 1
    else
        local prev=$(factorial $((n - 1)))
        echo $((n * prev))
    fi
}

result=$(factorial 5)
echo "5! = $result"  # 120
```

---

### BASH-189 — Function Pipelines

```bash copy
# Functions that work with pipes
uppercase() {
    tr '[:lower:]' '[:upper:]'
}

remove_spaces() {
    tr -d ' '
}

add_prefix() {
    sed "s/^/PREFIX_/"
}

# Use in pipeline
echo "hello world" | uppercase | remove_spaces | add_prefix
# PREFIX_HELLOWORLD
```

---

### BASH-190 — Dynamic Function Calls

```bash copy
# Call function by name stored in variable
run_command() {
    local cmd=$1
    shift
    
    if [ "$(type -t "$cmd")" = "function" ]; then
        "$cmd" "$@"
    else
        echo "Function not found: $cmd" >&2
        return 1
    fi
}

deploy_dev() {
    echo "Deploying to dev"
}

deploy_prod() {
    echo "Deploying to production"
}

# Dynamic call
environment="prod"
run_command "deploy_${environment}"
```

---

### BASH-191 — Function Wrappers

```bash copy
# Wrap commands with logging
logged() {
    local cmd=$1
    shift
    
    echo "[$(date)] Running: $cmd $@"
    
    if "$cmd" "$@"; then
        echo "[$(date)] Success: $cmd"
        return 0
    else
        echo "[$(date)] Failed: $cmd" >&2
        return 1
    fi
}

# Use wrapper
logged curl -s http://example.com
logged docker build -t myapp .
```

---

### BASH-192 — Memoization (Caching)

```bash copy
# Cache expensive function results
declare -A _cache

expensive_function() {
    local key=$1
    
    # Check cache
    if [ -n "${_cache[$key]}" ]; then
        echo "${_cache[$key]}"
        return 0
    fi
    
    # Compute (expensive operation)
    sleep 2
    local result=$(compute_something "$key")
    
    # Store in cache
    _cache[$key]=$result
    echo "$result"
}
```

---

### BASH-193 — Callbacks

```bash copy
# Function that accepts callback
process_items() {
    local callback=$1
    shift
    local items=("$@")
    
    for item in "${items[@]}"; do
        $callback "$item"
    done
}

# Callback functions
print_item() {
    echo "Item: $1"
}

process_item() {
    echo "Processing: $1"
    # Do work
}

# Use with different callbacks
process_items print_item item1 item2 item3
process_items process_item file1 file2 file3
```

</div>

</details>

---

<details>
<summary><strong>11. Common Function Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-194 — Logging Functions

```bash copy
# Structured logging
log() {
    local level=$1
    shift
    local message="$@"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message"
}

log_info() {
    log INFO "$@"
}

log_warn() {
    log WARN "$@" >&2
}

log_error() {
    log ERROR "$@" >&2
}

# Usage
log_info "Starting application"
log_warn "High memory usage detected"
log_error "Database connection failed"
```

---

### BASH-195 — Configuration Parsing

```bash copy
# Parse configuration file
load_config() {
    local config_file=$1
    
    if [ ! -f "$config_file" ]; then
        log_error "Config file not found: $config_file"
        return 1
    fi
    
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ $key =~ ^#.*$ || -z $key ]] && continue
        
        # Trim whitespace
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        # Export as environment variable
        export "$key"="$value"
        log_info "Loaded: $key=$value"
    done < "$config_file"
}

# Usage
load_config /etc/myapp/config.conf
```

---

### BASH-196 — Validation Functions

```bash copy
# Input validation suite
is_integer() {
    [[ $1 =~ ^[0-9]+$ ]]
}

is_email() {
    [[ $1 =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$ ]]
}

is_ip_address() {
    [[ $1 =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]
}

is_valid_url() {
    [[ $1 =~ ^https?:// ]]
}

# Usage
if is_integer "42"; then
    echo "Valid integer"
fi

if is_email "user@example.com"; then
    echo "Valid email"
fi
```

---

### BASH-197 — Retry Logic

```bash copy
# Generic retry function
retry() {
    local max_attempts=$1
    local wait_time=${2:-1}
    shift 2
    
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if "$@"; then
            return 0
        fi
        
        if [ $attempt -lt $max_attempts ]; then
            log_warn "Attempt $attempt/$max_attempts failed, retrying in ${wait_time}s..."
            sleep $wait_time
        fi
        
        ((attempt++))
    done
    
    log_error "Failed after $max_attempts attempts"
    return 1
}

# Usage
retry 5 2 curl -s http://api.example.com/health
retry 3 1 docker pull myapp:latest
```

---

### BASH-198 — Confirmation Prompts

```bash copy
# Ask for user confirmation
confirm() {
    local prompt=${1:-"Continue?"}
    local default=${2:-"n"}
    
    local yn
    while true; do
        read -p "$prompt (y/n) [${default}]: " yn
        yn=${yn:-$default}
        
        case $yn in
            [Yy]*)
                return 0
                ;;
            [Nn]*)
                return 1
                ;;
            *)
                echo "Please answer y or n"
                ;;
        esac
    done
}

# Usage
if confirm "Delete all logs?" "n"; then
    rm -rf /var/log/myapp/*
    echo "Logs deleted"
else
    echo "Operation cancelled"
fi
```

---

### BASH-199 — Progress Indicators

```bash copy
# Show progress bar
show_progress() {
    local current=$1
    local total=$2
    local width=50
    
    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    printf "\rProgress: ["
    printf "%${filled}s" | tr ' ' '#'
    printf "%${empty}s" | tr ' ' '-'
    printf "] %3d%%" $percent
    
    [ $current -eq $total ] && echo ""
}

# Usage
total=100
for i in $(seq 1 $total); do
    # Do work
    sleep 0.01
    show_progress $i $total
done
```

---

### BASH-200 — Resource Cleanup

```bash copy
# Cleanup function with trap
cleanup() {
    local exit_code=$?
    
    log_info "Cleaning up resources..."
    
    # Remove temp files
    [ -n "$temp_dir" ] && rm -rf "$temp_dir"
    
    # Stop background processes
    [ -n "$bg_pid" ] && kill $bg_pid 2>/dev/null
    
    # Unlock resources
    [ -f "$lock_file" ] && rm -f "$lock_file"
    
    log_info "Cleanup complete"
    exit $exit_code
}

# Set trap
trap cleanup EXIT INT TERM

# Script logic
temp_dir=$(mktemp -d)
lock_file="/tmp/myapp.lock"
```

</div>

</details>

---

<details>
<summary><strong>12. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Modular Deployment Script

```bash copy
#!/bin/bash
# deploy.sh - Production deployment with functions

set -euo pipefail

# Source libraries
source lib/logging.sh
source lib/validation.sh

# Configuration
readonly DOCKER_REGISTRY="registry.example.com"
readonly KUBE_NAMESPACE="production"

#
# Validates deployment parameters
# Arguments: $1=version
# Returns: 0=success, 1=failure
#
validate_deployment() {
    local version=$1
    
    log_info "Validating deployment..."
    
    # Check version format
    if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log_error "Invalid version format: $version"
        return 1
    fi
    
    # Check required tools
    local required_tools=(docker kubectl)
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &>/dev/null; then
            log_error "Required tool not found: $tool"
            return 1
        fi
    done
    
    log_info "Validation passed"
    return 0
}

#
# Builds Docker image
# Arguments: $1=version
# Returns: 0=success, 1=failure
#
build_image() {
    local version=$1
    local image="${DOCKER_REGISTRY}/myapp:${version}"
    
    log_info "Building image: $image"
    
    if docker build -t "$image" .; then
        log_info "Build successful"
        return 0
    else
        log_error "Build failed"
        return 1
    fi
}

#
# Pushes image to registry
# Arguments: $1=version
# Returns: 0=success, 1=failure
#
push_image() {
    local version=$1
    local image="${DOCKER_REGISTRY}/myapp:${version}"
    
    log_info "Pushing image: $image"
    
    if retry 3 docker push "$image"; then
        log_info "Push successful"
        return 0
    else
        log_error "Push failed"
        return 1
    fi
}

#
# Updates Kubernetes deployment
# Arguments: $1=version
# Returns: 0=success, 1=failure
#
update_kubernetes() {
    local version=$1
    local image="${DOCKER_REGISTRY}/myapp:${version}"
    
    log_info "Updating Kubernetes deployment"
    
    if kubectl set image deployment/myapp \
        myapp="$image" \
        --namespace="$KUBE_NAMESPACE"; then
        log_info "Deployment updated"
    else
        log_error "Deployment update failed"
        return 1
    fi
    
    # Wait for rollout
    log_info "Waiting for rollout..."
    if kubectl rollout status deployment/myapp \
        --namespace="$KUBE_NAMESPACE" \
        --timeout=300s; then
        log_info "Rollout successful"
        return 0
    else
        log_error "Rollout failed"
        return 1
    fi
}

#
# Performs health check
# Returns: 0=healthy, 1=unhealthy
#
health_check() {
    local endpoint="https://api.example.com/health"
    
    log_info "Performing health check"
    
    if retry 5 curl -sf "$endpoint" &>/dev/null; then
        log_info "Health check passed"
        return 0
    else
        log_error "Health check failed"
        return 1
    fi
}

#
# Sends deployment notification
# Arguments: $1=version, $2=status
#
send_notification() {
    local version=$1
    local status=$2
    
    local message="Deployment $version: $status"
    
    # Send to Slack/email/etc
    log_info "Notification: $message"
    # curl -X POST webhook_url -d "{\"text\":\"$message\"}"
}

#
# Rollback deployment
# Returns: 0=success, 1=failure
#
rollback_deployment() {
    log_warn "Rolling back deployment"
    
    if kubectl rollout undo deployment/myapp \
        --namespace="$KUBE_NAMESPACE"; then
        log_info "Rollback successful"
        return 0
    else
        log_error "Rollback failed"
        return 1
    fi
}

#
# Main deployment orchestration
#
main() {
    local version=${1:?"Version required"}
    
    log_info "=== Starting Deployment ==="
    log_info "Version: $version"
    log_info "Namespace: $KUBE_NAMESPACE"
    
    # Confirm production deployment
    if ! confirm "Deploy $version to production?" "n"; then
        log_info "Deployment cancelled"
        exit 0
    fi
    
    # Execute deployment steps
    validate_deployment "$version" || exit 1
    build_image "$version" || exit 1
    push_image "$version" || exit 1
    
    if update_kubernetes "$version"; then
        if health_check; then
            send_notification "$version" "SUCCESS"
            log_info "=== Deployment Complete ==="
            exit 0
        else
            log_error "Health check failed after deployment"
            rollback_deployment
            send_notification "$version" "FAILED (rolled back)"
            exit 1
        fi
    else
        log_error "Deployment failed"
        send_notification "$version" "FAILED"
        exit 1
    fi
}

# Run main function
main "$@"
```

---

### Scenario 2: Database Maintenance Suite

```bash copy
#!/bin/bash
# db_maintenance.sh - Database maintenance functions

set -euo pipefail

source lib/logging.sh

# Configuration
readonly BACKUP_DIR="/var/backups/databases"
readonly RETENTION_DAYS=30

#
# Creates database backup
# Arguments: $1=database_name
# Returns: 0=success, 1=failure
#
backup_database() {
    local db_name=$1
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${BACKUP_DIR}/${db_name}_${timestamp}.sql"
    
    log_info "Backing up database: $db_name"
    
    # Create backup directory
    mkdir -p "$BACKUP_DIR"
    
    # Perform backup
    if pg_dump "$db_name" > "$backup_file"; then
        log_info "Backup created: $(basename "$backup_file")"
    else
        log_error "Backup failed: $db_name"
        rm -f "$backup_file"
        return 1
    fi
    
    # Compress backup
    if gzip "$backup_file"; then
        local size=$(du -h "${backup_file}.gz" | awk '{print $1}')
        log_info "Backup compressed: $size"
        return 0
    else
        log_warn "Compression failed (backup saved uncompressed)"
        return 0
    fi
}

#
# Verifies backup integrity
# Arguments: $1=backup_file
# Returns: 0=valid, 1=invalid
#
verify_backup() {
    local backup_file=$1
    
    log_info "Verifying backup: $(basename "$backup_file")"
    
    # Check file exists and not empty
    if [ ! -s "$backup_file" ]; then
        log_error "Backup is empty or missing"
        return 1
    fi
    
    # Check if compressed
    if [[ "$backup_file" == *.gz ]]; then
        if gzip -t "$backup_file" 2>/dev/null; then
            log_info "Backup integrity verified"
            return 0
        else
            log_error "Backup is corrupted"
            return 1
        fi
    fi
    
    log_info "Backup verified"
    return 0
}

#
# Rotates old backups
# Arguments: $1=database_name
#
rotate_backups() {
    local db_name=$1
    local deleted=0
    
    log_info "Rotating backups for: $db_name"
    
    while IFS= read -r old_backup; do
        log_info "Removing old backup: $(basename "$old_backup")"
        rm "$old_backup"
        ((deleted++))
    done < <(find "$BACKUP_DIR" \
        -name "${db_name}_*.sql.gz" \
        -mtime +$RETENTION_DAYS)
    
    if [ $deleted -gt 0 ]; then
        log_info "Removed $deleted old backup(s)"
    else
        log_info "No old backups to remove"
    fi
}

#
# Optimizes database
# Arguments: $1=database_name
# Returns: 0=success, 1=failure
#
optimize_database() {
    local db_name=$1
    
    log_info "Optimizing database: $db_name"
    
    # Vacuum and analyze
    if psql "$db_name" -c "VACUUM ANALYZE;" &>/dev/null; then
        log_info "Optimization complete"
        return 0
    else
        log_error "Optimization failed"
        return 1
    fi
}

#
# Checks database size
# Arguments: $1=database_name
#
check_database_size() {
    local db_name=$1
    
    local size=$(psql -t "$db_name" -c "
        SELECT pg_size_pretty(pg_database_size('$db_name'));
    " | xargs)
    
    log_info "Database size: $size"
    echo "$size"
}

#
# Full maintenance routine
# Arguments: $1=database_name
#
full_maintenance() {
    local db_name=$1
    
    log_info "=== Starting Maintenance: $db_name ==="
    
    # Check size before
    local size_before=$(check_database_size "$db_name")
    
    # Backup
    if ! backup_database "$db_name"; then
        log_error "Backup failed, skipping maintenance"
        return 1
    fi
    
    # Optimize
    optimize_database "$db_name"
    
    # Check size after
    local size_after=$(check_database_size "$db_name")
    
    # Rotate old backups
    rotate_backups "$db_name"
    
    log_info "=== Maintenance Complete ==="
    log_info "Size before: $size_before"
    log_info "Size after: $size_after"
}

#
# Main function
#
main() {
    case ${1:-} in
        backup)
            backup_database "${2:?"Database name required"}"
            ;;
        verify)
            verify_backup "${2:?"Backup file required"}"
            ;;
        rotate)
            rotate_backups "${2:?"Database name required"}"
            ;;
        optimize)
            optimize_database "${2:?"Database name required"}"
            ;;
        full)
            full_maintenance "${2:?"Database name required"}"
            ;;
        *)
            echo "Usage: $0 {backup|verify|rotate|optimize|full} <database>" >&2
            exit 1
            ;;
    esac
}

main "$@"
```

---

### Scenario 3: System Health Monitor

```bash copy
#!/bin/bash
# health_monitor.sh - System health monitoring with functions

set -euo pipefail

source lib/logging.sh

# Thresholds
readonly CPU_THRESHOLD=80
readonly MEMORY_THRESHOLD=85
readonly DISK_THRESHOLD=90

#
# Checks CPU usage
# Returns: 0=ok, 1=high
#
check_cpu() {
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    local cpu_int=${cpu_usage%.*}
    
    log_info "CPU usage: ${cpu_usage}%"
    
    if [ $cpu_int -gt $CPU_THRESHOLD ]; then
        log_warn "CPU usage above threshold (${CPU_THRESHOLD}%)"
        return 1
    fi
    
    return 0
}

#
# Checks memory usage
# Returns: 0=ok, 1=high
#
check_memory() {
    local mem_usage=$(free | grep Mem | awk '{print int($3/$2 * 100)}')
    
    log_info "Memory usage: ${mem_usage}%"
    
    if [ $mem_usage -gt $MEMORY_THRESHOLD ]; then
        log_warn "Memory usage above threshold (${MEMORY_THRESHOLD}%)"
        return 1
    fi
    
    return 0
}

#
# Checks disk usage
# Arguments: $1=mount_point (default: /)
# Returns: 0=ok, 1=high
#
check_disk() {
    local mount=${1:-"/"}
    local disk_usage=$(df -h "$mount" | awk 'NR==2 {print $5}' | sed 's/%//')
    
    log_info "Disk usage ($mount): ${disk_usage}%"
    
    if [ $disk_usage -gt $DISK_THRESHOLD ]; then
        log_warn "Disk usage above threshold (${DISK_THRESHOLD}%)"
        return 1
    fi
    
    return 0
}

#
# Checks service status
# Arguments: $1=service_name
# Returns: 0=running, 1=not running
#
check_service() {
    local service=$1
    
    if systemctl is-active "$service" &>/dev/null; then
        log_info "Service $service: running"
        return 0
    else
        log_error "Service $service: not running"
        return 1
    fi
}

#
# Checks port availability
# Arguments: $1=port
# Returns: 0=open, 1=closed
#
check_port() {
    local port=$1
    
    if nc -z localhost "$port" &>/dev/null; then
        log_info "Port $port: open"
        return 0
    else
        log_error "Port $port: closed"
        return 1
    fi
}

#
# Gets top processes by CPU
# Arguments: $1=count (default: 5)
#
get_top_cpu_processes() {
    local count=${1:-5}
    
    log_info "Top $count CPU processes:"
    ps aux --sort=-%cpu | head -n $((count + 1)) | tail -n $count | \
    while read -r line; do
        log_info "  $line"
    done
}

#
# Gets top processes by memory
# Arguments: $1=count (default: 5)
#
get_top_memory_processes() {
    local count=${1:-5}
    
    log_info "Top $count memory processes:"
    ps aux --sort=-%mem | head -n $((count + 1)) | tail -n $count | \
    while read -r line; do
        log_info "  $line"
    done
}

#
# Performs comprehensive health check
# Returns: 0=healthy, 1=issues detected
#
comprehensive_check() {
    local issues=0
    
    log_info "=== System Health Check ==="
    
    # Resource checks
    check_cpu || ((issues++))
    check_memory || ((issues++))
    check_disk "/" || ((issues++))
    
    # Service checks
    local critical_services=(nginx postgresql redis)
    for service in "${critical_services[@]}"; do
        check_service "$service" || ((issues++))
    done
    
    # Port checks
    local critical_ports=(80 443 5432 6379)
    for port in "${critical_ports[@]}"; do
        check_port "$port" || ((issues++))
    done
    
    # Show top processes if issues detected
    if [ $issues -gt 0 ]; then
        get_top_cpu_processes 5
        get_top_memory_processes 5
    fi
    
    log_info "=== Check Complete ==="
    log_info "Issues detected: $issues"
    
    return $([ $issues -eq 0 ] && echo 0 || echo 1)
}

#
# Main function
#
main() {
    case ${1:-check} in
        check)
            comprehensive_check
            ;;
        cpu)
            check_cpu
            ;;
        memory)
            check_memory
            ;;
        disk)
            check_disk "${2:-/}"
            ;;
        service)
            check_service "${2:?"Service name required"}"
            ;;
        port)
            check_port "${2:?"Port number required"}"
            ;;
        *)
            echo "Usage: $0 {check|cpu|memory|disk|service|port} [args]" >&2
            exit 1
            ;;
    esac
}

main "$@"
```

</div>

</details>

---

<details>
<summary><strong>13. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Define function (method 1)
function my_function() {
    echo "Hello"
}
```

```bash copy
# Define function (method 2 - POSIX)
my_function() {
    echo "Hello"
}
```

```bash copy
# Call function
my_function
```

```bash copy
# Function with parameters
greet() {
    local name=$1
    echo "Hello, $name"
}
greet "Alice"
```

```bash copy
# Return status code
check_file() {
    [ -f "$1" ] && return 0 || return 1
}
```

```bash copy
# Capture function output
result=$(my_function)
```

```bash copy
# Local variable
my_function() {
    local var="value"
}
```

```bash copy
# Source library file
source lib/utils.sh
```

```bash copy
# Source with error checking
[ -f lib/utils.sh ] && source lib/utils.sh
```

```bash copy
# Check if function exists
if [ "$(type -t my_function)" = "function" ]; then
    my_function
fi
```

```bash copy
# List all functions
declare -F
```

```bash copy
# Show function definition
declare -f my_function
```

```bash copy
# Unset function
unset -f my_function
```

```bash copy
# Export function to subshells
export -f my_function
```

</div>

</details>

---

<details>
<summary><strong>14. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Functions organize code into reusable blocks
- Always use `local` for function variables
- Functions return status codes (0-255)
- Capture output with command substitution
- Define functions before calling them
- Source library files to share functions

---

**Function Definition:**

```bash copy
# POSIX style (recommended)
function_name() {
    local param=$1
    # function body
    return 0
}

# With function keyword
function function_name() {
    # function body
}
```

---

**Parameters and Return Values:**

| Concept | Syntax | Example |
|---------|--------|---------|
| Access parameter | `$1`, `$2`, etc. | `local name=$1` |
| All parameters | `$@` | `echo "$@"` |
| Parameter count | `$#` | `[ $# -eq 0 ]` |
| Return status | `return N` | `return 1` |
| Capture output | `$(func)` | `result=$(get_value)` |

---

**Variable Scope:**

| Scope | Declaration | Visibility |
|-------|-------------|----------|
| Local | `local var="value"` | Function only |
| Global | `var="value"` | Entire script |
| Exported | `export var="value"` | Subshells too |
| Readonly | `readonly var="value"` | Cannot modify |

---

**Best Practices:**

1. **Use local variables**
   ```bash copy
   my_function() {
       local var="value"  # Always use local
   }
   ```

2. **Validate parameters**
   ```bash copy
   my_function() {
       [ $# -eq 0 ] && return 1
       local param=$1
   }
   ```

3. **Return status codes**
   ```bash copy
   my_function() {
       # work
       return 0  # success
   }
   ```

4. **Document functions**
   ```bash copy
   # Description of function
   # Arguments: $1=name, $2=value
   # Returns: 0=success, 1=failure
   my_function() {
       # implementation
   }
   ```

5. **Keep functions small**
   - One responsibility per function
   - 20-30 lines max
   - Extract complex logic

---

**Common Patterns:**

```bash copy
# Validation
validate_input() {
    [ $# -eq 0 ] && return 1
    [[ $1 =~ ^[0-9]+$ ]] && return 0 || return 1
}

# Retry logic
retry() {
    local max=$1
    shift
    for i in $(seq 1 $max); do
        "$@" && return 0
        sleep 1
    done
    return 1
}

# Logging
log() {
    echo "[$(date)] $@"
}

# Cleanup
cleanup() {
    rm -rf "$temp_dir"
}
trap cleanup EXIT
```

---

**Library Structure:**

```
project/
├── script.sh
└── lib/
    ├── logging.sh
    ├── validation.sh
    └── utils.sh
```

**Loading libraries:**
```bash copy
# Load all libraries
for lib in lib/*.sh; do
    source "$lib"
done
```

---

**Function Testing:**

```bash copy
# Simple test
test_function() {
    result=$(my_function arg)
    [ "$result" = "expected" ] && echo "PASS" || echo "FAIL"
}

# With assertion
assert_equals() {
    [ "$1" = "$2" ] && echo "✓ PASS" || echo "✗ FAIL"
}
```

---

**What's Next:**
Now that you can organize code with functions, the next file covers arrays and string manipulation — how to handle collections of data and process text efficiently.

</div>

</details>

---
