# **09. Advanced Scripting Techniques — Professional Bash Patterns**
> Mastering command-line parsing, configuration management, and production patterns.

---

## Table of Contents
- [1. Why Advanced Techniques Matter](#1-why-advanced-techniques-matter)
- [2. Command-Line Argument Parsing](#2-command-line-argument-parsing)
- [3. Configuration Management](#3-configuration-management)
- [4. Modular Script Design](#4-modular-script-design)
- [5. Signal Handling Patterns](#5-signal-handling-patterns)
- [6. Concurrency and Parallelism](#6-concurrency-and-parallelism)
- [7. IPC and Communication](#7-ipc-and-communication)
- [8. Performance Optimization](#8-performance-optimization)
- [9. Security Considerations](#9-security-considerations)
- [10. Production Patterns](#10-production-patterns)
- [11. Code Generation](#11-code-generation)
- [12. Real-World Scenarios](#12-real-world-scenarios)
- [13. Commands Reference](#13-commands-reference)
- [14. Quick Reference](#14-quick-reference)

---

<details>
<summary><strong>1. Why Advanced Techniques Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Simple scripts become complex tools.

What starts as a 20-line helper becomes:
- a critical production tool
- shared across teams
- needs configuration
- requires robust CLI
- must handle edge cases

Understanding advanced techniques means:
- you can build professional-grade tools
- you can handle complex requirements
- you can write maintainable automation
- you can scale scripts to production

This isn't about showing off.
It's about writing scripts that others can use confidently — scripts that behave like real tools, not quick hacks.

</div>

</details>

---

<details>
<summary><strong>2. Command-Line Argument Parsing</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-401 — getopts for Short Options

```bash copy
#!/bin/bash

# Default values
verbose=0
output=""
force=0

# Parse options
while getopts "vo:fh" opt; do
    case $opt in
        v)
            verbose=1
            ;;
        o)
            output="$OPTARG"
            ;;
        f)
            force=1
            ;;
        h)
            show_help
            exit 0
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument" >&2
            exit 1
            ;;
    esac
done

# Shift past options
shift $((OPTIND - 1))

# Remaining arguments
echo "Positional args: $@"
```

---

### BASH-402 — Long Options Pattern

```bash copy
#!/bin/bash

# Parse long options
while [ $# -gt 0 ]; do
    case $1 in
        --verbose|-v)
            verbose=1
            shift
            ;;
        --output|-o)
            output="$2"
            shift 2
            ;;
        --force|-f)
            force=1
            shift
            ;;
        --config)
            config="$2"
            shift 2
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        -*)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done
```

---

### BASH-403 — Subcommand Pattern

```bash copy
#!/bin/bash
# tool.sh - Multi-command tool

cmd_deploy() {
    echo "Deploying..."
}

cmd_rollback() {
    echo "Rolling back..."
}

cmd_status() {
    echo "Checking status..."
}

# Main dispatcher
main() {
    local subcommand=${1:-}
    
    if [ -z "$subcommand" ]; then
        echo "Usage: $0 <command> [options]" >&2
        echo "Commands: deploy, rollback, status" >&2
        exit 1
    fi
    
    shift
    
    # Dispatch to subcommand
    case $subcommand in
        deploy)
            cmd_deploy "$@"
            ;;
        rollback)
            cmd_rollback "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        *)
            echo "Unknown command: $subcommand" >&2
            exit 1
            ;;
    esac
}

main "$@"
```

---

### BASH-404 — Advanced Argument Parser

```bash copy
#!/bin/bash

# Configuration
VERBOSE=0
DRY_RUN=0
CONFIG_FILE=""
declare -a POSITIONAL=()

show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] [ARGS]

OPTIONS:
    -v, --verbose          Verbose output
    -d, --dry-run          Dry run mode
    -c, --config FILE      Configuration file
    -h, --help             Show this help

EXAMPLES:
    $(basename "$0") --verbose file1 file2
    $(basename "$0") -c config.yaml deploy
EOF
}

parse_args() {
    while [ $# -gt 0 ]; do
        case $1 in
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -c|--config)
                if [ -z "${2:-}" ]; then
                    echo "Error: --config requires an argument" >&2
                    exit 1
                fi
                CONFIG_FILE="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            --)
                shift
                POSITIONAL+=("$@")
                break
                ;;
            -*)
                echo "Error: Unknown option: $1" >&2
                show_help >&2
                exit 1
                ;;
            *)
                POSITIONAL+=("$1")
                shift
                ;;
        esac
    done
}

# Parse
parse_args "$@"

# Restore positional parameters
set -- "${POSITIONAL[@]}"

echo "Verbose: $VERBOSE"
echo "Dry run: $DRY_RUN"
echo "Config: $CONFIG_FILE"
echo "Args: $@"
```

---

### BASH-405 — Flag Accumulation

```bash copy
#!/bin/bash

# Accumulate flags
verbosity=0

while getopts "vvv" opt; do
    case $opt in
        v)
            ((verbosity++))
            ;;
    esac
done

case $verbosity in
    0)
        echo "Normal output"
        ;;
    1)
        echo "Verbose output"
        ;;
    2)
        echo "Very verbose output"
        ;;
    *)
        echo "Debug output (verbosity: $verbosity)"
        ;;
esac
```

</div>

</details>

---

<details>
<summary><strong>3. Configuration Management</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-406 — Environment-Based Config

```bash copy
#!/bin/bash

# Defaults
: ${APP_HOST:="localhost"}
: ${APP_PORT:="8080"}
: ${APP_ENV:="development"}
: ${LOG_LEVEL:="info"}

# Load from environment file
load_env() {
    local env_file=${1:-.env}
    
    if [ -f "$env_file" ]; then
        # Export variables from file
        set -a
        source "$env_file"
        set +a
        
        echo "Loaded: $env_file"
    fi
}

# Validate configuration
validate_config() {
    local errors=0
    
    if [ -z "$APP_HOST" ]; then
        echo "Error: APP_HOST not set" >&2
        ((errors++))
    fi
    
    if ! [[ $APP_PORT =~ ^[0-9]+$ ]]; then
        echo "Error: APP_PORT must be numeric" >&2
        ((errors++))
    fi
    
    return $errors
}

load_env
validate_config || exit 1
```

---

### BASH-407 — Multi-Layer Configuration

```bash copy
#!/bin/bash

# Configuration precedence:
# 1. Command line arguments (highest)
# 2. Environment variables
# 3. Config file
# 4. Defaults (lowest)

# Layer 1: Defaults
HOST="localhost"
PORT="8080"
DEBUG="0"

# Layer 2: Config file
load_config() {
    local config_file="$1"
    
    if [ -f "$config_file" ]; then
        while IFS='=' read -r key value; do
            [[ $key =~ ^#.*$ || -z $key ]] && continue
            
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | xargs)
            
            case $key in
                HOST) HOST="$value" ;;
                PORT) PORT="$value" ;;
                DEBUG) DEBUG="$value" ;;
            esac
        done < "$config_file"
    fi
}

# Layer 3: Environment variables
[ -n "$APP_HOST" ] && HOST="$APP_HOST"
[ -n "$APP_PORT" ] && PORT="$APP_PORT"
[ -n "$APP_DEBUG" ] && DEBUG="$APP_DEBUG"

# Layer 4: Command line (parsed earlier)
# Overrides everything

echo "Final config:"
echo "  HOST=$HOST"
echo "  PORT=$PORT"
echo "  DEBUG=$DEBUG"
```

---

### BASH-408 — INI File Parser

```bash copy
#!/bin/bash

# Parse INI file
declare -A config

parse_ini() {
    local file=$1
    local section=""
    
    while IFS= read -r line; do
        # Remove whitespace
        line=$(echo "$line" | xargs)
        
        # Skip comments and empty lines
        [[ $line =~ ^[#;] || -z $line ]] && continue
        
        # Section header
        if [[ $line =~ ^\[(.*)\]$ ]]; then
            section="${BASH_REMATCH[1]}"
            continue
        fi
        
        # Key=value
        if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | xargs)
            
            # Store with section prefix
            if [ -n "$section" ]; then
                config["${section}.${key}"]="$value"
            else
                config["$key"]="$value"
            fi
        fi
    done < "$file"
}

# Usage
parse_ini "config.ini"

echo "Database host: ${config[database.host]}"
echo "Database port: ${config[database.port]}"
```

---

### BASH-409 — YAML Config (using yq)

```bash copy
#!/bin/bash

# Requires: yq (https://github.com/mikefarah/yq)

config_file="config.yaml"

# Read values
get_config() {
    local key=$1
    yq eval ".$key" "$config_file"
}

# Example config.yaml:
# database:
#   host: localhost
#   port: 5432
# app:
#   debug: true

DB_HOST=$(get_config "database.host")
DB_PORT=$(get_config "database.port")
APP_DEBUG=$(get_config "app.debug")

echo "DB: $DB_HOST:$DB_PORT"
echo "Debug: $APP_DEBUG"
```

---

### BASH-410 — Configuration Validation

```bash copy
#!/bin/bash

declare -A config
declare -A config_schema

# Define schema
config_schema[host]="required,string"
config_schema[port]="required,integer,range:1-65535"
config_schema[timeout]="optional,integer,min:0"
config_schema[debug]="optional,boolean"

validate_config() {
    local errors=0
    
    for key in "${!config_schema[@]}"; do
        local rules=${config_schema[$key]}
        local value=${config[$key]:-}
        
        IFS=',' read -ra rules_array <<< "$rules"
        
        for rule in "${rules_array[@]}"; do
            case $rule in
                required)
                    if [ -z "$value" ]; then
                        echo "Error: $key is required" >&2
                        ((errors++))
                    fi
                    ;;
                integer)
                    if ! [[ $value =~ ^[0-9]+$ ]]; then
                        echo "Error: $key must be integer" >&2
                        ((errors++))
                    fi
                    ;;
                range:*)
                    local range=${rule#range:}
                    local min=${range%-*}
                    local max=${range#*-}
                    if ((value < min || value > max)); then
                        echo "Error: $key must be in range $min-$max" >&2
                        ((errors++))
                    fi
                    ;;
            esac
        done
    done
    
    return $errors
}
```

</div>

</details>

---

<details>
<summary><strong>4. Modular Script Design</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-411 — Library Structure

```bash copy
# Project structure:
# project/
# ├── bin/
# │   └── tool.sh
# └── lib/
#     ├── common.sh
#     ├── deploy.sh
#     └── monitor.sh

# bin/tool.sh
#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/../lib"

# Source libraries
for lib in "$LIB_DIR"/*.sh; do
    source "$lib"
done

# Use library functions
log_info "Starting"
deploy_application
monitor_health
```

---

### BASH-412 — Lazy Loading Libraries

```bash copy
#!/bin/bash

LIB_DIR="./lib"
declare -A loaded_libs

load_lib() {
    local lib=$1
    
    # Already loaded?
    [ "${loaded_libs[$lib]}" = "1" ] && return 0
    
    local lib_file="$LIB_DIR/${lib}.sh"
    
    if [ ! -f "$lib_file" ]; then
        echo "Error: Library not found: $lib" >&2
        return 1
    fi
    
    source "$lib_file"
    loaded_libs[$lib]=1
    echo "Loaded: $lib"
}

# Load only when needed
if [ "$USE_DATABASE" = "1" ]; then
    load_lib database
fi

if [ "$USE_AWS" = "1" ]; then
    load_lib aws
fi
```

---

### BASH-413 — Plugin System

```bash copy
#!/bin/bash

PLUGIN_DIR="./plugins"
declare -a registered_plugins=()

# Plugin interface
# Each plugin must implement:
# - plugin_init()
# - plugin_process()

discover_plugins() {
    local plugin
    for plugin in "$PLUGIN_DIR"/*.sh; do
        [ -f "$plugin" ] || continue
        
        source "$plugin"
        
        # Validate plugin
        if declare -f plugin_init &>/dev/null && \
           declare -f plugin_process &>/dev/null; then
            registered_plugins+=("$(basename "$plugin" .sh)")
            echo "Registered: $(basename "$plugin")"
        else
            echo "Invalid plugin: $(basename "$plugin")" >&2
        fi
    done
}

# Initialize all plugins
init_plugins() {
    local plugin
    for plugin in "${registered_plugins[@]}"; do
        echo "Initializing: $plugin"
        plugin_init
    done
}

# Process with all plugins
process_with_plugins() {
    local data=$1
    
    for plugin in "${registered_plugins[@]}"; do
        data=$(plugin_process "$data")
    done
    
    echo "$data"
}
```

---

### BASH-414 — Namespace Pattern

```bash copy
#!/bin/bash

# Namespace: database
namespace_database() {
    db_connect() {
        echo "Connecting to database..."
    }
    
    db_query() {
        echo "Querying: $1"
    }
    
    db_close() {
        echo "Closing connection"
    }
}

# Namespace: logging
namespace_logging() {
    log_info() {
        echo "[INFO] $@"
    }
    
    log_error() {
        echo "[ERROR] $@" >&2
    }
}

# Initialize namespaces
namespace_database
namespace_logging

# Use functions
db_connect
db_query "SELECT * FROM users"
log_info "Query complete"
db_close
```

---

### BASH-415 — Dependency Injection

```bash copy
#!/bin/bash

# Interface: Logger
log_message() {
    echo "Default logger: $@"
}

# Injected logger
use_logger() {
    local logger=$1
    log_message() {
        $logger "$@"
    }
}

# Different logger implementations
syslog_logger() {
    logger -t myapp "$@"
}

file_logger() {
    echo "[$(date)] $@" >> /var/log/myapp.log
}

# Inject logger
if [ "$USE_SYSLOG" = "1" ]; then
    use_logger syslog_logger
elif [ "$USE_FILE" = "1" ]; then
    use_logger file_logger
fi

# Use logger (implementation determined at runtime)
log_message "Application started"
```

</div>

</details>

---

<details>
<summary><strong>5. Signal Handling Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-416 — Graceful Shutdown

```bash copy
#!/bin/bash

shutdown_requested=false

graceful_shutdown() {
    if [ "$shutdown_requested" = "true" ]; then
        echo "Force shutdown!"
        exit 1
    fi
    
    echo "Graceful shutdown initiated..."
    shutdown_requested=true
    
    # Allow time for cleanup
    sleep 2
}

trap graceful_shutdown INT TERM

while [ "$shutdown_requested" = "false" ]; do
    echo "Working..."
    sleep 1
done

echo "Shutdown complete"
```

---

### BASH-417 — Signal Forwarding

```bash copy
#!/bin/bash

# Start child process
long_running_process &
child_pid=$!

# Forward signals to child
forward_signal() {
    local sig=$1
    echo "Forwarding $sig to child ($child_pid)"
    kill -$sig $child_pid 2>/dev/null
}

trap 'forward_signal TERM' TERM
trap 'forward_signal INT' INT

# Wait for child
wait $child_pid
exit_code=$?

echo "Child exited with code: $exit_code"
exit $exit_code
```

---

### BASH-418 — Reload Configuration

```bash copy
#!/bin/bash

config_file="config.conf"

load_config() {
    echo "Loading configuration..."
    source "$config_file"
    echo "Config loaded: $(date)"
}

# Initial load
load_config

# Reload on SIGHUP
trap 'load_config' HUP

echo "Process running (PID: $$)"
echo "Send SIGHUP to reload: kill -HUP $$"

while true; do
    echo "Working with config: $SOME_VALUE"
    sleep 5
done
```

---

### BASH-419 — Signal-Safe Operations

```bash copy
#!/bin/bash

# Global state
processing=false

# Signal-safe handler
signal_handler() {
    # Don't interrupt critical section
    if [ "$processing" = "true" ]; then
        echo "Deferring signal until safe..."
        return
    fi
    
    echo "Handling signal immediately"
    cleanup_and_exit
}

trap signal_handler INT TERM

while true; do
    processing=true
    
    # Critical section
    echo "Critical operation..."
    sleep 2
    
    processing=false
    
    # Safe point for signals
    sleep 1
done
```

</div>

</details>

---

<details>
<summary><strong>6. Concurrency and Parallelism</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-420 — Worker Pool

```bash copy
#!/bin/bash

work_queue="/tmp/work_queue_$$"
result_queue="/tmp/result_queue_$$"
workers=4

# Create queues
mkfifo "$work_queue" "$result_queue"
trap "rm -f '$work_queue' '$result_queue'" EXIT

# Worker function
worker() {
    local id=$1
    
    while read -r task; do
        [ "$task" = "STOP" ] && break
        
        echo "[Worker $id] Processing: $task"
        result=$(process_task "$task")
        echo "$result" >> "$result_queue"
    done < "$work_queue"
}

# Start workers
for i in $(seq 1 $workers); do
    worker $i &
done

# Submit work
{
    for i in $(seq 1 20); do
        echo "task_$i"
    done
    
    # Stop signal for each worker
    for i in $(seq 1 $workers); do
        echo "STOP"
    done
} > "$work_queue" &

# Collect results
for i in $(seq 1 20); do
    read -r result < "$result_queue"
    echo "Result: $result"
done

wait
```

---

### BASH-421 — Semaphore Pattern

```bash copy
#!/bin/bash

# Limit concurrent operations
max_concurrent=3
semaphore_dir="/tmp/semaphore_$$"

mkdir -p "$semaphore_dir"
trap "rm -rf '$semaphore_dir'" EXIT

acquire_semaphore() {
    local timeout=60
    local waited=0
    
    while true; do
        local count=$(ls "$semaphore_dir" 2>/dev/null | wc -l)
        
        if ((count < max_concurrent)); then
            touch "$semaphore_dir/$$"
            return 0
        fi
        
        sleep 1
        ((waited++))
        
        if ((waited >= timeout)); then
            echo "Timeout acquiring semaphore" >&2
            return 1
        fi
    done
}

release_semaphore() {
    rm -f "$semaphore_dir/$$"
}

# Use semaphore
for i in $(seq 1 10); do
    (
        acquire_semaphore || exit 1
        trap release_semaphore EXIT
        
        echo "Task $i running"
        sleep $((RANDOM % 5 + 1))
        echo "Task $i complete"
    ) &
done

wait
```

---

### BASH-422 — Map-Reduce Pattern

```bash copy
#!/bin/bash

# Map phase
map() {
    local input=$1
    
    # Process and emit key-value pairs
    echo "key1:value1"
    echo "key2:value2"
}

# Reduce phase
reduce() {
    local key=$1
    shift
    local values=("$@")
    
    # Aggregate values for key
    local sum=0
    for val in "${values[@]}"; do
        ((sum += val))
    done
    
    echo "$key:$sum"
}

# MapReduce coordinator
mapreduce() {
    local input_files=("$@")
    local temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT
    
    # Map phase (parallel)
    for file in "${input_files[@]}"; do
        map "$file" > "$temp_dir/map_$$" &
    done
    wait
    
    # Shuffle and sort
    cat "$temp_dir"/map_* | sort > "$temp_dir/sorted"
    
    # Reduce phase
    local current_key=""
    local values=()
    
    while IFS=: read -r key value; do
        if [ "$key" != "$current_key" ]; then
            if [ -n "$current_key" ]; then
                reduce "$current_key" "${values[@]}"
            fi
            current_key="$key"
            values=()
        fi
        values+=("$value")
    done < "$temp_dir/sorted"
    
    # Final reduce
    [ -n "$current_key" ] && reduce "$current_key" "${values[@]}"
}
```

---

### BASH-423 — Async/Await Pattern

```bash copy
#!/bin/bash

# Async task
async_task() {
    local task_id=$1
    local duration=$2
    
    (
        sleep $duration
        echo "Task $task_id complete"
    ) &
    
    echo $!  # Return PID
}

# Await task
await_task() {
    local pid=$1
    wait $pid
    return $?
}

# Await all
await_all() {
    wait
}

# Usage
echo "Starting async tasks..."

pid1=$(async_task 1 2)
pid2=$(async_task 2 3)
pid3=$(async_task 3 1)

echo "Tasks started: $pid1, $pid2, $pid3"
echo "Waiting for all..."

await_all

echo "All tasks complete"
```

</div>

</details>

---

<details>
<summary><strong>7. IPC and Communication</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-424 — Named Pipes

```bash copy
#!/bin/bash

pipe="/tmp/mypipe_$$"
mkfifo "$pipe"
trap "rm -f '$pipe'" EXIT

# Producer
producer() {
    for i in {1..10}; do
        echo "Message $i"
        sleep 1
    done > "$pipe"
}

# Consumer
consumer() {
    while read -r msg; do
        echo "Received: $msg"
    done < "$pipe"
}

# Start producer and consumer
producer &
consumer

wait
```

---

### BASH-425 — Socket Communication

```bash copy
#!/bin/bash

# Server (using netcat)
server() {
    local port=9999
    
    while true; do
        echo "Listening on port $port..."
        response=$(echo "Hello from server" | nc -l $port)
        echo "Received: $response"
    done
}

# Client
client() {
    local host=localhost
    local port=9999
    
    echo "Request from client" | nc $host $port
}

# Usage
# Terminal 1: server
# Terminal 2: client
```

---

### BASH-426 — Message Queue

```bash copy
#!/bin/bash

queue_dir="/tmp/message_queue_$$"
mkdir -p "$queue_dir"
trap "rm -rf '$queue_dir'" EXIT

# Send message
send_message() {
    local queue=$1
    local message=$2
    
    local msg_file="$queue_dir/$queue/$(date +%s%N)"
    mkdir -p "$queue_dir/$queue"
    echo "$message" > "$msg_file"
}

# Receive message
receive_message() {
    local queue=$1
    local timeout=${2:-10}
    
    local elapsed=0
    while ((elapsed < timeout)); do
        local msg_file=$(ls "$queue_dir/$queue" 2>/dev/null | head -1)
        
        if [ -n "$msg_file" ]; then
            cat "$queue_dir/$queue/$msg_file"
            rm "$queue_dir/$queue/$msg_file"
            return 0
        fi
        
        sleep 1
        ((elapsed++))
    done
    
    return 1
}

# Usage
send_message "work_queue" "Task 1"
send_message "work_queue" "Task 2"

msg=$(receive_message "work_queue")
echo "Got message: $msg"
```

---

### BASH-427 — Shared Memory Pattern

```bash copy
#!/bin/bash

# Use files in tmpfs for shared memory
shm_dir="/dev/shm/myapp_$$"
mkdir -p "$shm_dir"
trap "rm -rf '$shm_dir'" EXIT

# Write to shared memory
shm_write() {
    local key=$1
    local value=$2
    echo "$value" > "$shm_dir/$key"
}

# Read from shared memory
shm_read() {
    local key=$1
    cat "$shm_dir/$key" 2>/dev/null
}

# Lock for atomic operations
shm_lock() {
    local lock_file="$shm_dir/.lock"
    exec 200>"$lock_file"
    flock 200
}

shm_unlock() {
    flock -u 200
}

# Usage
shm_write "counter" "0"

# Atomic increment
shm_lock
counter=$(shm_read "counter")
((counter++))
shm_write "counter" "$counter"
shm_unlock
```

</div>

</details>

---

<details>
<summary><strong>8. Performance Optimization</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-428 — Avoid Subshells

```bash copy
# SLOW - subshell per iteration
count=0
cat file.txt | while read line; do
    ((count++))
done
echo $count  # 0 (subshell!)

# FAST - no subshell
count=0
while read line; do
    ((count++))
done < file.txt
echo $count  # Correct
```

---

### BASH-429 — Batch Operations

```bash copy
# SLOW - one operation per file
for file in *.txt; do
    grep pattern "$file"
done

# FAST - batch operation
grep pattern *.txt

# SLOW - multiple calls
for file in *.txt; do
    stat "$file"
done

# FAST - single call
stat *.txt
```

---

### BASH-430 — Built-in vs External

```bash copy
# SLOW - external commands
basename=$(basename "$file")
dirname=$(dirname "$file")

# FAST - parameter expansion
basename=${file##*/}
dirname=${file%/*}

# SLOW - external command in loop
for file in *; do
    filename=$(basename "$file" .txt)
done

# FAST - built-in operation
for file in *; do
    filename=${file%.txt}
done
```

---

### BASH-431 — String Building

```bash copy
# SLOW - repeated concatenation
result=""
for i in {1..1000}; do
    result="${result}line $i\n"
done

# FAST - array then join
lines=()
for i in {1..1000}; do
    lines+=("line $i")
done
result=$(IFS=$'\n'; echo "${lines[*]}")

# FASTEST - printf
printf 'line %s\n' {1..1000}
```

---

### BASH-432 — Caching

```bash copy
#!/bin/bash

declare -A cache
cache_ttl=300  # 5 minutes

cache_get() {
    local key=$1
    local cache_file="/tmp/cache_${key}"
    
    if [ -f "$cache_file" ]; then
        local age=$(($(date +%s) - $(stat -c%Y "$cache_file")))
        
        if ((age < cache_ttl)); then
            cat "$cache_file"
            return 0
        fi
    fi
    
    return 1
}

cache_set() {
    local key=$1
    local value=$2
    echo "$value" > "/tmp/cache_${key}"
}

# Usage
expensive_operation() {
    sleep 2
    echo "Result: $(date +%s)"
}

key="operation_1"
if ! result=$(cache_get "$key"); then
    echo "Cache miss"
    result=$(expensive_operation)
    cache_set "$key" "$result"
fi

echo "$result"
```

---

### BASH-433 — Lazy Evaluation

```bash copy
#!/bin/bash

# Lazy load expensive data
declare -A lazy_data

lazy_get() {
    local key=$1
    
    # Return if already loaded
    if [ -n "${lazy_data[$key]}" ]; then
        echo "${lazy_data[$key]}"
        return 0
    fi
    
    # Load on demand
    echo "Loading $key..." >&2
    case $key in
        users)
            lazy_data[$key]=$(expensive_user_query)
            ;;
        config)
            lazy_data[$key]=$(expensive_config_load)
            ;;
    esac
    
    echo "${lazy_data[$key]}"
}

# Usage - only loads when accessed
users=$(lazy_get users)
config=$(lazy_get config)
```

</div>

</details>

---

<details>
<summary><strong>9. Security Considerations</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-434 — Input Validation

```bash copy
#!/bin/bash

validate_integer() {
    local value=$1
    [[ $value =~ ^[0-9]+$ ]]
}

validate_alphanumeric() {
    local value=$1
    [[ $value =~ ^[a-zA-Z0-9]+$ ]]
}

validate_path() {
    local path=$1
    # No directory traversal
    [[ ! $path =~ \.\. ]]
}

# Sanitize input
sanitize() {
    local input=$1
    # Remove dangerous characters
    echo "$input" | tr -cd '[:alnum:]._-'
}

# Usage
read -p "Enter user ID: " user_id
if ! validate_integer "$user_id"; then
    echo "Invalid user ID" >&2
    exit 1
fi

read -p "Enter filename: " filename
filename=$(sanitize "$filename")
```

---

### BASH-435 — Safe Command Execution

```bash copy
#!/bin/bash

# DANGEROUS - command injection
user_input="file.txt; rm -rf /"
cat $user_input  # DON'T DO THIS!

# SAFE - quote variables
cat "$user_input"

# DANGEROUS - eval with user input
eval "cat $user_input"  # DON'T DO THIS!

# SAFE - use arrays
files=("$file1" "$file2")
cat "${files[@]}"
```

---

### BASH-436 — Secrets Management

```bash copy
#!/bin/bash

# Load secrets from secure file
load_secrets() {
    local secrets_file="/etc/secrets/app.env"
    
    # Check permissions (should be 600)
    local perms=$(stat -c%a "$secrets_file" 2>/dev/null)
    if [ "$perms" != "600" ]; then
        echo "Error: Insecure permissions on secrets file" >&2
        return 1
    fi
    
    # Load secrets
    set -a
    source "$secrets_file"
    set +a
}

# Don't log secrets
log_safe() {
    local message=$1
    # Redact patterns
    message=$(echo "$message" | sed 's/password=.*/password=**REDACTED**/g')
    echo "$message"
}

# Clear secrets on exit
cleanup_secrets() {
    unset DATABASE_PASSWORD
    unset API_KEY
}

trap cleanup_secrets EXIT
```

---

### BASH-437 — Temporary File Security

```bash copy
#!/bin/bash

# INSECURE - predictable names
temp="/tmp/myapp_$$"
echo "secret" > "$temp"  # Race condition!

# SECURE - use mktemp
temp=$(mktemp)
chmod 600 "$temp"  # Restrict permissions
trap "shred -u '$temp'" EXIT  # Secure delete

echo "secret" > "$temp"

# For sensitive data
secure_temp() {
    local temp=$(mktemp)
    chmod 600 "$temp"
    echo "$temp"
}
```

---

### BASH-438 — Safe Privilege Escalation

```bash copy
#!/bin/bash

# Check if running as root
require_root() {
    if [ "$EUID" -ne 0 ]; then
        echo "This script must be run as root" >&2
        exit 1
    fi
}

# Drop privileges
drop_privileges() {
    local user=$1
    
    if [ "$EUID" -eq 0 ]; then
        exec sudo -u "$user" "$0" "$@"
    fi
}

# Minimal privilege principle
run_as_user() {
    local user=$1
    shift
    
    if [ "$EUID" -eq 0 ]; then
        sudo -u "$user" "$@"
    else
        "$@"
    fi
}
```

</div>

</details>

---

<details>
<summary><strong>10. Production Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-439 — Health Checks

```bash copy
#!/bin/bash

health_check() {
    local checks_passed=0
    local checks_failed=0
    
    # Check 1: Process running
    if pgrep -x myapp > /dev/null; then
        ((checks_passed++))
    else
        echo "FAIL: Process not running" >&2
        ((checks_failed++))
    fi
    
    # Check 2: HTTP endpoint
    if curl -sf http://localhost:8080/health > /dev/null; then
        ((checks_passed++))
    else
        echo "FAIL: Health endpoint not responding" >&2
        ((checks_failed++))
    fi
    
    # Check 3: Database connection
    if pg_isready -q; then
        ((checks_passed++))
    else
        echo "FAIL: Database not ready" >&2
        ((checks_failed++))
    fi
    
    echo "Health: $checks_passed passed, $checks_failed failed"
    return $checks_failed
}

health_check
exit $?
```

---

### BASH-440 — Circuit Breaker

```bash copy
#!/bin/bash

circuit_state="closed"
failure_count=0
failure_threshold=3
last_attempt=0
cooldown_period=60

attempt_operation() {
    local now=$(date +%s)
    
    case $circuit_state in
        closed)
            if operation; then
                failure_count=0
                return 0
            else
                ((failure_count++))
                
                if ((failure_count >= failure_threshold)); then
                    circuit_state="open"
                    last_attempt=$now
                    echo "Circuit breaker OPEN"
                fi
                return 1
            fi
            ;;
        open)
            if ((now - last_attempt >= cooldown_period)); then
                circuit_state="half-open"
                echo "Circuit breaker HALF-OPEN"
                attempt_operation
            else
                echo "Circuit breaker OPEN - rejecting"
                return 1
            fi
            ;;
        half-open)
            if operation; then
                circuit_state="closed"
                failure_count=0
                echo "Circuit breaker CLOSED"
                return 0
            else
                circuit_state="open"
                last_attempt=$now
                echo "Circuit breaker OPEN"
                return 1
            fi
            ;;
    esac
}
```

---

### BASH-441 — Rate Limiting

```bash copy
#!/bin/bash

rate_limit() {
    local max_requests=$1
    local time_window=$2
    local state_file="/tmp/rate_limit_$$"
    
    # Clean old state
    if [ -f "$state_file" ]; then
        local age=$(($(date +%s) - $(stat -c%Y "$state_file")))
        if ((age >= time_window)); then
            rm "$state_file"
        fi
    fi
    
    # Check current count
    local count=0
    [ -f "$state_file" ] && count=$(cat "$state_file")
    
    if ((count >= max_requests)); then
        echo "Rate limit exceeded" >&2
        return 1
    fi
    
    # Increment counter
    echo $((count + 1)) > "$state_file"
    return 0
}

# Usage: 10 requests per 60 seconds
if rate_limit 10 60; then
    # Process request
    echo "Processing..."
else
    echo "Too many requests" >&2
    exit 429
fi
```

---

### BASH-442 — Metrics Collection

```bash copy
#!/bin/bash

metrics_file="/var/metrics/app.prom"

# Record metric
record_metric() {
    local name=$1
    local value=$2
    local labels=$3
    
    echo "${name}{${labels}} ${value} $(date +%s)000" >> "$metrics_file"
}

# Counter
counter_inc() {
    local name=$1
    local labels=${2:-}
    record_metric "${name}_total" 1 "$labels"
}

# Gauge
gauge_set() {
    local name=$1
    local value=$2
    local labels=${3:-}
    record_metric "$name" "$value" "$labels"
}

# Histogram/timing
time_operation() {
    local name=$1
    shift
    
    local start=$(date +%s%N)
    "$@"
    local status=$?
    local duration=$(( ($(date +%s%N) - start) / 1000000 ))
    
    record_metric "${name}_duration_ms" "$duration" "status=\"$status\""
    return $status
}

# Usage
counter_inc "requests" "method=\"GET\""
gauge_set "active_connections" 42
time_operation "database_query" psql -c "SELECT 1"
```

</div>

</details>

---

<details>
<summary><strong>11. Code Generation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-443 — Generate Scripts

```bash copy
#!/bin/bash

generate_deployment_script() {
    local env=$1
    local output="deploy_${env}.sh"
    
    cat > "$output" << EOF
#!/bin/bash
# Generated deployment script for $env
# Generated at: $(date)

set -euo pipefail

ENVIRONMENT="$env"
REGISTRY="registry.example.com"

deploy() {
    echo "Deploying to \$ENVIRONMENT..."
    # Deployment logic here
}

deploy
EOF
    
    chmod +x "$output"
    echo "Generated: $output"
}

# Generate for each environment
for env in dev staging production; do
    generate_deployment_script "$env"
done
```

---

### BASH-444 — Template Engine

```bash copy
#!/bin/bash

# Simple template engine
render_template() {
    local template=$1
    
    # Replace {{variable}} with actual values
    local output="$template"
    
    # Find all variables
    while [[ $output =~ \{\{([^}]+)\}\} ]]; do
        local var="${BASH_REMATCH[1]}"
        local value="${!var:-}"
        output="${output//\{\{$var\}\}/$value}"
    done
    
    echo "$output"
}

# Usage
export APP_NAME="MyApp"
export APP_VERSION="1.0.0"

template='
Application: {{APP_NAME}}
Version: {{APP_VERSION}}
Environment: {{ENVIRONMENT}}
'

rendered=$(render_template "$template")
echo "$rendered"
```

---

### BASH-445 — Configuration Generator

```bash copy
#!/bin/bash

generate_nginx_config() {
    local domain=$1
    local port=$2
    local config_file="/etc/nginx/sites-available/${domain}"
    
    cat > "$config_file" << EOF
server {
    listen 80;
    server_name $domain;
    
    location / {
        proxy_pass http://localhost:$port;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
    }
}
EOF
    
    echo "Generated: $config_file"
}

# Generate from list
while IFS=, read -r domain port; do
    generate_nginx_config "$domain" "$port"
done << EOF
example.com,8080
api.example.com,8081
admin.example.com,8082
EOF
```

</div>

</details>

---

<details>
<summary><strong>12. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Production-Ready CLI Tool

```bash copy
#!/bin/bash
#
# cloudctl - Cloud resource management tool
#

set -euo pipefail

# Constants
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly VERSION="1.0.0"
readonly CONFIG_DIR="$HOME/.cloudctl"
readonly LOG_FILE="$CONFIG_DIR/cloudctl.log"

# Configuration
VERBOSE=0
DRY_RUN=0
PROFILE="default"

# Initialize
mkdir -p "$CONFIG_DIR"

# Logging
log() {
    local level=$1
    shift
    local message="$@"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" | tee -a "$LOG_FILE"
}

log_debug() { [ $VERBOSE -eq 1 ] && log "DEBUG" "$@"; }
log_info() { log "INFO" "$@"; }
log_error() { log "ERROR" "$@" >&2; }

# Help
show_help() {
    cat << EOF
cloudctl v$VERSION - Cloud resource management

USAGE:
    cloudctl [OPTIONS] <COMMAND> [ARGS]

GLOBAL OPTIONS:
    -v, --verbose          Verbose output
    -d, --dry-run          Dry run mode
    -p, --profile NAME     Profile to use (default: $PROFILE)
    -h, --help             Show this help

COMMANDS:
    list                   List resources
    create <name>          Create resource
    delete <name>          Delete resource
    status <name>          Check status
    config                 Manage configuration

EXAMPLES:
    cloudctl list
    cloudctl --verbose create myserver
    cloudctl --profile prod status myserver

For help on specific command:
    cloudctl <command> --help
EOF
}

# Parse global options
parse_global_opts() {
    while [ $# -gt 0 ]; do
        case $1 in
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -p|--profile)
                PROFILE="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "Unknown global option: $1"
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
}

# Load profile
load_profile() {
    local profile_file="$CONFIG_DIR/profiles/${PROFILE}.conf"
    
    if [ ! -f "$profile_file" ]; then
        log_error "Profile not found: $PROFILE"
        exit 1
    fi
    
    log_debug "Loading profile: $PROFILE"
    set -a
    source "$profile_file"
    set +a
}

# Command: list
cmd_list() {
    log_info "Listing resources (profile: $PROFILE)"
    
    if [ $DRY_RUN -eq 1 ]; then
        echo "[DRY RUN] Would list resources"
        return 0
    fi
    
    # Implementation
    echo "Resource 1"
    echo "Resource 2"
}

# Command: create
cmd_create() {
    local name=$1
    
    if [ -z "$name" ]; then
        log_error "Resource name required"
        echo "Usage: cloudctl create <name>" >&2
        return 1
    fi
    
    log_info "Creating resource: $name (profile: $PROFILE)"
    
    if [ $DRY_RUN -eq 1 ]; then
        echo "[DRY RUN] Would create: $name"
        return 0
    fi
    
    # Implementation
    echo "Created: $name"
}

# Command: delete
cmd_delete() {
    local name=$1
    
    if [ -z "$name" ]; then
        log_error "Resource name required"
        return 1
    fi
    
    # Confirmation for production
    if [ "$PROFILE" = "production" ]; then
        read -p "Delete $name in PRODUCTION? (type 'yes'): " confirm
        if [ "$confirm" != "yes" ]; then
            log_info "Cancelled"
            return 0
        fi
    fi
    
    log_info "Deleting resource: $name"
    
    if [ $DRY_RUN -eq 1 ]; then
        echo "[DRY RUN] Would delete: $name"
        return 0
    fi
    
    # Implementation
    echo "Deleted: $name"
}

# Command: status
cmd_status() {
    local name=$1
    
    if [ -z "$name" ]; then
        log_error "Resource name required"
        return 1
    fi
    
    log_info "Checking status: $name"
    
    # Implementation
    echo "Status: Running"
}

# Command: config
cmd_config() {
    local subcommand=${1:-}
    
    case $subcommand in
        init)
            initialize_config
            ;;
        list)
            list_profiles
            ;;
        edit)
            edit_profile "${2:-$PROFILE}"
            ;;
        *)
            cat << EOF
Config management:
    cloudctl config init          Initialize configuration
    cloudctl config list          List profiles
    cloudctl config edit [NAME]   Edit profile
EOF
            ;;
    esac
}

# Main dispatcher
main() {
    # Parse global options first
    parse_global_opts "$@"
    shift $((OPTIND - 1)) 2>/dev/null || true
    
    # Get command
    local command=${1:-}
    
    if [ -z "$command" ]; then
        log_error "No command specified"
        show_help >&2
        exit 1
    fi
    
    shift
    
    # Load profile (except for config commands)
    if [ "$command" != "config" ]; then
        load_profile
    fi
    
    # Dispatch to command
    case $command in
        list)
            cmd_list "$@"
            ;;
        create)
            cmd_create "$@"
            ;;
        delete)
            cmd_delete "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        *)
            log_error "Unknown command: $command"
            show_help >&2
            exit 1
            ;;
    esac
}

main "$@"
```

---

### Scenario 2: Job Scheduler

```bash copy
#!/bin/bash
#
# scheduler.sh - Simple job scheduler with concurrency control
#

set -euo pipefail

readonly STATE_DIR="/var/lib/scheduler"
readonly LOG_DIR="/var/log/scheduler"
readonly MAX_CONCURRENT=4

mkdir -p "$STATE_DIR" "$LOG_DIR"

# Job definition
declare -A jobs

register_job() {
    local name=$1
    local schedule=$2
    local command=$3
    
    jobs[$name]="$schedule|$command"
}

# Check if job should run
should_run() {
    local schedule=$1
    local last_run=${2:-0}
    local now=$(date +%s)
    
    # Parse schedule (simple: every N minutes)
    local interval=$((schedule * 60))
    
    if ((now - last_run >= interval)); then
        return 0
    else
        return 1
    fi
}

# Run job
run_job() {
    local name=$1
    local command=$2
    
    local log_file="$LOG_DIR/${name}_$(date +%Y%m%d_%H%M%S).log"
    local state_file="$STATE_DIR/${name}.state"
    
    echo "Starting: $name" | tee -a "$log_file"
    
    local start=$(date +%s)
    
    if eval "$command" >> "$log_file" 2>&1; then
        local end=$(date +%s)
        local duration=$((end - start))
        
        echo "Success: $name (${duration}s)" | tee -a "$log_file"
        echo "$end|success|$duration" > "$state_file"
    else
        local end=$(date +%s)
        local duration=$((end - start))
        
        echo "Failed: $name (${duration}s)" | tee -a "$log_file" >&2
        echo "$end|failed|$duration" > "$state_file"
    fi
}

# Job runner with concurrency control
run_jobs() {
    local running=0
    
    for job_name in "${!jobs[@]}"; do
        local job_info="${jobs[$job_name]}"
        local schedule="${job_info%%|*}"
        local command="${job_info#*|}"
        
        # Get last run time
        local state_file="$STATE_DIR/${job_name}.state"
        local last_run=0
        
        if [ -f "$state_file" ]; then
            last_run=$(cut -d'|' -f1 "$state_file")
        fi
        
        # Check if should run
        if should_run "$schedule" "$last_run"; then
            # Wait if too many concurrent jobs
            while ((running >= MAX_CONCURRENT)); do
                wait -n
                ((running--))
            done
            
            # Run job in background
            (run_job "$job_name" "$command") &
            ((running++))
        fi
    done
    
    # Wait for remaining jobs
    wait
}

# Register jobs
register_job "backup" 60 "tar -czf /backup/data.tar.gz /data"
register_job "cleanup" 1440 "find /tmp -mtime +7 -delete"
register_job "report" 30 "/usr/local/bin/generate-report"

# Main loop
while true; do
    echo "Checking jobs: $(date)"
    run_jobs
    sleep 60
done
```

</div>

</details>

---

<details>
<summary><strong>13. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Parse short options
while getopts "vo:f" opt; do
    case $opt in
        v) verbose=1 ;;
        o) output="$OPTARG" ;;
        f) force=1 ;;
    esac
done
```

```bash copy
# Parse long options
while [ $# -gt 0 ]; do
    case $1 in
        --verbose|-v) verbose=1; shift ;;
        --output|-o) output="$2"; shift 2 ;;
        --) shift; break ;;
        *) break ;;
    esac
done
```

```bash copy
# Subcommand pattern
case $1 in
    deploy) cmd_deploy "${@:2}" ;;
    status) cmd_status "${@:2}" ;;
esac
```

```bash copy
# Load environment file
set -a
source .env
set +a
```

```bash copy
# Named pipes
mkfifo mypipe
command > mypipe &
command2 < mypipe
```

```bash copy
# Worker pool
for i in {1..4}; do
    worker $i &
done
wait
```

```bash copy
# Semaphore
acquire_semaphore
trap release_semaphore EXIT
```

```bash copy
# Rate limiting
if rate_limit 10 60; then
    process_request
fi
```

```bash copy
# Health check
health_check || exit 1
```

```bash copy
# Circuit breaker
if circuit_open; then
    echo "Service unavailable"
    exit 503
fi
```

</div>

</details>

---

<details>
<summary><strong>14. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Use `getopts` for short options, manual parsing for long options
- Support subcommands for complex tools
- Load configuration from environment, files, and arguments
- Implement proper signal handling for graceful shutdown
- Use worker pools for controlled parallelism
- Validate and sanitize all user input

---

**Argument Parsing:**

| Method | Use Case |
|--------|----------|
| `getopts` | Short options (-v, -o file) |
| Manual `case` | Long options (--verbose, --output) |
| Subcommands | Multi-command tools (git-style) |

---

**Configuration Layers:**

```
Priority (high to low):
1. Command-line arguments
2. Environment variables
3. Config files
4. Defaults
```

---

**Common Patterns:**

```bash copy
# Professional CLI tool structure
#!/bin/bash
set -euo pipefail

# Constants
readonly VERSION="1.0.0"
readonly CONFIG_DIR="$HOME/.tool"

# Logging
log_info() { echo "[INFO] $@"; }
log_error() { echo "[ERROR] $@" >&2; }

# Help
show_help() { ... }

# Parse options
parse_opts() { ... }

# Commands
cmd_deploy() { ... }
cmd_status() { ... }

# Main
main() {
    parse_opts "$@"
    case $command in
        deploy) cmd_deploy ;;
        status) cmd_status ;;
    esac
}

main "$@"
```

---

**Performance Optimization:**

| Slow | Fast |
|------|------|
| Pipe into while | While with redirect |
| Multiple external commands | Single batch operation |
| `basename`/`dirname` | Parameter expansion |
| Repeated concatenation | Array then join |
| External command in loop | Built-in operation |

---

**Security Checklist:**

- [ ] Validate all user input
- [ ] Quote all variables
- [ ] Use arrays for file lists
- [ ] Never use `eval` with user input
- [ ] Check file permissions
- [ ] Use `mktemp` for temporary files
- [ ] Clear secrets on exit
- [ ] Run with minimal privileges

---

**Production Patterns:**

```bash copy
# Health check
health_check() {
    checks_passed=0
    # Check process
    # Check endpoints
    # Check dependencies
    return $checks_failed
}

# Circuit breaker
if [ $failures -gt $threshold ]; then
    circuit_open=true
fi

# Rate limiting
if ! rate_limit $max_requests $window; then
    exit 429
fi

# Metrics
record_metric "requests_total" 1
time_operation "db_query" execute_query
```

---

**Concurrency Patterns:**

```bash copy
# Worker pool
for i in {1..4}; do
    worker &
done
wait

# Semaphore
while [ $(jobs -r | wc -l) -ge $max ]; do
    wait -n
done

# Message queue
send_message "queue" "task"
receive_message "queue"
```

---

**Best Practices:**

1. **Start with template**
   - Strict mode
   - Logging
   - Help text
   - Cleanup trap

2. **Parse arguments properly**
   - Support --help
   - Validate input
   - Clear error messages

3. **Load configuration**
   - Multiple layers
   - Validation
   - Sensible defaults

4. **Handle signals**
   - Graceful shutdown
   - Cleanup resources
   - Forward to children

5. **Optimize performance**
   - Avoid subshells
   - Batch operations
   - Use built-ins
   - Cache expensive operations

6. **Secure by default**
   - Validate input
   - Quote variables
   - Secure temp files
   - Minimal privileges

---

**What's Next:**
Now that you've mastered advanced techniques, the final file covers real production scripts and best practices — putting everything together into professional-grade automation tools.

</div>

</details>

---