# **04. Variables, Outputs & Locals**

You've been hardcoding values directly into your Terraform code — instance types, region names, CIDR blocks.
That works for learning, but it doesn't scale.

What happens when you need to deploy the same infrastructure across dev, staging, and production with different configurations?
Or when you want to reuse the same code across multiple projects?
Or when you need to pass outputs from one resource to another in a clean, organized way?

**That's where variables, outputs, and locals come in.**

They turn static code into flexible, reusable configurations.
Variables let you inject values from outside. Outputs expose information for other systems. Locals help you calculate and organize values internally.

---

## Table of Contents
1. [Input Variables](#input-variables)
2. [Variable Types](#variable-types)
3. [Variable Defaults](#variable-defaults)
4. [Variable Validation](#variable-validation)
5. [Variable Files (.tfvars)](#variable-files-tfvars)
6. [Sensitive Variables](#sensitive-variables)
7. [Outputs](#outputs)
8. [Locals](#locals)
9. [Variable Precedence](#variable-precedence)
10. [Environment-Specific Variables](#environment-specific-variables)

---

<details>
<summary><strong>1. Input Variables</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Input variables are parameters you can pass into your Terraform configuration.
They make your code flexible and reusable.

**Without variables:**
```hcl
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  
  tags = {
    Environment = "production"
  }
}
```

Every time you change environments, you edit the code.

**With variables:**
```hcl
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "environment" {
  description = "Environment name"
  type        = string
}

resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = var.instance_type
  
  tags = {
    Environment = var.environment
  }
}
```

Now you can deploy dev, staging, and production with different values — same code.

**Variable Declaration Syntax:**

```hcl
variable "NAME" {
  description = "Human-readable description"
  type        = TYPE
  default     = VALUE
  sensitive   = BOOLEAN
  validation  = {...}
}
```

**Referencing Variables:**

Use `var.NAME` anywhere in your code:
```hcl
instance_type = var.instance_type
cidr_block    = var.vpc_cidr
region        = var.aws_region
```

**Setting Variable Values:**

**Method 1: Command Line**
```bash
terraform apply -var="environment=production" -var="instance_type=t3.large"
```

**Method 2: Environment Variables**
```bash
export TF_VAR_environment="production"
export TF_VAR_instance_type="t3.large"
terraform apply
```

**Method 3: Variable Files (most common)**
```bash
terraform apply -var-file="production.tfvars"
```

**Method 4: Interactive Prompt**
If no value is provided and no default exists, Terraform prompts:
```
var.environment
  Environment name

  Enter a value: production
```

**Method 5: Default Value**
```hcl
variable "instance_type" {
  default = "t3.micro"
}
```

If you don't provide a value, Terraform uses the default.

</div>

</details>

---

<details>
<summary><strong>2. Variable Types</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Terraform supports several variable types to match different data structures.

**Primitive Types:**

**string** — Text
```hcl
variable "region" {
  type    = string
  default = "us-east-1"
}
```

**number** — Integers and decimals
```hcl
variable "instance_count" {
  type    = number
  default = 3
}
```

**bool** — True or false
```hcl
variable "enable_monitoring" {
  type    = bool
  default = true
}
```

**Collection Types:**

**list** — Ordered collection of values (same type)
```hcl
variable "availability_zones" {
  type    = list(string)
  default = ["us-east-1a", "us-east-1b", "us-east-1c"]
}

# Usage
availability_zone = var.availability_zones[0]
```

**map** — Key-value pairs (same type for values)
```hcl
variable "instance_types" {
  type = map(string)
  default = {
    dev     = "t3.micro"
    staging = "t3.small"
    prod    = "t3.large"
  }
}

# Usage
instance_type = var.instance_types["prod"]
```

**set** — Unordered collection of unique values
```hcl
variable "allowed_cidrs" {
  type    = set(string)
  default = ["10.0.0.0/8", "172.16.0.0/12"]
}
```

**Structural Types:**

**object** — Collection with specific attribute types
```hcl
variable "database_config" {
  type = object({
    engine         = string
    engine_version = string
    instance_class = string
    storage_gb     = number
  })
  
  default = {
    engine         = "postgres"
    engine_version = "14.7"
    instance_class = "db.t3.micro"
    storage_gb     = 20
  }
}

# Usage
engine = var.database_config.engine
```

**tuple** — Fixed-length collection with specific types
```hcl
variable "network_config" {
  type    = tuple([string, number, bool])
  default = ["10.0.0.0/16", 3, true]
}
```

**any** — Any type (use sparingly)
```hcl
variable "tags" {
  type    = any
  default = {}
}
```

**Complex Example:**

```hcl
variable "vpc_config" {
  type = object({
    cidr_block = string
    subnets = list(object({
      cidr_block        = string
      availability_zone = string
      public            = bool
    }))
    enable_dns = bool
  })
  
  default = {
    cidr_block = "10.0.0.0/16"
    subnets = [
      {
        cidr_block        = "10.0.1.0/24"
        availability_zone = "us-east-1a"
        public            = true
      },
      {
        cidr_block        = "10.0.2.0/24"
        availability_zone = "us-east-1b"
        public            = false
      }
    ]
    enable_dns = true
  }
}
```

**Type Conversion:**

Terraform automatically converts compatible types:
```hcl
variable "port" {
  type = number
}

# You provide: "8080" (string)
# Terraform converts: 8080 (number)
```

</div>

</details>

---

<details>
<summary><strong>3. Variable Defaults</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Defaults make variables optional. If no value is provided, Terraform uses the default.

**With Default:**
```hcl
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}
```

You can run `terraform apply` without providing a value.

**Without Default:**
```hcl
variable "environment" {
  description = "Environment name"
  type        = string
  # No default - must be provided
}
```

Terraform will prompt or error if no value is given.

**When to Use Defaults:**

✅ **Use defaults for:**
- Common values that rarely change
- Safe fallback values
- Development/testing configurations

❌ **Don't use defaults for:**
- Sensitive values (passwords, API keys)
- Environment-specific values (prod vs dev)
- Values that must be consciously chosen

**Example Strategy:**

```hcl
# Safe to default
variable "instance_type" {
  type    = string
  default = "t3.micro"
}

# No default - must be explicit
variable "environment" {
  type = string
}

# No default - sensitive
variable "db_password" {
  type      = string
  sensitive = true
}

# Safe default for development
variable "enable_monitoring" {
  type    = bool
  default = false
}
```

**Nullable Variables:**

```hcl
variable "backup_retention_days" {
  type     = number
  default  = null
  nullable = true
}
```

`null` means "not set" — different from a default value.

</div>

</details>

---

<details>
<summary><strong>4. Variable Validation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

You can add validation rules to catch errors early.

**Basic Validation:**

```hcl
variable "environment" {
  type = string
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}
```

If someone tries `terraform apply -var="environment=test"`, they get:
```
Error: Invalid value for variable

Environment must be dev, staging, or prod.
```

**Number Range Validation:**

```hcl
variable "instance_count" {
  type = number
  
  validation {
    condition     = var.instance_count >= 1 && var.instance_count <= 10
    error_message = "Instance count must be between 1 and 10."
  }
}
```

**String Pattern Validation:**

```hcl
variable "bucket_name" {
  type = string
  
  validation {
    condition     = can(regex("^[a-z0-9-]+$", var.bucket_name))
    error_message = "Bucket name must contain only lowercase letters, numbers, and hyphens."
  }
}
```

**Multiple Validations:**

```hcl
variable "cidr_block" {
  type = string
  
  validation {
    condition     = can(cidrhost(var.cidr_block, 0))
    error_message = "Must be a valid CIDR block."
  }
  
  validation {
    condition     = split("/", var.cidr_block)[1] <= 24
    error_message = "CIDR block must be /24 or larger."
  }
}
```

**List Validation:**

```hcl
variable "allowed_regions" {
  type = list(string)
  
  validation {
    condition = alltrue([
      for region in var.allowed_regions :
      contains(["us-east-1", "us-west-2", "eu-west-1"], region)
    ])
    error_message = "All regions must be in allowed list."
  }
}
```

**Validation Functions:**

- `can()` — Tests if expression succeeds
- `contains()` — Checks if value is in list
- `length()` — Returns length of string/list
- `regex()` — Pattern matching
- `alltrue()` — All conditions true
- `anytrue()` — Any condition true

**Complex Example:**

```hcl
variable "database_config" {
  type = object({
    engine         = string
    instance_class = string
    storage_gb     = number
  })
  
  validation {
    condition = contains(
      ["postgres", "mysql", "mariadb"],
      var.database_config.engine
    )
    error_message = "Engine must be postgres, mysql, or mariadb."
  }
  
  validation {
    condition     = var.database_config.storage_gb >= 20
    error_message = "Storage must be at least 20 GB."
  }
  
  validation {
    condition = can(
      regex("^db\\.(t3|t4g|m5|m6g)\\.", var.database_config.instance_class)
    )
    error_message = "Instance class must be t3, t4g, m5, or m6g family."
  }
}
```

Validation runs during `terraform plan`, catching errors before infrastructure changes.

</div>

</details>

---

<details>
<summary><strong>5. Variable Files (.tfvars)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Variable files let you manage multiple configurations cleanly.

**File Structure:**

```
project/
├── main.tf
├── variables.tf
├── dev.tfvars
├── staging.tfvars
└── production.tfvars
```

**variables.tf** — Variable declarations
```hcl
variable "environment" {
  type = string
}

variable "instance_type" {
  type = string
}

variable "instance_count" {
  type = number
}
```

**dev.tfvars** — Development values
```hcl
environment    = "dev"
instance_type  = "t3.micro"
instance_count = 1
```

**staging.tfvars** — Staging values
```hcl
environment    = "staging"
instance_type  = "t3.small"
instance_count = 2
```

**production.tfvars** — Production values
```hcl
environment    = "prod"
instance_type  = "t3.large"
instance_count = 5
```

**Using Variable Files:**

```bash
# Deploy to dev
terraform apply -var-file="dev.tfvars"

# Deploy to staging
terraform apply -var-file="staging.tfvars"

# Deploy to production
terraform apply -var-file="production.tfvars"
```

**Auto-Loaded Files:**

Terraform automatically loads:
- `terraform.tfvars`
- `terraform.tfvars.json`
- `*.auto.tfvars`
- `*.auto.tfvars.json`

**Example:**

```
project/
├── main.tf
├── variables.tf
└── terraform.tfvars  ← Automatically loaded
```

You don't need `-var-file` for `terraform.tfvars`:
```bash
terraform apply  # Automatically uses terraform.tfvars
```

**JSON Format:**

```json
{
  "environment": "prod",
  "instance_type": "t3.large",
  "instance_count": 5
}
```

**Best Practices:**

1. **Never commit sensitive values** — Use `.gitignore`:
```
*.tfvars
!example.tfvars
```

2. **Provide example file:**
```hcl
# example.tfvars
environment    = "dev"
instance_type  = "t3.micro"
instance_count = 1
db_password    = "CHANGE_ME"
```

3. **Organize by environment:**
```
environments/
├── dev/
│   └── terraform.tfvars
├── staging/
│   └── terraform.tfvars
└── prod/
    └── terraform.tfvars
```

4. **Document required variables:**
```hcl
# variables.tf
variable "environment" {
  description = "Environment name (dev/staging/prod)"
  type        = string
}
```

</div>

</details>

---

<details>
<summary><strong>6. Sensitive Variables</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Sensitive variables hide values in Terraform output and logs.

**Declaring Sensitive Variables:**

```hcl
variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}
```

**Without sensitive flag:**
```bash
terraform apply
...
db_password = "MySecretPassword123"
```

**With sensitive flag:**
```bash
terraform apply
...
db_password = <sensitive>
```

**Setting Sensitive Values:**

**Method 1: Environment Variables (Recommended)**
```bash
export TF_VAR_db_password="MySecretPassword123"
terraform apply
```

**Method 2: Variable File (Not Committed)**
```hcl
# secrets.tfvars (in .gitignore)
db_password = "MySecretPassword123"
```

```bash
terraform apply -var-file="secrets.tfvars"
```

**Method 3: External Secrets Manager**
```hcl
data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = "prod/database/password"
}

resource "aws_db_instance" "main" {
  password = data.aws_secretsmanager_secret_version.db_password.secret_string
}
```

**Sensitive in State:**

⚠️ **Important:** `sensitive = true` only hides output. The value is still stored in `terraform.tfstate` as plain text.

**To protect state:**
- Use remote state with encryption (S3 + KMS)
- Restrict state file access (covered in File 08)
- Never commit state to Git

**Example: Complete Sensitive Setup**

```hcl
# variables.tf
variable "db_username" {
  description = "Database username"
  type        = string
  sensitive   = true
}

variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}

# main.tf
resource "aws_db_instance" "main" {
  allocated_storage = 20
  engine            = "postgres"
  instance_class    = "db.t3.micro"
  
  username = var.db_username
  password = var.db_password
}

output "db_endpoint" {
  value     = aws_db_instance.main.endpoint
  sensitive = false  # Endpoint is not sensitive
}

output "db_password" {
  value     = var.db_password
  sensitive = true  # Mark output as sensitive too
}
```

**Best Practices:**

1. **Mark all secrets as sensitive**
2. **Use environment variables or secret managers**
3. **Never commit secrets to Git**
4. **Encrypt remote state**
5. **Rotate secrets regularly**

</div>

</details>

---

<details>
<summary><strong>7. Outputs</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Outputs expose values after Terraform creates resources.

**Why Use Outputs:**
- Share information between Terraform configurations
- Display important values after apply
- Pass data to CI/CD pipelines
- Reference values in other tools

**Output Syntax:**

```hcl
output "NAME" {
  description = "Human-readable description"
  value       = EXPRESSION
  sensitive   = BOOLEAN
}
```

**Basic Examples:**

```hcl
output "instance_id" {
  description = "ID of the EC2 instance"
  value       = aws_instance.web.id
}

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.web.public_ip
}

output "bucket_name" {
  description = "Name of the S3 bucket"
  value       = aws_s3_bucket.data.bucket
}
```

**After terraform apply:**
```
Outputs:

instance_id        = "i-0abc123def456"
instance_public_ip = "54.123.45.67"
bucket_name        = "my-data-bucket"
```

**View Outputs Later:**

```bash
terraform output
```

**Get Specific Output:**

```bash
terraform output instance_public_ip
# 54.123.45.67
```

**Output JSON Format:**

```bash
terraform output -json
```

```json
{
  "instance_id": {
    "sensitive": false,
    "type": "string",
    "value": "i-0abc123def456"
  }
}
```

**Complex Outputs:**

**List:**
```hcl
output "subnet_ids" {
  value = aws_subnet.public[*].id
}
```

**Map:**
```hcl
output "instance_ips" {
  value = {
    web = aws_instance.web.public_ip
    db  = aws_instance.db.private_ip
  }
}
```

**Object:**
```hcl
output "vpc_info" {
  value = {
    id         = aws_vpc.main.id
    cidr_block = aws_vpc.main.cidr_block
    subnets    = aws_subnet.public[*].id
  }
}
```

**Sensitive Outputs:**

```hcl
output "db_password" {
  value     = aws_db_instance.main.password
  sensitive = true
}
```

Displays as:
```
db_password = <sensitive>
```

Access with:
```bash
terraform output -raw db_password
# MySecretPassword123
```

**Using Outputs in Other Configurations:**

**Configuration A (network/):**
```hcl
output "vpc_id" {
  value = aws_vpc.main.id
}

output "subnet_ids" {
  value = aws_subnet.public[*].id
}
```

**Configuration B (application/):**
```hcl
data "terraform_remote_state" "network" {
  backend = "s3"
  config = {
    bucket = "my-terraform-state"
    key    = "network/terraform.tfstate"
    region = "us-east-1"
  }
}

resource "aws_instance" "app" {
  subnet_id = data.terraform_remote_state.network.outputs.subnet_ids[0]
  vpc_security_group_ids = [aws_security_group.app.id]
}
```

**Practical Example:**

```hcl
# main.tf
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  count             = 3
  vpc_id            = aws_vpc.main.id
  cidr_block        = "10.0.${count.index}.0/24"
  availability_zone = data.aws_availability_zones.available.names[count.index]
}

resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  subnet_id     = aws_subnet.public[0].id
}

# outputs.tf
output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}

output "subnet_ids" {
  description = "IDs of all subnets"
  value       = aws_subnet.public[*].id
}

output "web_server_url" {
  description = "URL to access the web server"
  value       = "http://${aws_instance.web.public_ip}"
}

output "deployment_info" {
  description = "Complete deployment information"
  value = {
    vpc_id      = aws_vpc.main.id
    subnet_ids  = aws_subnet.public[*].id
    instance_id = aws_instance.web.id
    public_ip   = aws_instance.web.public_ip
  }
}
```

</div>

</details>

---

<details>
<summary><strong>8. Locals</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Locals (local values) are internal variables for calculations and organization.
Unlike input variables, they can't be set from outside — they're computed internally.

**Why Use Locals:**
- Avoid repeating complex expressions
- Calculate derived values
- Organize and name intermediate values
- Make code more readable

**Locals Syntax:**

```hcl
locals {
  name1 = expression1
  name2 = expression2
}
```

**Basic Example:**

```hcl
locals {
  project_name = "myapp"
  environment  = "prod"
  
  # Computed value
  name_prefix = "${local.project_name}-${local.environment}"
}

resource "aws_s3_bucket" "data" {
  bucket = "${local.name_prefix}-data"
}

resource "aws_s3_bucket" "logs" {
  bucket = "${local.name_prefix}-logs"
}
```

**Common Patterns:**

**Default Tags:**
```hcl
locals {
  common_tags = {
    Project     = "MyApp"
    Environment = var.environment
    ManagedBy   = "Terraform"
    Owner       = "DevOps"
  }
}

resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
  
  tags = merge(
    local.common_tags,
    {
      Name = "WebServer"
      Role = "Frontend"
    }
  )
}
```

**Conditional Logic:**
```hcl
locals {
  is_production = var.environment == "prod"
  instance_type = local.is_production ? "t3.large" : "t3.micro"
  instance_count = local.is_production ? 5 : 1
}

resource "aws_instance" "app" {
  count         = local.instance_count
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = local.instance_type
}
```

**Calculations:**
```hcl
locals {
  # Calculate subnet CIDRs
  vpc_cidr = "10.0.0.0/16"
  subnet_cidrs = [
    cidrsubnet(local.vpc_cidr, 8, 0),  # 10.0.0.0/24
    cidrsubnet(local.vpc_cidr, 8, 1),  # 10.0.1.0/24
    cidrsubnet(local.vpc_cidr, 8, 2),  # 10.0.2.0/24
  ]
}

resource "aws_subnet" "public" {
  count      = 3
  vpc_id     = aws_vpc.main.id
  cidr_block = local.subnet_cidrs[count.index]
}
```

**Complex Data Structures:**
```hcl
locals {
  environments = {
    dev = {
      instance_type = "t3.micro"
      instance_count = 1
      enable_monitoring = false
    }
    staging = {
      instance_type = "t3.small"
      instance_count = 2
      enable_monitoring = true
    }
    prod = {
      instance_type = "t3.large"
      instance_count = 5
      enable_monitoring = true
    }
  }
  
  # Select config based on environment variable
  config = local.environments[var.environment]
}

resource "aws_instance" "app" {
  count         = local.config.instance_count
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = local.config.instance_type
  monitoring    = local.config.enable_monitoring
}
```

**Locals vs Variables:**

| Aspect | Variables | Locals |
|--------|-----------|--------|
| **Set from** | Outside (CLI, .tfvars) | Inside (calculated) |
| **Can change** | Yes, at runtime | No, computed once |
| **Reference** | `var.name` | `local.name` |
| **Purpose** | Configuration input | Internal calculations |

**When to Use Each:**

**Use Variables:**
- Values that change per environment
- User-provided configuration
- Secrets from external sources

**Use Locals:**
- Derived values
- Repeated expressions
- Complex calculations
- Default tags
- Naming patterns

**Practical Example:**

```hcl
# variables.tf
variable "environment" {
  type = string
}

variable "project_name" {
  type = string
}

variable "aws_region" {
  type = string
}

# locals.tf
locals {
  # Naming convention
  name_prefix = "${var.project_name}-${var.environment}"
  
  # Common tags
  common_tags = {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "Terraform"
    Region      = var.aws_region
  }
  
  # Environment-specific configs
  is_production = var.environment == "prod"
  
  instance_config = {
    type  = local.is_production ? "t3.large" : "t3.micro"
    count = local.is_production ? 3 : 1
  }
  
  # Availability zones
  azs = slice(data.aws_availability_zones.available.names, 0, 3)
  
  # Subnet calculations
  vpc_cidr = "10.0.0.0/16"
  public_subnet_cidrs = [
    for i in range(3) : cidrsubnet(local.vpc_cidr, 8, i)
  ]
  private_subnet_cidrs = [
    for i in range(3) : cidrsubnet(local.vpc_cidr, 8, i + 10)
  ]
}

# main.tf
resource "aws_vpc" "main" {
  cidr_block = local.vpc_cidr
  
  tags = merge(
    local.common_tags,
    { Name = "${local.name_prefix}-vpc" }
  )
}

resource "aws_subnet" "public" {
  count             = 3
  vpc_id            = aws_vpc.main.id
  cidr_block        = local.public_subnet_cidrs[count.index]
  availability_zone = local.azs[count.index]
  
  tags = merge(
    local.common_tags,
    { Name = "${local.name_prefix}-public-${count.index + 1}" }
  )
}
```

</div>

</details>

---

<details>
<summary><strong>9. Variable Precedence</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When multiple sources provide values for the same variable, Terraform follows a precedence order.

**Precedence (Lowest to Highest):**

1. **Variable default value** (lowest)
2. **Environment variable (TF_VAR_name)**
3. **terraform.tfvars file**
4. **terraform.tfvars.json file**
5. ***.auto.tfvars files** (alphabetical order)
6. **-var-file** flag (order matters)
7. **-var** flag (highest)

**Example:**

```hcl
# variables.tf
variable "instance_type" {
  type    = string
  default = "t3.micro"  # Priority 1 (lowest)
}
```

```bash
# Priority 2
export TF_VAR_instance_type="t3.small"
```

```hcl
# terraform.tfvars - Priority 3
instance_type = "t3.medium"
```

```hcl
# prod.auto.tfvars - Priority 5
instance_type = "t3.large"
```

```bash
# Priority 6
terraform apply -var-file="override.tfvars"
```

```bash
# Priority 7 (highest - wins)
terraform apply -var="instance_type=t3.xlarge"
```

**Final value:** `t3.xlarge`

**Multiple -var-file:**

Last one wins:
```bash
terraform apply \
  -var-file="base.tfvars" \
  -var-file="prod.tfvars"  # This overrides base.tfvars
```

**Multiple -var:**

Last one wins:
```bash
terraform apply \
  -var="instance_type=t3.micro" \
  -var="instance_type=t3.large"  # This wins
```

**Practical Strategy:**

```
Priority Order (our setup):
1. variables.tf defaults    → Safe fallbacks
2. terraform.tfvars         → Shared defaults
3. environment.auto.tfvars  → Environment-specific
4. secrets.auto.tfvars      → Secrets (not in Git)
5. -var flag                → CI/CD overrides
```

**Example Setup:**

```hcl
# variables.tf - Defaults
variable "instance_type" {
  default = "t3.micro"
}

variable "environment" {
  # No default - must be set
}
```

```hcl
# terraform.tfvars - Shared
project_name = "myapp"
aws_region   = "us-east-1"
```

```hcl
# dev.auto.tfvars - Dev environment
environment    = "dev"
instance_type  = "t3.micro"
instance_count = 1
```

```hcl
# prod.auto.tfvars - Prod environment
environment    = "prod"
instance_type  = "t3.large"
instance_count = 5
```

```bash
# CI/CD can override
terraform apply -var="instance_count=3"
```

**Testing Precedence:**

```bash
# See what values Terraform will use
terraform console
> var.instance_type
"t3.large"
```

</div>

</details>

---

<details>
<summary><strong>10. Environment-Specific Variables</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Managing multiple environments (dev, staging, prod) requires organized variable strategies.

**Strategy 1: Separate .tfvars Files**

```
project/
├── main.tf
├── variables.tf
├── dev.tfvars
├── staging.tfvars
└── prod.tfvars
```

```bash
# Deploy to specific environment
terraform apply -var-file="dev.tfvars"
terraform apply -var-file="staging.tfvars"
terraform apply -var-file="prod.tfvars"
```

**Strategy 2: Auto-Loading Files**

```
project/
├── main.tf
├── variables.tf
├── terraform.tfvars       # Shared config
└── prod.auto.tfvars       # Auto-loaded
```

```bash
# Automatically uses prod.auto.tfvars
terraform apply
```

**Strategy 3: Directory-Based (Recommended)**

```
project/
├── modules/
│   └── infrastructure/
│       ├── main.tf
│       └── variables.tf
└── environments/
    ├── dev/
    │   ├── main.tf
    │   └── terraform.tfvars
    ├── staging/
    │   ├── main.tf
    │   └── terraform.tfvars
    └── prod/
        ├── main.tf
        └── terraform.tfvars
```

**environments/dev/main.tf:**
```hcl
module "infrastructure" {
  source = "../../modules/infrastructure"
  
  environment    = "dev"
  instance_type  = "t3.micro"
  instance_count = 1
}
```

**environments/prod/main.tf:**
```hcl
module "infrastructure" {
  source = "../../modules/infrastructure"
  
  environment    = "prod"
  instance_type  = "t3.large"
  instance_count = 5
}
```

```bash
# Deploy dev
cd environments/dev
terraform apply

# Deploy prod
cd environments/prod
terraform apply
```

Each environment has its own:
- State file
- Variable values
- Terraform workspace

**Strategy 4: Workspaces (For Simple Cases)**

```bash
# Create workspaces
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

# Switch environments
terraform workspace select dev
terraform apply

terraform workspace select prod
terraform apply
```

```hcl
# Use workspace name
locals {
  environment = terraform.workspace
  
  configs = {
    dev = {
      instance_type = "t3.micro"
      instance_count = 1
    }
    prod = {
      instance_type = "t3.large"
      instance_count = 5
    }
  }
  
  config = local.configs[local.environment]
}
```

**⚠️ Workspaces share the same code and backend — not recommended for prod/dev separation.**
**We'll cover this in File 07.**

**Best Practices:**

1. **Use directory structure for prod/staging/dev**
2. **Keep shared code in modules**
3. **Store environment-specific values in .tfvars**
4. **Never commit secrets** (use .gitignore)
5. **Document required variables**
6. **Validate variable values**

**Complete Example:**

```hcl
# modules/infrastructure/variables.tf
variable "environment" {
  type = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Must be dev, staging, or prod."
  }
}

variable "instance_type" {
  type = string
}

variable "instance_count" {
  type = number
  validation {
    condition     = var.instance_count >= 1 && var.instance_count <= 10
    error_message = "Instance count must be 1-10."
  }
}

# modules/infrastructure/locals.tf
locals {
  name_prefix = "myapp-${var.environment}"
  
  common_tags = {
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
}

# environments/prod/terraform.tfvars
environment    = "prod"
instance_type  = "t3.large"
instance_count = 5
aws_region     = "us-east-1"
```

</div>

</details>

---

**Your code is now flexible and reusable.**

Variables let you inject configuration from outside. Outputs expose information for other systems. Locals organize internal calculations.
You can deploy the same code across dev, staging, and production with different values — no code duplication, no manual edits.

Next, we'll add **loops and conditionals** to make your configurations even more dynamic — creating multiple resources with patterns, applying logic, and building truly scalable infrastructure.