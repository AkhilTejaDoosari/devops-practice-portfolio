# **07. Process Management & Job Control — Managing Running Processes**
> How to start, monitor, and control processes and background jobs.

---

## Table of Contents
- [1. Why Process Management Matters](#1-why-process-management-matters)
- [2. Understanding Processes](#2-understanding-processes)
- [3. Starting Processes](#3-starting-processes)
- [4. Background Jobs](#4-background-jobs)
- [5. Job Control](#5-job-control)
- [6. Process Information](#6-process-information)
- [7. Signals and Process Control](#7-signals-and-process-control)
- [8. Process Substitution](#8-process-substitution)
- [9. Subshells and Command Groups](#9-subshells-and-command-groups)
- [10. Process Monitoring](#10-process-monitoring)
- [11. Resource Management](#11-resource-management)
- [12. Real-World Scenarios](#12-real-world-scenarios)
- [13. Commands Reference](#13-commands-reference)
- [14. Quick Reference](#14-quick-reference)

---

<details>
<summary><strong>1. Why Process Management Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every script interacts with processes.

Running commands? Creating processes.
Background tasks? Managing jobs.
Monitoring services? Checking process status.
Cleanup operations? Sending signals.

Understanding process management means:
- you can run tasks in parallel
- you can monitor and control running processes
- you can handle signals gracefully
- you can build robust automation

This isn't about memorizing commands.
It's about understanding how processes work — so you can orchestrate complex operations reliably.

</div>

</details>

---

<details>
<summary><strong>2. Understanding Processes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-312 — What is a Process?

A process is a running instance of a program.

Every command you run creates a process:
- Has a unique Process ID (PID)
- Has a Parent Process ID (PPID)
- Has a state (running, sleeping, stopped, zombie)
- Consumes resources (CPU, memory)
- Can be controlled with signals

```bash copy
# Show current shell PID
echo "Current shell PID: $$"

# Show parent PID
echo "Parent PID: $PPID"

# Run command and get its PID
sleep 10 &
echo "Background job PID: $!"
```

---

### BASH-313 — Process Hierarchy

```bash copy
# View process tree
pstree -p $$

# Example hierarchy:
# bash(1234)───script.sh(5678)───sleep(5679)
```

**Key Concept:**
- Parent process spawns child processes
- When parent exits, children become orphans (adopted by init/systemd)
- When child exits, parent should reap it (or it becomes zombie)

---

### BASH-314 — Process States

```bash copy
# View process states
ps aux

# States:
# R = Running
# S = Sleeping (interruptible)
# D = Sleeping (uninterruptible)
# T = Stopped
# Z = Zombie
```

**Common States:**
- **Running (R)**: Currently executing or ready to run
- **Sleeping (S)**: Waiting for event (can be interrupted)
- **Stopped (T)**: Paused by signal (Ctrl+Z)
- **Zombie (Z)**: Finished but not reaped by parent

</div>

</details>

---

<details>
<summary><strong>3. Starting Processes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-315 — Foreground Processes

```bash copy
# Run in foreground (blocks until complete)
command

# Examples
ls -la
ping -c 5 google.com
sleep 10
```

Script waits for command to complete before continuing.

---

### BASH-316 — Background Processes

```bash copy
# Run in background
command &

# Get PID
command &
pid=$!
echo "Started process: $pid"

# Multiple background processes
sleep 10 &
sleep 20 &
sleep 30 &
```

---

### BASH-317 — Detached Processes

```bash copy
# Detach from terminal (nohup)
nohup command &

# Redirect output
nohup command > output.log 2>&1 &

# Completely detached (disown)
command &
disown
```

**nohup**: Process continues after terminal closes
**disown**: Remove job from shell's job table

---

### BASH-318 — Running with Different Priority

```bash copy
# Run with lower priority (nice)
nice -n 10 command

# Run with higher priority (requires root)
nice -n -10 command

# Change priority of running process
renice -n 5 -p PID
```

**Nice values:**
- Range: -20 (highest priority) to 19 (lowest)
- Default: 0
- Only root can set negative values

---

### BASH-319 — Start Process in Specific Directory

```bash copy
# Method 1: Change directory in subshell
(cd /path/to/dir && command)

# Method 2: pushd/popd
pushd /path/to/dir
command
popd

# Script stays in original directory
pwd
```

</div>

</details>

---

<details>
<summary><strong>4. Background Jobs</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-320 — Starting Background Jobs

```bash copy
# Start in background
sleep 30 &

# Start multiple jobs
for i in {1..5}; do
    sleep $((i * 10)) &
done

# Get PID of last background job
last_pid=$!
echo "Last job PID: $last_pid"
```

---

### BASH-321 — Listing Jobs

```bash copy
# List all jobs
jobs

# Output format:
# [1]   Running                 sleep 30 &
# [2]-  Running                 sleep 60 &
# [3]+  Running                 sleep 90 &

# List with PIDs
jobs -l

# List only running jobs
jobs -r

# List only stopped jobs
jobs -s
```

**Job Notation:**
- `+` = current job (most recent)
- `-` = previous job
- `[1]` = job number

---

### BASH-322 — Waiting for Jobs

```bash copy
# Wait for all background jobs
wait

# Wait for specific job
sleep 30 &
pid=$!
wait $pid
echo "Process $pid completed"

# Wait for any job to finish
sleep 10 &
sleep 20 &
wait -n
echo "One job finished"
```

---

### BASH-323 — Limiting Concurrent Jobs

```bash copy
#!/bin/bash
# Process files with max 4 concurrent jobs

max_jobs=4
job_count=0

for file in *.txt; do
    process_file "$file" &
    ((job_count++))
    
    # Wait when limit reached
    if ((job_count >= max_jobs)); then
        wait -n
        ((job_count--))
    fi
done

# Wait for remaining jobs
wait
```

---

### BASH-324 — Job Exit Status

```bash copy
#!/bin/bash

# Start jobs
sleep 2 && echo "Success" &
pid1=$!

sleep 1 && exit 1 &
pid2=$!

# Wait and check status
wait $pid1
status1=$?

wait $pid2
status2=$?

echo "Job 1 exit status: $status1"
echo "Job 2 exit status: $status2"
```

</div>

</details>

---

<details>
<summary><strong>5. Job Control</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-325 — Suspending and Resuming

```bash copy
# Start a long-running command
sleep 100

# Suspend it (Ctrl+Z)
# [1]+  Stopped                 sleep 100

# Resume in foreground
fg

# Resume in background
bg

# Resume specific job
fg %1    # Job number
bg %1
```

---

### BASH-326 — Moving Between Foreground and Background

```bash copy
# Start in foreground
sleep 60

# Suspend (Ctrl+Z)
# [1]+  Stopped

# Resume in background
bg %1

# Bring back to foreground
fg %1
```

---

### BASH-327 — Job Control Commands

```bash copy
# Bring job to foreground
fg              # Current job
fg %1           # Job 1
fg %sleep       # Job starting with "sleep"

# Send job to background
bg              # Current job
bg %1           # Job 1

# Kill job
kill %1         # Kill job 1
kill %%         # Kill current job
kill %sleep     # Kill job matching "sleep"
```

---

### BASH-328 — Disowning Jobs

```bash copy
# Start job
sleep 100 &

# Disown (removes from job table)
disown

# Job continues but is no longer tracked

# Disown specific job
sleep 200 &
disown %1

# Disown all jobs
disown -a
```

**Why disown?**
- Job continues after shell exits
- Useful for long-running processes
- Won't receive HUP signal when terminal closes

</div>

</details>

---

<details>
<summary><strong>6. Process Information</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-329 — Listing Processes

```bash copy
# Show all processes
ps aux

# Show process tree
ps auxf
pstree

# Show processes for current user
ps u

# Show processes by user
ps u -U username

# Show specific process
ps -p PID
```

---

### BASH-330 — Process Information

```bash copy
# Get process command line
ps -p PID -o cmd=

# Get process status
ps -p PID -o stat=

# Get process CPU usage
ps -p PID -o %cpu=

# Get process memory usage
ps -p PID -o %mem=

# Multiple fields
ps -p PID -o pid,ppid,cmd,%cpu,%mem
```

---

### BASH-331 — Find Processes

```bash copy
# Find by name
pgrep nginx

# Find by name with full command
pgrep -f "python script.py"

# Find by user
pgrep -u username

# Find and show details
pgrep -a nginx

# Count matching processes
pgrep -c nginx
```

---

### BASH-332 — Process Tree

```bash copy
# Show tree from specific process
pstree -p PID

# Show tree with command line
pstree -a PID

# Highlight specific process
pstree -H PID

# Show threads
pstree -t
```

---

### BASH-333 — Check if Process Running

```bash copy
# Method 1: pgrep
if pgrep -x nginx > /dev/null; then
    echo "nginx is running"
fi

# Method 2: pidof
if pidof nginx > /dev/null; then
    echo "nginx is running"
fi

# Method 3: kill -0 (send null signal)
if kill -0 PID 2>/dev/null; then
    echo "Process $PID is running"
fi
```

</div>

</details>

---

<details>
<summary><strong>7. Signals and Process Control</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-334 — Understanding Signals

```bash copy
# List all signals
kill -l

# Common signals:
# SIGTERM (15) - Graceful termination
# SIGKILL (9)  - Force kill (cannot be caught)
# SIGINT (2)   - Interrupt (Ctrl+C)
# SIGHUP (1)   - Hangup
# SIGSTOP (19) - Stop (cannot be caught)
# SIGCONT (18) - Continue
```

---

### BASH-335 — Sending Signals

```bash copy
# Send SIGTERM (default)
kill PID

# Send specific signal
kill -TERM PID
kill -15 PID

# Force kill
kill -KILL PID
kill -9 PID

# Send to process group
kill -TERM -PID

# Kill by name
pkill nginx
killall nginx
```

---

### BASH-336 — Graceful vs Force Kill

```bash copy
#!/bin/bash
# Gracefully stop process with timeout

stop_process() {
    local pid=$1
    local timeout=${2:-10}
    
    # Send TERM signal
    kill -TERM $pid 2>/dev/null || return 1
    
    # Wait for process to exit
    local elapsed=0
    while kill -0 $pid 2>/dev/null; do
        sleep 1
        ((elapsed++))
        
        if ((elapsed >= timeout)); then
            echo "Timeout, force killing"
            kill -KILL $pid
            return 1
        fi
    done
    
    echo "Process stopped gracefully"
    return 0
}

# Usage
stop_process 12345 10
```

---

### BASH-337 — Trap Signals in Scripts

```bash copy
#!/bin/bash
# Handle signals gracefully

cleanup() {
    echo "Cleaning up..."
    # Cleanup code here
    rm -f /tmp/lockfile
    exit 0
}

# Trap signals
trap cleanup SIGINT SIGTERM

echo "Script running (PID: $$)"
echo "Press Ctrl+C to stop"

while true; do
    echo "Working..."
    sleep 1
done
```

---

### BASH-338 — Trap Multiple Signals

```bash copy
#!/bin/bash

cleanup() {
    local signal=$1
    echo "Received $signal signal"
    # Cleanup
    exit 0
}

# Trap multiple signals
trap 'cleanup SIGINT' INT
trap 'cleanup SIGTERM' TERM
trap 'cleanup SIGHUP' HUP

# Or trap all at once
trap 'cleanup "signal"' INT TERM HUP

while true; do
    sleep 1
done
```

---

### BASH-339 — Ignore Signals

```bash copy
#!/bin/bash
# Ignore specific signals

# Ignore SIGINT (Ctrl+C won't work)
trap '' INT

echo "Try pressing Ctrl+C (it won't work)"
sleep 10

# Restore default handler
trap - INT

echo "Now Ctrl+C will work"
sleep 10
```

---

### BASH-340 — Signal-Safe Cleanup

```bash copy
#!/bin/bash
# Ensure cleanup runs even on signals

temp_file=$(mktemp)
temp_dir=$(mktemp -d)

cleanup() {
    local exit_code=$?
    echo "Cleaning up (exit code: $exit_code)"
    rm -f "$temp_file"
    rm -rf "$temp_dir"
    exit $exit_code
}

# Trap EXIT (runs on any exit)
trap cleanup EXIT

# Trap signals to exit cleanly
trap 'exit 130' INT   # 128 + 2
trap 'exit 143' TERM  # 128 + 15

echo "Script running..."
sleep 30
```

</div>

</details>

---

<details>
<summary><strong>8. Process Substitution</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-341 — Basic Process Substitution

```bash copy
# Compare output of two commands
diff <(ls dir1) <(ls dir2)

# Sort and compare
diff <(sort file1.txt) <(sort file2.txt)

# Multiple inputs
paste <(seq 1 5) <(seq 6 10) <(seq 11 15)
```

---

### BASH-342 — Process Substitution for Output

```bash copy
# Send output to multiple processes
command > >(process1) > >(process2)

# Example: log to file and send to syslog
command > >(tee -a logfile.log) > >(logger -t mytag)

# Duplicate stream
command | tee >(process1) >(process2) > /dev/null
```

---

### BASH-343 — Complex Process Substitution

```bash copy
# Join data from different sources
join <(sort users.txt) <(sort groups.txt)

# Compare live data
diff <(ssh server1 'df -h') <(ssh server2 'df -h')

# Process and compare
diff <(grep ERROR log1.txt | sort) <(grep ERROR log2.txt | sort)
```

</div>

</details>

---

<details>
<summary><strong>9. Subshells and Command Groups</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-344 — Subshells

```bash copy
# Subshell (in parentheses)
(cd /tmp && ls)
# Current directory unchanged

# Variables in subshell don't affect parent
(var=hello)
echo $var  # Empty

# Subshells inherit variables
export_var="test"
(echo $export_var)  # Prints "test"
```

---

### BASH-345 — Command Groups

```bash copy
# Command group (in braces)
{ cd /tmp && ls; }
# Current directory changed!

# Variables in group affect parent
{ var=hello; }
echo $var  # Prints "hello"

# Redirect group output
{
    echo "Line 1"
    echo "Line 2"
    echo "Line 3"
} > output.txt
```

---

### BASH-346 — Subshells vs Command Groups

```bash copy
# Subshell - isolated
(
    cd /tmp
    var="subshell"
    echo "In subshell: $(pwd)"
)
echo "In parent: $(pwd)"
echo "Var: $var"  # Empty

# Command group - shared
{
    cd /tmp
    var="group"
    echo "In group: $(pwd)"
}
echo "In parent: $(pwd)"  # /tmp
echo "Var: $var"  # "group"
```

---

### BASH-347 — Parallel Execution with Subshells

```bash copy
#!/bin/bash
# Run tasks in parallel

# Sequential (slow)
task1
task2
task3

# Parallel (fast)
(task1) &
(task2) &
(task3) &
wait

# With error handling
(task1 || echo "Task 1 failed") &
(task2 || echo "Task 2 failed") &
(task3 || echo "Task 3 failed") &
wait
```

</div>

</details>

---

<details>
<summary><strong>10. Process Monitoring</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-348 — Monitor Process CPU and Memory

```bash copy
#!/bin/bash
# Monitor process resources

monitor_process() {
    local pid=$1
    
    while kill -0 $pid 2>/dev/null; do
        # Get CPU and memory usage
        read cpu mem < <(ps -p $pid -o %cpu,%mem --no-headers)
        
        echo "$(date) - CPU: ${cpu}% MEM: ${mem}%"
        sleep 1
    done
}

# Usage
command &
pid=$!
monitor_process $pid
```

---

### BASH-349 — Watch Process Status

```bash copy
#!/bin/bash
# Watch process continuously

watch_process() {
    local name=$1
    
    watch -n 1 "ps aux | grep '$name' | grep -v grep"
}

# Alternative with loop
monitor_by_name() {
    local name=$1
    
    while true; do
        clear
        echo "=== Process: $name ==="
        echo "Time: $(date)"
        echo ""
        ps aux | grep "$name" | grep -v grep
        sleep 2
    done
}
```

---

### BASH-350 — Top Processes

```bash copy
#!/bin/bash
# Show top CPU consumers

top_cpu() {
    local count=${1:-10}
    ps aux --sort=-%cpu | head -n $((count + 1))
}

# Top memory consumers
top_memory() {
    local count=${1:-10}
    ps aux --sort=-%mem | head -n $((count + 1))
}

# Usage
echo "=== Top 10 CPU ==="
top_cpu 10

echo ""
echo "=== Top 10 Memory ==="
top_memory 10
```

---

### BASH-351 — Process Lifetime Tracking

```bash copy
#!/bin/bash
# Track how long process runs

track_process() {
    local pid=$1
    local start=$(date +%s)
    
    echo "Tracking process $pid..."
    
    while kill -0 $pid 2>/dev/null; do
        sleep 1
    done
    
    local end=$(date +%s)
    local duration=$((end - start))
    
    echo "Process ran for $duration seconds"
}

# Usage
long_running_command &
track_process $!
```

</div>

</details>

---

<details>
<summary><strong>11. Resource Management</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-352 — CPU Affinity

```bash copy
# Run on specific CPU cores
taskset -c 0,1 command        # Cores 0 and 1
taskset -c 0-3 command        # Cores 0 through 3

# Get current affinity
taskset -p PID

# Set affinity for running process
taskset -cp 0,1 PID
```

---

### BASH-353 — Memory Limits

```bash copy
# Limit memory (ulimit)
ulimit -v 1000000  # Virtual memory (KB)
ulimit -m 500000   # Physical memory (KB)

# Run with memory limit
(ulimit -v 1000000; command)

# Check limits
ulimit -a
```

---

### BASH-354 — CPU Time Limits

```bash copy
# Limit CPU time
ulimit -t 60  # 60 seconds

# Run with time limit
(ulimit -t 30; command)

# Timeout wrapper
timeout 30s command
timeout 5m long_running_command
```

---

### BASH-355 — Process Priority (nice/renice)

```bash copy
# Start with lower priority
nice -n 10 cpu_intensive_task

# Start with higher priority (requires root)
nice -n -10 important_task

# Change priority of running process
renice -n 5 -p PID

# Change priority of all user processes
renice -n 10 -u username
```

---

### BASH-356 — cgroups (Control Groups)

```bash copy
# Create cgroup
cgcreate -g cpu,memory:mygroup

# Set CPU limit (50%)
cgset -r cpu.cfs_quota_us=50000 mygroup
cgset -r cpu.cfs_period_us=100000 mygroup

# Set memory limit (1GB)
cgset -r memory.limit_in_bytes=1G mygroup

# Run command in cgroup
cgexec -g cpu,memory:mygroup command
```

</div>

</details>

---

<details>
<summary><strong>12. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Parallel Task Executor

```bash copy
#!/bin/bash
# parallel_tasks.sh - Execute tasks in parallel with limits

set -euo pipefail

max_jobs=${1:-4}
tasks_file=${2:-"tasks.txt"}

if [[ ! -f "$tasks_file" ]]; then
    echo "Tasks file not found: $tasks_file" >&2
    exit 1
fi

echo "=== Parallel Task Executor ==="
echo "Max concurrent: $max_jobs"
echo "Tasks file: $tasks_file"
echo ""

# Track jobs
declare -A job_pids
declare -A job_status
job_count=0
total_tasks=0
completed=0
failed=0

# Execute single task
execute_task() {
    local task=$1
    local task_num=$2
    
    echo "[Task $task_num] Starting: $task"
    local start=$(date +%s)
    
    if eval "$task"; then
        local end=$(date +%s)
        local duration=$((end - start))
        echo "[Task $task_num] ✓ Complete (${duration}s)"
        return 0
    else
        local end=$(date +%s)
        local duration=$((end - start))
        echo "[Task $task_num] ✗ Failed (${duration}s)" >&2
        return 1
    fi
}

# Read and execute tasks
while IFS= read -r task; do
    # Skip empty lines and comments
    [[ -z "$task" || "$task" =~ ^# ]] && continue
    
    ((total_tasks++))
    
    # Execute task in background
    execute_task "$task" "$total_tasks" &
    pid=$!
    
    job_pids[$pid]=$total_tasks
    ((job_count++))
    
    # Wait if max jobs reached
    while ((job_count >= max_jobs)); do
        # Wait for any job to finish
        wait -n
        status=$?
        
        # Find which job finished
        for pid in "${!job_pids[@]}"; do
            if ! kill -0 $pid 2>/dev/null; then
                task_num=${job_pids[$pid]}
                
                if ((status == 0)); then
                    ((completed++))
                else
                    ((failed++))
                fi
                
                unset job_pids[$pid]
                ((job_count--))
                break
            fi
        done
    done
done < "$tasks_file"

# Wait for remaining jobs
while ((job_count > 0)); do
    wait -n
    status=$?
    
    for pid in "${!job_pids[@]}"; do
        if ! kill -0 $pid 2>/dev/null; then
            if ((status == 0)); then
                ((completed++))
            else
                ((failed++))
            fi
            unset job_pids[$pid]
            ((job_count--))
            break
        fi
    done
done

# Summary
echo ""
echo "=== Execution Complete ==="
echo "Total tasks: $total_tasks"
echo "Completed: $completed"
echo "Failed: $failed"

[[ $failed -gt 0 ]] && exit 1
exit 0
```

---

### Scenario 2: Process Monitor and Restart

```bash copy
#!/bin/bash
# monitor_restart.sh - Monitor process and restart if needed

set -euo pipefail

process_name=${1:?"Process name required"}
check_interval=${2:-5}
max_restarts=${3:-5}

echo "=== Process Monitor ==="
echo "Process: $process_name"
echo "Check interval: ${check_interval}s"
echo "Max restarts: $max_restarts"
echo ""

restart_count=0
last_restart=0

check_process() {
    pgrep -x "$process_name" > /dev/null
}

start_process() {
    echo "[$(date)] Starting $process_name..."
    
    # Start process (customize this)
    systemctl start "$process_name" 2>/dev/null || \
    service "$process_name" start 2>/dev/null || \
    "$process_name" &
    
    sleep 2
    
    if check_process; then
        echo "[$(date)] ✓ Started successfully"
        return 0
    else
        echo "[$(date)] ✗ Failed to start" >&2
        return 1
    fi
}

monitor_loop() {
    while true; do
        if check_process; then
            # Process running
            pid=$(pgrep -x "$process_name")
            cpu=$(ps -p $pid -o %cpu= --no-headers 2>/dev/null || echo "N/A")
            mem=$(ps -p $pid -o %mem= --no-headers 2>/dev/null || echo "N/A")
            
            echo "[$(date)] ✓ Running (PID: $pid, CPU: ${cpu}%, MEM: ${mem}%)"
            restart_count=0  # Reset counter on successful check
        else
            # Process not running
            echo "[$(date)] ✗ Process not running"
            
            # Check restart limit
            if ((restart_count >= max_restarts)); then
                echo "[$(date)] ✗ Max restarts reached ($max_restarts)" >&2
                exit 1
            fi
            
            # Rate limiting
            current_time=$(date +%s)
            if ((current_time - last_restart < 10)); then
                echo "[$(date)] Waiting before restart..."
                sleep 10
            fi
            
            # Attempt restart
            ((restart_count++))
            last_restart=$(date +%s)
            
            if start_process; then
                echo "[$(date)] Restart successful ($restart_count/$max_restarts)"
            else
                echo "[$(date)] Restart failed ($restart_count/$max_restarts)" >&2
            fi
        fi
        
        sleep $check_interval
    done
}

# Setup signal handlers
cleanup() {
    echo ""
    echo "[$(date)] Monitor stopped"
    exit 0
}

trap cleanup INT TERM

# Start monitoring
monitor_loop
```

---

### Scenario 3: Resource-Limited Job Runner

```bash copy
#!/bin/bash
# resource_limited_runner.sh - Run job with resource constraints

set -euo pipefail

# Configuration
max_cpu_percent=${MAX_CPU:-50}
max_memory_mb=${MAX_MEMORY:-1024}
timeout_seconds=${TIMEOUT:-300}

echo "=== Resource Limited Job Runner ==="
echo "CPU limit: ${max_cpu_percent}%"
echo "Memory limit: ${max_memory_mb}MB"
echo "Timeout: ${timeout_seconds}s"
echo ""

# Monitor resources
monitor_resources() {
    local pid=$1
    local log_file=$2
    
    {
        echo "=== Resource Usage Log ==="
        echo "Timestamp,CPU%,MEM%,RSS_KB"
        
        while kill -0 $pid 2>/dev/null; do
            read cpu mem rss < <(ps -p $pid -o %cpu,%mem,rss --no-headers 2>/dev/null || echo "0 0 0")
            
            echo "$(date +%s),$cpu,$mem,$rss"
            
            # Check CPU limit
            cpu_int=${cpu%.*}
            if ((cpu_int > max_cpu_percent)); then
                echo "WARNING: CPU usage ($cpu%) exceeds limit ($max_cpu_percent%)" >&2
            fi
            
            # Check memory limit
            mem_mb=$((rss / 1024))
            if ((mem_mb > max_memory_mb)); then
                echo "ERROR: Memory usage (${mem_mb}MB) exceeds limit (${max_memory_mb}MB)" >&2
                kill -TERM $pid
                return 1
            fi
            
            sleep 1
        done
    } > "$log_file"
}

# Run job
run_job() {
    local command="$@"
    local start=$(date +%s)
    
    echo "Starting job: $command"
    
    # Start with resource limits
    (
        # Set ulimits
        ulimit -v $((max_memory_mb * 1024))  # Virtual memory
        ulimit -t $timeout_seconds           # CPU time
        
        # Execute command
        eval "$command"
    ) &
    
    local pid=$!
    echo "Job PID: $pid"
    
    # Monitor in background
    local log_file="/tmp/job-${pid}-resources.log"
    monitor_resources $pid "$log_file" &
    local monitor_pid=$!
    
    # Wait with timeout
    local elapsed=0
    while kill -0 $pid 2>/dev/null; do
        sleep 1
        ((elapsed++))
        
        if ((elapsed >= timeout_seconds)); then
            echo "Job timeout after ${timeout_seconds}s" >&2
            kill -TERM $pid
            sleep 2
            kill -KILL $pid 2>/dev/null
            wait $monitor_pid 2>/dev/null
            return 124  # timeout exit code
        fi
    done
    
    # Get exit status
    wait $pid
    local exit_code=$?
    
    wait $monitor_pid 2>/dev/null
    
    local end=$(date +%s)
    local duration=$((end - start))
    
    echo ""
    echo "=== Job Complete ==="
    echo "Duration: ${duration}s"
    echo "Exit code: $exit_code"
    echo "Resource log: $log_file"
    
    # Show resource summary
    if [[ -f "$log_file" ]]; then
        echo ""
        echo "=== Resource Summary ==="
        awk -F',' 'NR>2 {
            sum_cpu+=$2; sum_mem+=$3; sum_rss+=$4; count++
        } END {
            printf "Avg CPU: %.2f%%\n", sum_cpu/count
            printf "Avg MEM: %.2f%%\n", sum_mem/count
            printf "Avg RSS: %.2f MB\n", sum_rss/count/1024
        }' "$log_file"
    fi
    
    return $exit_code
}

# Run job with provided command
if [[ $# -eq 0 ]]; then
    echo "Usage: $0 <command>" >&2
    exit 1
fi

run_job "$@"
```

---

### Scenario 4: Graceful Shutdown Handler

```bash copy
#!/bin/bash
# graceful_shutdown.sh - Handle shutdown gracefully

set -euo pipefail

# Global state
declare -a child_pids=()
shutdown_requested=false

# Cleanup function
cleanup() {
    local signal=${1:-EXIT}
    
    if [[ "$shutdown_requested" == "true" ]]; then
        return  # Already shutting down
    fi
    
    shutdown_requested=true
    
    echo ""
    echo "[$(date)] Received $signal, shutting down gracefully..."
    
    # Stop accepting new work
    # (your application logic here)
    
    # Wait for existing work to complete
    if [[ ${#child_pids[@]} -gt 0 ]]; then
        echo "[$(date)] Waiting for ${#child_pids[@]} child processes..."
        
        local timeout=30
        local elapsed=0
        
        while ((${#child_pids[@]} > 0)) && ((elapsed < timeout)); do
            local remaining=()
            
            for pid in "${child_pids[@]}"; do
                if kill -0 $pid 2>/dev/null; then
                    remaining+=($pid)
                else
                    echo "[$(date)] Process $pid completed"
                fi
            done
            
            child_pids=("${remaining[@]}")
            
            if ((${#child_pids[@]} > 0)); then
                sleep 1
                ((elapsed++))
            fi
        done
        
        # Force kill remaining processes
        if ((${#child_pids[@]} > 0)); then
            echo "[$(date)] Timeout, force killing ${#child_pids[@]} processes"
            for pid in "${child_pids[@]}"; do
                kill -KILL $pid 2>/dev/null || true
            done
        fi
    fi
    
    # Cleanup resources
    echo "[$(date)] Cleaning up resources..."
    # (your cleanup logic here)
    
    echo "[$(date)] Shutdown complete"
    exit 0
}

# Register signal handlers
trap 'cleanup SIGINT' INT
trap 'cleanup SIGTERM' TERM
trap 'cleanup SIGHUP' HUP
trap 'cleanup EXIT' EXIT

# Worker function
do_work() {
    local id=$1
    echo "[Worker $id] Starting work (PID: $$)"
    sleep $((RANDOM % 20 + 10))
    echo "[Worker $id] Work complete"
}

# Main loop
echo "[$(date)] Service started (PID: $$)"
echo "Press Ctrl+C for graceful shutdown"
echo ""

work_id=0

while [[ "$shutdown_requested" == "false" ]]; do
    ((work_id++))
    
    # Start worker
    do_work $work_id &
    pid=$!
    child_pids+=($pid)
    
    echo "[$(date)] Started worker $work_id (PID: $pid)"
    
    # Clean up completed workers
    local active=()
    for pid in "${child_pids[@]}"; do
        if kill -0 $pid 2>/dev/null; then
            active+=($pid)
        fi
    done
    child_pids=("${active[@]}")
    
    # Rate limit
    sleep 5
done
```

---

### Scenario 5: Process Pool Manager

```bash copy
#!/bin/bash
# process_pool.sh - Manage a pool of worker processes

set -euo pipefail

pool_size=${1:-4}
work_queue="/tmp/work_queue_$$"
results_file="/tmp/results_$$"

# Cleanup
trap "rm -f '$work_queue' '$results_file'" EXIT

mkfifo "$work_queue"

echo "=== Process Pool Manager ==="
echo "Pool size: $pool_size"
echo ""

# Worker function
worker() {
    local worker_id=$1
    
    while IFS= read -r task; do
        [[ "$task" == "STOP" ]] && break
        
        echo "[Worker $worker_id] Processing: $task"
        
        # Execute task
        if eval "$task"; then
            echo "[Worker $worker_id] ✓ Success: $task" >> "$results_file"
        else
            echo "[Worker $worker_id] ✗ Failed: $task" >> "$results_file"
        fi
    done < "$work_queue"
    
    echo "[Worker $worker_id] Stopped"
}

# Start worker pool
echo "Starting worker pool..."
worker_pids=()

for i in $(seq 1 $pool_size); do
    worker $i &
    worker_pids+=($!)
    echo "Started worker $i (PID: ${worker_pids[-1]})"
done

echo ""
echo "Worker pool ready. Send tasks to: $work_queue"
echo "Submit tasks with: echo 'command' > $work_queue"
echo "Stop workers with: echo 'STOP' > $work_queue"
echo ""

# Example: Submit some tasks
{
    for i in $(seq 1 10); do
        echo "sleep $((RANDOM % 5 + 1)) && echo 'Task $i done'"
    done
    
    # Send stop signals
    for i in $(seq 1 $pool_size); do
        echo "STOP"
    done
} > "$work_queue" &

# Wait for all workers
for pid in "${worker_pids[@]}"; do
    wait $pid
done

echo ""
echo "=== Results ==="
cat "$results_file"
```

</div>

</details>

---

<details>
<summary><strong>13. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Start in background
command &
```

```bash copy
# Get PID of last background job
pid=$!
```

```bash copy
# List jobs
jobs
jobs -l  # with PIDs
```

```bash copy
# Wait for job
wait
wait $pid
wait -n  # wait for any
```

```bash copy
# Foreground/background control
fg       # bring to foreground
bg       # send to background
```

```bash copy
# Disown job
disown
disown %1
```

```bash copy
# Kill process
kill PID
kill -TERM PID
kill -KILL PID
kill -9 PID
```

```bash copy
# Kill by name
pkill name
killall name
```

```bash copy
# Find processes
pgrep name
pgrep -f "pattern"
pidof name
```

```bash copy
# Process information
ps aux
ps -p PID
ps aux | grep name
```

```bash copy
# Process tree
pstree
pstree -p PID
```

```bash copy
# Check if running
kill -0 PID 2>/dev/null
pgrep -x name > /dev/null
```

```bash copy
# Trap signals
trap 'cleanup' EXIT
trap 'handler' INT TERM
```

```bash copy
# Run with timeout
timeout 30s command
```

```bash copy
# Run with nice
nice -n 10 command
renice -n 5 -p PID
```

```bash copy
# Process substitution
diff <(cmd1) <(cmd2)
```

```bash copy
# Subshell
(command)
```

```bash copy
# Command group
{ command; }
```

</div>

</details>

---

<details>
<summary><strong>14. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Every command creates a process with unique PID
- Background jobs run concurrently with `&`
- Signals control processes (TERM, KILL, INT, etc.)
- `trap` catches signals for cleanup
- `wait` synchronizes background jobs
- Process substitution `<()` treats command output as file

---

**Process Control:**

| Command | Action |
|---------|--------|
| `command &` | Run in background |
| `jobs` | List background jobs |
| `fg` | Bring job to foreground |
| `bg` | Send job to background |
| `wait` | Wait for jobs to complete |
| `Ctrl+Z` | Suspend current job |
| `Ctrl+C` | Interrupt current job |

---

**Signals:**

| Signal | Number | Effect | Can Block? |
|--------|--------|--------|------------|
| SIGTERM | 15 | Graceful termination | Yes |
| SIGKILL | 9 | Force kill | No |
| SIGINT | 2 | Interrupt (Ctrl+C) | Yes |
| SIGHUP | 1 | Hangup | Yes |
| SIGSTOP | 19 | Stop | No |
| SIGCONT | 18 | Continue | No |

---

**Process Information:**

| Command | Purpose |
|---------|---------|
| `ps aux` | List all processes |
| `pgrep name` | Find process by name |
| `pidof name` | Get PID by name |
| `pstree` | Show process tree |
| `top` | Interactive monitor |
| `kill -0 PID` | Check if running |

---

**Common Patterns:**

```bash copy
# Parallel execution with limit
max_jobs=4
job_count=0
for item in "${items[@]}"; do
    process "$item" &
    ((job_count++))
    if ((job_count >= max_jobs)); then
        wait -n
        ((job_count--))
    fi
done
wait

# Graceful cleanup
cleanup() {
    echo "Cleaning up..."
    # cleanup code
}
trap cleanup EXIT INT TERM

# Wait with timeout
sleep 30 &
pid=$!
timeout=10
elapsed=0
while kill -0 $pid 2>/dev/null; do
    ((elapsed >= timeout)) && kill $pid && break
    sleep 1
    ((elapsed++))
done

# Check if process running
if pgrep -x nginx > /dev/null; then
    echo "Running"
fi
```

---

**Job Control:**

| Syntax | Meaning |
|--------|---------|
| `%1` | Job 1 |
| `%%` | Current job |
| `%+` | Current job |
| `%-` | Previous job |
| `%string` | Job starting with "string" |

---

**Resource Limits:**

| Command | Purpose |
|---------|---------|
| `nice -n 10 cmd` | Lower priority |
| `renice -n 5 -p PID` | Change priority |
| `ulimit -v 1000000` | Limit memory |
| `ulimit -t 60` | Limit CPU time |
| `timeout 30s cmd` | Kill after timeout |
| `taskset -c 0,1 cmd` | CPU affinity |

---

**Best Practices:**

1. **Always trap EXIT for cleanup**
   ```bash copy
   trap cleanup EXIT
   ```

2. **Wait for background jobs**
   ```bash copy
   command &
   wait
   ```

3. **Check process status**
   ```bash copy
   if kill -0 $pid 2>/dev/null; then
       echo "Running"
   fi
   ```

4. **Graceful termination**
   ```bash copy
   kill -TERM $pid  # Try graceful
   sleep 5
   kill -KILL $pid  # Force if needed
   ```

5. **Limit concurrent jobs**
   ```bash copy
   while ((job_count >= max_jobs)); do
       wait -n
       ((job_count--))
   done
   ```

---

**What's Next:**
Now that you can manage processes, the next file covers error handling and debugging — how to write robust scripts that fail gracefully and are easy to troubleshoot.

</div>

</details>

---