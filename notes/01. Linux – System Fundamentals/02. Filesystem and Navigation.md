# Filesystem & Navigation

Every operating system has a way of organizing files. Windows uses drive letters — `C:\`, `D:\`, scattered across physical disks. macOS hides most of its structure behind a pretty GUI. Linux takes a different approach: one unified tree, starting from a single root, with every file, device, process, and piece of system state living somewhere in that tree.

This isn't just organization for organization's sake. The Linux filesystem hierarchy is a **mental map**. Once you internalize it, you stop guessing where things are. Configs? `/etc`. Logs? `/var/log`. Binaries? `/usr/bin`. User data? `/home`. Temporary files? `/tmp`. The structure becomes instinct.

This file teaches you that map — not just "what goes where," but *why* it's organized this way, and how to move through it efficiently. By the end, navigating Linux will feel as natural as navigating your own house.

---

## Table of Contents

1. [The Root of Everything](#1-the-root-of-everything)
2. [The Directory Hierarchy — A Guided Tour](#2-the-directory-hierarchy--a-guided-tour)
3. [Paths — Absolute vs Relative](#3-paths--absolute-vs-relative)
4. [Navigation Commands](#4-navigation-commands)
5. [Listing and Inspecting](#5-listing-and-inspecting)
6. [Finding Things](#6-finding-things)
7. [Navigation Shortcuts That Save Hours](#7-navigation-shortcuts-that-save-hours)
8. [Where We Go From Here](#8-where-we-go-from-here)

---

<details>
<summary><strong>1. The Root of Everything</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

In Linux, everything starts at `/` — the root directory. Not "root" as in the superuser, but root as in the base of the tree. Every file, every directory, every device, every mount point — all of it branches from this single point.

There are no drive letters. When you plug in a USB drive, it doesn't become `E:\`. It gets *mounted* somewhere in the existing tree, like `/mnt/usb` or `/media/username/drive`. The tree stays unified.

This design comes from Unix philosophy: one namespace, one hierarchy, everything accessible through the same interface. It seems simple, but it has profound implications. You can move directories around, mount network drives, swap physical disks — and the paths stay consistent. Applications don't care where data physically lives. They just follow paths.

When you open a terminal, you land in your home directory — something like `/home/d.akhilteja`. But you're always somewhere in that tree. The `pwd` command (print working directory) tells you exactly where:

```bash
pwd
```

Output: `/home/d.akhilteja`

That's your current location in the filesystem. Every command you run operates relative to this location unless you specify otherwise.

</div>
</details>

---

<details>
<summary><strong>2. The Directory Hierarchy — A Guided Tour</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The Filesystem Hierarchy Standard (FHS) defines where things belong. Every major distribution follows this standard, which means once you learn it, you know where to look on any Linux system.

### `/` — The root

The base. Everything branches from here.

### `/home` — User territories

Each user gets a directory: `/home/d.akhilteja`, `/home/t.charan`. This is where personal files, configs, downloads, and projects live. When ChillSpot's developers save their work, it lands here.

### `/root` — The superuser's home

The root user (administrator) doesn't live in `/home`. Their home directory is `/root`. This separation exists because `/home` might be on a separate partition or network mount — the root user needs a home directory that's always available, even in recovery mode.

### `/etc` — Configuration central

System-wide configuration files live here. SSH settings in `/etc/ssh/`. Network configuration in `/etc/netplan/` or `/etc/network/`. User accounts in `/etc/passwd`. Service configs scattered throughout. If you're configuring something system-wide, you're editing files in `/etc`.

```bash
ls /etc
```

You'll see dozens of files and directories — each controlling some aspect of the system.

### `/var` — Variable data

Data that changes during operation: logs (`/var/log`), mail spools, print queues, caches. When ChillSpot Streaming writes access logs, they land in `/var/log/chillspot/`. When the system logs authentication attempts, check `/var/log/auth.log`.

This directory grows over time. On long-running servers, `/var/log` can consume gigabytes if not rotated properly.

### `/tmp` — Temporary files

Short-lived files that programs create and discard. Cleared on reboot (on most systems). Never store anything important here.

### `/usr` — User programs and data

Despite the name, this isn't about users — it's historically "Unix System Resources." Most installed software lives here:

- `/usr/bin` — user commands (most of what you run daily)
- `/usr/sbin` — system administration commands
- `/usr/lib` — libraries
- `/usr/share` — architecture-independent data (docs, icons, etc.)

When you install packages, they typically land in `/usr`.

Closely related to `/usr` are the legacy binary directories:

### `/bin` and `/sbin` — Essential binaries

Core commands needed for basic operation and recovery. On modern systems, these are symlinks to `/usr/bin` and `/usr/sbin` — the distinction is historical, but scripts still reference the old paths for compatibility.

Moving from system binaries to third-party software:

### `/opt` — Optional software

Third-party applications that don't follow standard packaging often install here. If ChillSpot installs a vendor's monitoring agent, it might land in `/opt/vendor-agent/`. This is typically used for proprietary or self-contained software that isn't controlled by the system package manager.

Now we shift from installed software to something different — virtual filesystems that expose hardware and kernel internals:

### `/dev` — Devices as files

Hardware represented as files. Disks (`/dev/sda`, `/dev/nvme0n1`), terminals (`/dev/tty`), random number generators (`/dev/urandom`). This is the "everything is a file" philosophy in action.

### `/proc` — Process information

A virtual filesystem exposing kernel and process data. `/proc/cpuinfo` shows CPU details. `/proc/meminfo` shows memory. Each running process has a directory: `/proc/1234/` contains everything about process 1234.

### `/sys` — System and device info

Another virtual filesystem for kernel objects, devices, and drivers. More structured than `/proc`, used for device management and kernel parameter tuning.

Finally, the directories where external storage gets attached:

### `/mnt` and `/media` — Mount points

`/mnt` is traditionally for temporary mounts by administrators. `/media` is for removable media (USB drives, CDs). When you plug in a drive, modern desktops auto-mount it under `/media/username/`.

### `/srv` — Service data

Data for services provided by the system. Web servers might store sites in `/srv/www`. Application backends might live in `/srv/appname`. This is where ChillSpot Streaming lives — `/srv/chillspot-streaming/` — keeping service data separate from system files and user home directories.

### The mental map

After a while, this becomes instinct:

- Need to edit a service config? → `/etc`
- Checking logs? → `/var/log`
- Looking for installed programs? → `/usr/bin`
- User's files? → `/home/username`
- Temporary workspace? → `/tmp`
- Device issues? → `/dev`
- Process debugging? → `/proc`

</div>
</details>

---

<details>
<summary><strong>3. Paths — Absolute vs Relative</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every file has an address. That address can be written two ways.

### Absolute paths

Start from root (`/`) and specify the complete location:

```
/home/d.akhilteja/projects/chillspot/config.yaml
```

This path works from anywhere. Doesn't matter where you currently are — the path points to exactly one location.

### Relative paths

Start from your current location:

```
projects/chillspot/config.yaml
```

If you're in `/home/d.akhilteja`, this resolves to the same file. But if you're in `/tmp`, it would look for `/tmp/projects/chillspot/config.yaml` — probably not what you want.

### Special path symbols

`.` — current directory
`..` — parent directory
`~` — your home directory

These shortcuts make navigation faster:

```bash
cd ..          # go up one level
cd ../..       # go up two levels
cd ~/projects  # go to projects in your home
cd ./scripts   # go to scripts in current directory (the ./ is optional)
```

### When to use which

**Absolute paths** in scripts, configs, and automation. You want predictable behavior regardless of where the script runs.

**Relative paths** in interactive sessions when you're navigating around. Faster to type, natural to use.

</div>
</details>

---

<details>
<summary><strong>4. Navigation Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Moving around the filesystem is muscle memory for Linux users. Three commands handle 90% of navigation.

### `pwd` — Where am I?

Print working directory. Shows your current location:

```bash
pwd
```

Output: `/home/d.akhilteja/projects`

### `cd` — Change directory

Move to a different location:

```bash
cd /var/log              # absolute path
cd projects              # relative path
cd ..                    # parent directory
cd ~                     # home directory
cd -                     # previous directory (toggle back)
cd                       # home directory (shortcut)
```

The `cd -` trick is underrated. Jump to `/var/log`, check something, then `cd -` to return exactly where you were.

### `ls` — What's here?

List directory contents:

```bash
ls                       # current directory
ls /etc                  # specific directory
ls -l                    # long format (permissions, owner, size, date)
ls -a                    # include hidden files (starting with .)
ls -la                   # both
ls -lh                   # human-readable sizes (KB, MB, GB)
ls -lt                   # sort by modification time
ls -lS                   # sort by size
```

Combine flags as needed. `ls -lah` is probably the most common — long format, all files, human-readable. Also useful: `ls -d */` lists only directories, and `ls -A` shows all files except `.` and `..`.

### A practical flow

You SSH into a server to check ChillSpot logs:

```bash
pwd                      # /home/d.akhilteja
cd /var/log              # go to logs
ls                       # see what's here
cd chillspot             # enter the app's log directory
ls -lt                   # newest logs first
```

This flow becomes automatic. Where am I? What's here? Go there. Look around.

</div>
</details>

---

<details>
<summary><strong>5. Listing and Inspecting</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Navigating gets you to the right place. Inspecting tells you what you're looking at.

### Reading `ls -l` output

```bash
ls -l /srv/chillspot-streaming/
```

Output:
```
drwxr-xr-x 2 chillspot chillspot 4096 Mar 15 10:30 config
-rw-r--r-- 1 chillspot chillspot 2048 Mar 15 09:15 app.log
-rwxr-xr-x 1 chillspot chillspot 8192 Mar 10 14:20 start.sh
```

Breaking it down:

| Column | Meaning |
|--------|---------|
| `drwxr-xr-x` | File type + permissions |
| `2` | Link count |
| `chillspot` | Owner |
| `chillspot` | Group |
| `4096` | Size in bytes |
| `Mar 15 10:30` | Last modified |
| `config` | Name |

The first character tells you the type:
- `-` = regular file
- `d` = directory
- `l` = symbolic link
- `c` = character device
- `b` = block device

We'll cover permissions deeply in File 03.

Once you know what's in a directory, sometimes you need to know *what kind* of thing you're looking at:

### `file` — What type is this?

Linux doesn't rely on extensions. A file named `data` could be text, binary, image, or anything. The `file` command inspects actual content:

```bash
file app.log
```

Output: `app.log: ASCII text`

```bash
file start.sh
```

Output: `start.sh: Bourne-Again shell script, ASCII text executable`

```bash
file /bin/ls
```

Output: `/bin/ls: ELF 64-bit LSB pie executable, x86-64...`

When you need even more detail — timestamps, inode numbers, exact byte counts:

### `stat` — Full file details

Everything about a file:

```bash
stat config.yaml
```

Output includes size, blocks, inode, permissions, access/modify/change times, and more. Useful when debugging permission or timestamp issues.

For a bird's-eye view of entire directory structures:

### `tree` — Visual hierarchy

If installed, `tree` shows directory structure visually:

```bash
tree /srv/chillspot-streaming/
```

Output:
```
/srv/chillspot-streaming/
├── config
│   ├── nginx.conf
│   └── app.yaml
├── logs
│   └── access.log
└── start.sh
```

Much clearer than nested `ls` commands. Install with `apt install tree` or `dnf install tree`.

</div>
</details>

---

<details>
<summary><strong>6. Finding Things</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

On a server with thousands of files, you need ways to locate things fast. These commands become your daily detective kit — the difference between hunting for ten minutes and finding what you need in seconds.

### `find` — The power tool

Search by name, type, size, time, permissions — almost any attribute.

**Find by name:**

```bash
find /etc -name "nginx.conf"
```

**Find by pattern:**

```bash
find /srv -name "*.log"
```

**Find directories only:**

```bash
find /home -type d -name "projects"
```

**Find files modified in last 24 hours:**

```bash
find /var/log -type f -mtime -1
```

**Find large files (over 100MB):**

```bash
find / -type f -size +100M 2>/dev/null
```

The `2>/dev/null` suppresses permission errors — you'll hit directories you can't read.

**Find and execute:**

```bash
find /tmp -name "*.tmp" -delete              # delete matching files
find /srv -name "*.sh" -exec chmod +x {} \;  # make scripts executable
```

### `locate` — The fast alternative

`locate` uses a pre-built database, making it almost instant:

```bash
locate nginx.conf
```

The catch: the database needs updating. Run `sudo updatedb` to refresh it. Good for finding files on systems you manage; not useful if files just changed.

### `which` and `whereis` — Finding commands

Where does a command live?

```bash
which python3
```

Output: `/usr/bin/python3`

```bash
whereis nginx
```

Output: `nginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx`

`which` shows the executable path. `whereis` shows binaries, source, and manual pages.

### `grep` — Finding content

`find` locates files. `grep` searches inside them:

```bash
grep "error" /var/log/chillspot/app.log
```

**Recursive search:**

```bash
grep -r "database_url" /srv/chillspot-streaming/config/
```

**Case insensitive:**

```bash
grep -i "warning" /var/log/syslog
```

**Show line numbers:**

```bash
grep -n "timeout" config.yaml
```

Combine `find` and `grep` for powerful searches:

```bash
find /etc -name "*.conf" -exec grep -l "ssl" {} \;
```

This finds all `.conf` files in `/etc` that contain "ssl".

</div>
</details>

---

<details>
<summary><strong>7. Navigation Shortcuts That Save Hours</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Experienced engineers navigate fast. Here's how.

### Tab completion

Type partial names, press Tab:

```bash
cd /etc/sys<Tab>
```

Completes to `/etc/systemd/` (if that's the only match) or shows options if multiple exist.

Double-Tab shows all possibilities. This works for commands, paths, and even command options in modern shells.

### Brace expansion

Create or reference multiple paths:

```bash
mkdir -p projects/{frontend,backend,shared}
```

Creates three directories in one command.

```bash
cp config.yaml{,.backup}
```

Copies `config.yaml` to `config.yaml.backup`.

### `pushd` and `popd` — Directory stack

When navigating complex paths, maintain a stack:

```bash
pushd /var/log                 # saves current dir, moves to /var/log
pushd /etc/nginx               # saves /var/log, moves to /etc/nginx
popd                           # returns to /var/log
popd                           # returns to original directory
```

Better than `cd -` when juggling multiple locations.

### History navigation

Your shell remembers commands:

```bash
history                        # show command history
!123                          # run command #123 from history
!!                            # run last command
!cd                           # run last command starting with "cd"
```

Press `Ctrl+R` for reverse search — start typing and it finds matching commands from history.

Once your muscle memory grows, you'll want to create your own shortcuts — that's where aliases come in:

### Aliases

Create shortcuts for common navigations in `~/.bashrc`:

```bash
alias logs='cd /var/log'
alias proj='cd ~/projects/chillspot-streaming'
alias ..='cd ..'
alias ...='cd ../..'
```

After adding, run `source ~/.bashrc` to apply. Now `logs` jumps straight to `/var/log`.

### Practical example

A typical debugging session:

```bash
ssh server01
cd /srv/chillspot-streaming    # or use an alias
ls -la
cd logs
ls -lt | head                   # most recent logs
grep -i error app.log | tail -20
cd -                            # back to app directory
cat config/app.yaml
```

Fluid navigation. No wasted keystrokes.

</div>
</details>

---

## 8. Where We Go From Here

You now have the mental map. You know where configs live, where logs accumulate, where binaries run from, and where users keep their data. You can navigate efficiently, find files by name or content, and move through the filesystem like it's your living room.

But the filesystem isn't just about *finding* files — it's about *controlling access* to them. Every file has an owner, a group, and permission bits that determine who can read, write, or execute it. Without understanding this layer, you'll constantly hit "Permission denied" and not know why. Worse, you might accidentally expose sensitive data or lock yourself out of your own files.

File 03 covers **Users, Groups & Permissions** — the security model protecting everything in this filesystem. And once you understand permissions, you'll be ready for File 04, where we explore what actually *uses* these files: running processes and the systemd service manager.

The filesystem is the foundation. Let's secure it.