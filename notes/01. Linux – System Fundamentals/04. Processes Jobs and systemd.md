# Processes, Jobs & systemd

Every file you've navigated, every permission you've set — none of it matters until something *runs*. A config file is just text until a process reads it. A script is just code until something executes it. The filesystem is storage; processes are action.

When you type `ls`, a process runs. When ChillSpot Streaming serves video, that's a process. When nginx handles requests, PostgreSQL stores data, or cron triggers a backup — all processes. Your Linux system might have hundreds running right now, each consuming CPU, memory, and file handles, each with its own identity and permissions.

Understanding processes means understanding what your system is actually *doing*. You'll learn to see which programs are running, how much resources they consume, how to control them, and how systemd orchestrates everything on modern Linux. This is where static knowledge becomes operational skill.

---

## Table of Contents

1. [What Is a Process?](#1-what-is-a-process)
2. [Viewing Processes](#2-viewing-processes)
3. [Process States and Lifecycle](#3-process-states-and-lifecycle)
4. [Signals — Talking to Processes](#4-signals--talking-to-processes)
5. [Foreground, Background, and Job Control](#5-foreground-background-and-job-control)
6. [Process Priority and Resource Limits](#6-process-priority-and-resource-limits)
7. [systemd — The Modern Init System](#7-systemd--the-modern-init-system)
8. [Managing Services with systemctl](#8-managing-services-with-systemctl)
9. [Writing systemd Unit Files](#9-writing-systemd-unit-files)
10. [Where We Go From Here](#10-where-we-go-from-here)

---

<details>
<summary><strong>1. What Is a Process?</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

A process is a running instance of a program. The program is the code sitting on disk — `/usr/bin/nginx`, `/usr/bin/python3`, your custom script. When you execute it, the kernel creates a process: allocates memory, assigns a process ID (PID), sets up file descriptors, and starts running instructions.

Every process has:

- **PID** — A unique identifier. Process 1 is special (init/systemd). Your process might be 28451.
- **PPID** — Parent process ID. Every process (except PID 1) has a parent that spawned it.
- **UID/GID** — The user and group the process runs as. Determines what files it can access.
- **State** — Running, sleeping, stopped, zombie.
- **Memory** — Its own virtual address space.
- **File descriptors** — Open files, sockets, pipes.

### The process tree

Processes form a tree. PID 1 (systemd on modern systems) is the root. It spawns system services. Those services might spawn workers. When you SSH in, your shell is spawned by the SSH daemon. Commands you run are children of your shell.

```bash
pstree
```

This shows the hierarchy visually. You'll see systemd at the top, branching into services, login sessions, and everything else.

### Process vs program

The distinction matters. One program can have multiple processes — nginx typically runs a master process plus worker processes. One process can execute different programs over time using `exec`. When you run a command in bash, bash forks a child process, then that child execs the command.

Understanding this helps when debugging. "nginx is slow" — which process? The master or a worker? "My script crashed" — the script is gone, but the parent shell remains.

</div>
</details>

---

<details>
<summary><strong>2. Viewing Processes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Several tools show what's running. Each has strengths.

### `ps` — Snapshot of processes

`ps` shows processes at the moment you run it. The options are notoriously inconsistent (BSD vs GNU style), but these patterns cover daily use:

```bash
ps aux
```

Shows all processes, all users, with details:

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 169436 13120 ?        Ss   Mar14   0:09 /sbin/init
chillspot 1842  2.1  4.3 892456 89012 ?        Sl   10:30   1:23 /srv/chillspot-streaming/app
```

| Column | Meaning |
|--------|---------|
| USER | Process owner |
| PID | Process ID |
| %CPU | CPU usage percentage |
| %MEM | Memory usage percentage |
| VSZ | Virtual memory size (KB) |
| RSS | Resident set size — actual RAM used (KB) |
| TTY | Terminal (? means no terminal) |
| STAT | Process state |
| START | Start time |
| TIME | Total CPU time consumed |
| COMMAND | The command that launched it |

**Filter for specific processes:**

```bash
ps aux | grep chillspot
ps aux | grep -v grep | grep nginx    # exclude the grep itself
```

**Show process tree:**

```bash
ps auxf
```

The `f` adds ASCII art showing parent-child relationships.

**Show specific columns:**

```bash
ps -eo pid,ppid,user,%cpu,%mem,cmd --sort=-%mem | head
```

Custom output, sorted by memory usage.

### `top` — Live process monitor

Real-time view that updates continuously:

```bash
top
```

Header shows system summary: uptime, load average, CPU breakdown, memory usage. Below, processes sorted by CPU usage by default.

**Key commands inside top:**

| Key | Action |
|-----|--------|
| `q` | Quit |
| `M` | Sort by memory |
| `P` | Sort by CPU |
| `k` | Kill a process (prompts for PID) |
| `u` | Filter by user |
| `1` | Show individual CPU cores |

### `htop` — Better top

If installed, `htop` provides a friendlier interface with colors, mouse support, and easier navigation:

```bash
htop
```

Shows CPU and memory bars visually. Use arrow keys to select processes, F9 to kill, F6 to sort. Install with `apt install htop` or `dnf install htop`.

### `/proc` — Raw process data

Every process has a directory in `/proc`:

```bash
ls /proc/1842/
```

Contains files exposing process internals:

- `cmdline` — Command and arguments
- `environ` — Environment variables
- `fd/` — Open file descriptors
- `status` — Detailed status including memory
- `cwd` — Current working directory (symlink)
- `exe` — Executable (symlink)

```bash
cat /proc/1842/cmdline | tr '\0' ' '
```

Shows the full command line. Arguments are null-separated, so `tr` makes it readable.

</div>
</details>

---

<details>
<summary><strong>3. Process States and Lifecycle</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Processes don't just "run" — they transition through states. Understanding these helps diagnose performance issues and stuck processes.

### Process states

The STAT column in `ps` shows states as letters:

| State | Meaning |
|-------|---------|
| R | Running or runnable (in run queue) |
| S | Interruptible sleep (waiting for event) |
| D | Uninterruptible sleep (usually I/O) |
| T | Stopped (by signal or debugger) |
| Z | Zombie (terminated but not reaped) |

Additional modifiers:

| Modifier | Meaning |
|----------|---------|
| < | High priority |
| N | Low priority (nice) |
| s | Session leader |
| l | Multi-threaded |
| + | Foreground process group |

So `Ssl` means sleeping, session leader, multi-threaded.

### The lifecycle

1. **Fork** — Parent process creates a copy of itself
2. **Exec** — Child replaces itself with a new program (optional)
3. **Run** — Process executes, alternating between running and sleeping
4. **Exit** — Process terminates, becomes zombie briefly
5. **Reap** — Parent collects exit status, zombie disappears

### Zombies

A zombie process has exited but its parent hasn't called `wait()` to collect the exit status. The process is dead — using no CPU or memory — but its entry remains in the process table.

```bash
ps aux | grep Z
```

A few zombies are normal and transient. Many zombies indicate a parent that's not reaping children properly — a bug in that program.

You can't kill a zombie (it's already dead). You can kill its parent, which orphans the zombie to PID 1, which will reap it.

### Orphans

If a parent dies before its children, those children become orphans. The kernel reassigns them to PID 1 (systemd), which adopts and eventually reaps them. This is normal and handled automatically.

</div>
</details>

---

<details>
<summary><strong>4. Signals — Talking to Processes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Signals are how you communicate with processes. They're software interrupts — the kernel delivers them, and the process can handle, ignore, or die from them.

### Common signals

| Signal | Number | Default Action | Use Case |
|--------|--------|----------------|----------|
| SIGHUP | 1 | Terminate | Reload config (by convention) |
| SIGINT | 2 | Terminate | Ctrl+C — interrupt |
| SIGQUIT | 3 | Core dump | Ctrl+\ — quit with dump |
| SIGKILL | 9 | Terminate | Force kill (cannot be caught) |
| SIGTERM | 15 | Terminate | Graceful shutdown request |
| SIGSTOP | 19 | Stop | Pause process (cannot be caught) |
| SIGCONT | 18 | Continue | Resume stopped process |

### The `kill` command

Despite the name, `kill` sends any signal — termination is just the default:

```bash
kill 1842              # Send SIGTERM (15) — graceful shutdown
kill -9 1842           # Send SIGKILL — force kill
kill -HUP 1842         # Send SIGHUP — often reloads config
kill -STOP 1842        # Pause the process
kill -CONT 1842        # Resume the process
```

### `killall` and `pkill`

Kill by name instead of PID:

```bash
killall nginx          # Kill all processes named exactly "nginx"
pkill -f chillspot     # Kill processes matching pattern in full command
```

The `-f` flag makes `pkill` match against the entire command line, not just the process name.

### Graceful vs forceful

Always try SIGTERM first:

```bash
kill 1842
```

SIGTERM tells the process "please shut down." Well-written programs catch this, close files, finish pending work, and exit cleanly.

If that doesn't work after a few seconds:

```bash
kill -9 1842
```

SIGKILL cannot be caught or ignored. The kernel terminates the process immediately. This can leave files corrupted, connections hanging, or locks unreleased. Use it as a last resort.

### Reloading services

Many daemons reload configuration on SIGHUP:

```bash
kill -HUP $(pgrep nginx)
```

Nginx re-reads its config without dropping connections. Much better than restarting.

</div>
</details>

---

<details>
<summary><strong>5. Foreground, Background, and Job Control</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When you run a command, it typically runs in the foreground — attached to your terminal, blocking until it completes. But you can run processes in the background, juggle multiple jobs, and move them between foreground and background.

### Running in background

Add `&` to run a command in the background:

```bash
./long-running-script.sh &
```

The shell prints the job number and PID:

```
[1] 28451
```

Your prompt returns immediately. The process runs independently.

### Checking jobs

```bash
jobs
```

Shows background jobs for your current shell:

```
[1]+  Running                 ./long-running-script.sh &
[2]-  Stopped                 vim config.yaml
```

### Moving between foreground and background

**Suspend a foreground process:**

Press `Ctrl+Z`. The process stops (SIGSTOP) and returns you to the prompt.

**Resume in background:**

```bash
bg %1
```

The stopped job continues running in the background.

**Bring to foreground:**

```bash
fg %1
```

The background job takes over your terminal.

### Keeping processes alive after logout

Background jobs die when you log out — they receive SIGHUP when the shell exits.

**Prevent with `nohup`:**

```bash
nohup ./long-running-script.sh &
```

Redirects output to `nohup.out` and ignores SIGHUP.

**Or use `disown`:**

```bash
./script.sh &
disown %1
```

Removes the job from the shell's job table. It won't receive SIGHUP.

**Or use a terminal multiplexer:**

`tmux` or `screen` create persistent sessions:

```bash
tmux new -s chillspot
./long-running-script.sh
# Ctrl+B, then D to detach
```

Later:

```bash
tmux attach -t chillspot
```

Your session is exactly as you left it. This is the professional approach for long-running tasks on remote servers.

</div>
</details>

---

<details>
<summary><strong>6. Process Priority and Resource Limits</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Not all processes are equally important. You can influence how the kernel schedules CPU time and limit how much resources a process can consume.

### Nice values

The "nice" value affects scheduling priority. Range: -20 (highest priority) to 19 (lowest). Default is 0.

Higher nice = nicer to other processes = lower priority.

**Start a process with low priority:**

```bash
nice -n 10 ./cpu-intensive-task.sh
```

**Change priority of running process:**

```bash
renice 10 -p 1842
```

Only root can set negative nice values (higher priority).

### Viewing priorities

```bash
ps -eo pid,ni,cmd | head
```

The `ni` column shows nice value.

In `top`, the NI column shows nice value, PR shows actual priority.

### Resource limits with `ulimit`

Shells can limit resources for processes they spawn:

```bash
ulimit -a                    # Show all limits
ulimit -n                    # Max open files
ulimit -u                    # Max user processes
ulimit -v                    # Max virtual memory
```

**Set limits:**

```bash
ulimit -n 65535              # Allow more open files
ulimit -u 4096               # Allow more processes
```

These apply to the current shell and its children.

### Persistent limits

For system-wide or per-user limits, edit `/etc/security/limits.conf`:

```
chillspot    soft    nofile    65535
chillspot    hard    nofile    65535
chillspot    soft    nproc     4096
chillspot    hard    nproc     4096
```

Soft limits can be raised by the user up to the hard limit. Hard limits require root to change.

### systemd resource control

For services managed by systemd, set limits in the unit file:

```ini
[Service]
LimitNOFILE=65535
LimitNPROC=4096
MemoryMax=2G
CPUQuota=200%
```

More granular than traditional ulimits, and applied specifically to that service.

</div>
</details>

---

<details>
<summary><strong>7. systemd — The Modern Init System</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

On modern Linux distributions, systemd is PID 1 — the first process, the ancestor of all others. It boots the system, manages services, handles logging, and much more.

### What systemd replaced

Traditional Unix used SysV init scripts — shell scripts in `/etc/init.d/` that started services sequentially. It worked but was slow (no parallelism) and fragile (shell scripts are error-prone).

systemd introduces:

- **Parallelization** — Services start simultaneously when dependencies allow
- **On-demand activation** — Services start when needed (socket, path, timer)
- **Unified configuration** — Declarative unit files instead of shell scripts
- **Process tracking** — Uses cgroups to track all processes in a service
- **Logging integration** — Journal captures stdout/stderr automatically

### Units

systemd manages "units" — not just services, but various system resources:

| Unit Type | Extension | Purpose |
|-----------|-----------|---------|
| Service | `.service` | Daemons and one-shot tasks |
| Socket | `.socket` | Socket-based activation |
| Timer | `.timer` | Scheduled tasks (like cron) |
| Mount | `.mount` | Filesystem mount points |
| Target | `.target` | Groups of units (like runlevels) |
| Path | `.path` | Path-based activation |

### Where units live

- `/usr/lib/systemd/system/` — Units from packages (don't edit)
- `/etc/systemd/system/` — Local customizations (your changes go here)
- `/run/systemd/system/` — Runtime units (transient)

Local units in `/etc` override package units in `/usr/lib`.

### Targets

Targets group units together. They're roughly equivalent to runlevels:

| Target | Equivalent | Description |
|--------|------------|-------------|
| `poweroff.target` | Runlevel 0 | System halt |
| `rescue.target` | Runlevel 1 | Single-user rescue mode |
| `multi-user.target` | Runlevel 3 | Multi-user, no GUI |
| `graphical.target` | Runlevel 5 | Multi-user with GUI |
| `reboot.target` | Runlevel 6 | Reboot |

```bash
systemctl get-default              # Show default target
systemctl set-default multi-user.target   # Boot to multi-user
```

</div>
</details>

---

<details>
<summary><strong>8. Managing Services with systemctl</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

`systemctl` is your interface to systemd. You'll use it constantly.

### Basic service control

```bash
systemctl start nginx              # Start now
systemctl stop nginx               # Stop now
systemctl restart nginx            # Stop then start
systemctl reload nginx             # Reload config (if supported)
systemctl status nginx             # Show status and recent logs
```

### Enable and disable

Starting a service runs it now. Enabling makes it start at boot:

```bash
systemctl enable nginx             # Start at boot
systemctl disable nginx            # Don't start at boot
systemctl enable --now nginx       # Enable and start immediately
```

### Checking status

```bash
systemctl status chillspot-streaming
```

Output shows:

- Whether it's running (active) or not
- Main PID
- Memory and CPU usage
- Recent log entries
- How long it's been running

```
● chillspot-streaming.service - ChillSpot Streaming Service
     Loaded: loaded (/etc/systemd/system/chillspot-streaming.service; enabled)
     Active: active (running) since Mon 2024-03-15 10:30:00 UTC; 2h ago
   Main PID: 1842 (chillspot)
      Tasks: 12 (limit: 4096)
     Memory: 256M
        CPU: 5min 23s
     CGroup: /system.slice/chillspot-streaming.service
             └─1842 /srv/chillspot-streaming/app
```

### Listing services

```bash
systemctl list-units --type=service              # Running services
systemctl list-units --type=service --all        # All services
systemctl list-unit-files --type=service         # All installed services
```

### Checking failures

```bash
systemctl --failed                 # Show failed units
```

### Reloading systemd

After editing unit files:

```bash
systemctl daemon-reload            # Reload unit file changes
```

Always run this after modifying files in `/etc/systemd/system/`.

### Masking services

Disable completely, preventing even manual starts:

```bash
systemctl mask nginx               # Prevent starting entirely
systemctl unmask nginx             # Allow starting again
```

Useful when you want to ensure a service never runs.

</div>
</details>

---

<details>
<summary><strong>9. Writing systemd Unit Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When you deploy your own applications, you'll write unit files. Here's the structure.

### A complete service example

`/etc/systemd/system/chillspot-streaming.service`:

```ini
[Unit]
Description=ChillSpot Streaming Service
Documentation=https://docs.chillspot.internal
After=network.target postgresql.service
Wants=postgresql.service

[Service]
Type=simple
User=chillspot
Group=chillspot
WorkingDirectory=/srv/chillspot-streaming
ExecStart=/srv/chillspot-streaming/app --config /srv/chillspot-streaming/config/app.yaml
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
RestartSec=5
StandardOutput=journal
StandardError=journal
Environment=NODE_ENV=production
EnvironmentFile=-/srv/chillspot-streaming/config/env

[Install]
WantedBy=multi-user.target
```

### Section breakdown

**[Unit]** — Metadata and dependencies

| Directive | Purpose |
|-----------|---------|
| Description | Human-readable name |
| Documentation | URL to docs |
| After | Start after these units |
| Wants | Weak dependency — start these too |
| Requires | Strong dependency — fail if these fail |

**[Service]** — How to run it

| Directive | Purpose |
|-----------|---------|
| Type | simple, forking, oneshot, notify |
| User/Group | Run as this user |
| WorkingDirectory | Set working directory |
| ExecStart | Command to start |
| ExecReload | Command to reload |
| ExecStop | Command to stop (optional) |
| Restart | When to restart: always, on-failure, no |
| RestartSec | Seconds between restart attempts |
| Environment | Set environment variables |
| EnvironmentFile | Load env vars from file (- means optional) |

**[Install]** — How to enable it

| Directive | Purpose |
|-----------|---------|
| WantedBy | Enable as part of this target |

### Service types

**simple** — Default. Process in ExecStart is the main process.

**forking** — Traditional daemon. Forks and parent exits. Use PIDFile to track.

**oneshot** — Runs once and exits. Good for setup tasks.

**notify** — Like simple, but service signals when ready via sd_notify.

### After creating

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now chillspot-streaming
sudo systemctl status chillspot-streaming
```

### Overriding package units

Don't edit files in `/usr/lib/systemd/system/`. Instead, create overrides:

```bash
sudo systemctl edit nginx
```

This creates `/etc/systemd/system/nginx.service.d/override.conf`. Add only the directives you want to change:

```ini
[Service]
LimitNOFILE=65535
```

The override merges with the original.

</div>
</details>

---

## 10. Where We Go From Here

You now understand the living side of Linux. Processes are programs in motion — consuming resources, responding to signals, managed by systemd. You can see what's running, control it, prioritize it, and deploy your own services with proper unit files.

But processes need software to run, and that software needs to be installed, updated, and managed. Different distributions handle this differently, but the concepts are universal: repositories, packages, dependencies, and package managers.

File 05 covers **Package Management** — how software gets onto your system, how to keep it updated, and how to manage the dependency web that holds everything together.

Your system runs processes. Those processes run software. Let's learn where that software comes from.
