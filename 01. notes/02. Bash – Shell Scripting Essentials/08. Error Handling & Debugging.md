# **08. Error Handling & Debugging — Writing Robust, Maintainable Scripts**
> How to handle failures gracefully and debug issues efficiently.

---

## Table of Contents
- [1. Why Error Handling Matters](#1-why-error-handling-matters)
- [2. Exit Status and Return Codes](#2-exit-status-and-return-codes)
- [3. Strict Mode (set -e, -u, -o pipefail)](#3-strict-mode-set--e--u--o-pipefail)
- [4. Error Detection Patterns](#4-error-detection-patterns)
- [5. Trap and Cleanup](#5-trap-and-cleanup)
- [6. Logging and Error Messages](#6-logging-and-error-messages)
- [7. Debugging Techniques](#7-debugging-techniques)
- [8. Testing and Validation](#8-testing-and-validation)
- [9. Common Pitfalls](#9-common-pitfalls)
- [10. Best Practices](#10-best-practices)
- [11. Debugging Tools](#11-debugging-tools)
- [12. Real-World Scenarios](#12-real-world-scenarios)
- [13. Commands Reference](#13-commands-reference)
- [14. Quick Reference](#14-quick-reference)

---

<details>
<summary><strong>1. Why Error Handling Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Scripts fail. That's inevitable.

What matters is how they fail:
- Silently and corrupt data?
- Or loudly and leave things clean?

Good error handling means:
- failures are detected immediately
- error messages are clear and actionable
- cleanup always happens
- debugging is straightforward

Understanding error handling means:
- you can write production-ready scripts
- you can debug issues quickly
- you can prevent data corruption
- you can build reliable automation

This isn't about defensive programming paranoia.
It's about knowing what can go wrong — and handling it gracefully when it does.

</div>

</details>

---

<details>
<summary><strong>2. Exit Status and Return Codes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-357 — Understanding Exit Status

```bash copy
# Every command returns exit status
command
echo $?  # 0 = success, non-zero = failure

# Examples
ls /tmp
echo $?  # 0 (success)

ls /nonexistent
echo $?  # 2 (error)

grep pattern file.txt
echo $?  # 0 (found), 1 (not found), 2 (error)
```

**Convention:**
- 0 = success
- 1-255 = various failures
- 126 = command cannot execute
- 127 = command not found
- 128+N = terminated by signal N

---

### BASH-358 — Setting Exit Codes

```bash copy
#!/bin/bash
# Proper exit codes

# Success
exit 0

# Failure
exit 1

# Specific errors
readonly ERR_INVALID_ARGS=1
readonly ERR_FILE_NOT_FOUND=2
readonly ERR_PERMISSION_DENIED=3

if [ ! -f "$file" ]; then
    echo "File not found: $file" >&2
    exit $ERR_FILE_NOT_FOUND
fi
```

---

### BASH-359 — Checking Command Success

```bash copy
# Method 1: Check $?
command
if [ $? -eq 0 ]; then
    echo "Success"
fi

# Method 2: Use command directly (better)
if command; then
    echo "Success"
else
    echo "Failed"
fi

# Method 3: Short circuit
command && echo "Success" || echo "Failed"
```

---

### BASH-360 — Function Return Values

```bash copy
validate_file() {
    local file=$1
    
    [ ! -e "$file" ] && return 1
    [ ! -f "$file" ] && return 2
    [ ! -r "$file" ] && return 3
    
    return 0
}

# Use return value
if validate_file "data.txt"; then
    echo "File is valid"
else
    case $? in
        1) echo "File does not exist" ;;
        2) echo "Not a regular file" ;;
        3) echo "File not readable" ;;
    esac
fi
```

---

### BASH-361 — Exit on Error

```bash copy
#!/bin/bash

# Method 1: Manual check
command1 || exit 1
command2 || exit 1
command3 || exit 1

# Method 2: set -e (exit on any error)
set -e
command1
command2
command3
```

</div>

</details>

---

<details>
<summary><strong>3. Strict Mode (set -e, -u, -o pipefail)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-362 — set -e (errexit)

Exit immediately if any command fails:

```bash copy
#!/bin/bash
set -e

# Script exits if any command fails
command1
command2
command3
```

**Caveats:**
```bash copy
# Doesn't exit in these cases:
command || true          # OR prevents exit
if ! command; then       # In if condition
    :
fi

while ! command; do      # In while condition
    :
done
```

---

### BASH-363 — set -u (nounset)

Exit if undefined variable is used:

```bash copy
#!/bin/bash
set -u

# This fails with "unbound variable"
echo $undefined_var

# Safe access
echo "${undefined_var:-default}"
```

**Why use it:**
Catches typos and missing variables early.

---

### BASH-364 — set -o pipefail

Fail if any command in pipeline fails:

```bash copy
#!/bin/bash
set -o pipefail

# Without pipefail
false | true
echo $?  # 0 (success - only last command checked)

# With pipefail
set -o pipefail
false | true
echo $?  # 1 (failure detected)
```

---

### BASH-365 — Strict Mode Template

```bash copy
#!/bin/bash
#
# Production script template with strict mode
#

# Exit on error, undefined variables, and pipe failures
set -euo pipefail

# Optional: trace execution
# set -x

# Optional: inherit ERR trap
# set -E

echo "Script starting..."

# Your code here
```

---

### BASH-366 — Selective Strict Mode

```bash copy
#!/bin/bash
set -euo pipefail

# Temporarily disable set -e
set +e
command_that_may_fail
result=$?
set -e

if [ $result -ne 0 ]; then
    echo "Command failed as expected"
fi

# Temporarily disable set -u
set +u
value=${OPTIONAL_VAR}
set -u
```

---

### BASH-367 — Strict Mode with Functions

```bash copy
#!/bin/bash
set -euo pipefail

# Function inherits strict mode
risky_operation() {
    # This will exit script if it fails
    command_that_might_fail
}

# Unless you disable it
safe_operation() {
    set +e
    command_that_might_fail
    local status=$?
    set -e
    return $status
}
```

</div>

</details>

---

<details>
<summary><strong>4. Error Detection Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-368 — Validate Prerequisites

```bash copy
#!/bin/bash

# Check required commands
for cmd in curl jq aws; do
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: Required command not found: $cmd" >&2
        exit 1
    fi
done

# Check required files
for file in config.yaml data.json; do
    if [ ! -f "$file" ]; then
        echo "Error: Required file not found: $file" >&2
        exit 1
    fi
done

# Check required environment variables
for var in DATABASE_URL API_KEY; do
    if [ -z "${!var:-}" ]; then
        echo "Error: Required variable not set: $var" >&2
        exit 1
    fi
done
```

---

### BASH-369 — Validate Arguments

```bash copy
#!/bin/bash

validate_args() {
    if [ $# -lt 2 ]; then
        cat >&2 << EOF
Error: Missing required arguments

Usage: $0 <environment> <version>

Arguments:
    environment    Deployment environment (dev|staging|prod)
    version        Version to deploy (e.g., v1.2.3)

Example:
    $0 production v1.2.3
EOF
        return 1
    fi
    
    local env=$1
    local version=$2
    
    # Validate environment
    case $env in
        dev|staging|prod) ;;
        *)
            echo "Error: Invalid environment '$env'" >&2
            echo "Must be: dev, staging, or prod" >&2
            return 1
            ;;
    esac
    
    # Validate version format
    if [[ ! $version =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "Error: Invalid version format '$version'" >&2
        echo "Expected format: vX.Y.Z (e.g., v1.2.3)" >&2
        return 1
    fi
    
    return 0
}

# Use validation
if ! validate_args "$@"; then
    exit 1
fi
```

---

### BASH-370 — Check File Operations

```bash copy
#!/bin/bash

# Check before reading
if [ ! -r "$file" ]; then
    echo "Error: Cannot read file: $file" >&2
    exit 1
fi

# Check before writing
if [ ! -w "$directory" ]; then
    echo "Error: No write permission: $directory" >&2
    exit 1
fi

# Check disk space
available=$(df -k "$directory" | awk 'NR==2 {print $4}')
required=1000000  # 1GB in KB

if [ $available -lt $required ]; then
    echo "Error: Insufficient disk space" >&2
    echo "Available: $((available/1024))MB" >&2
    echo "Required: $((required/1024))MB" >&2
    exit 1
fi
```

---

### BASH-371 — Validate Command Output

```bash copy
#!/bin/bash

# Capture and validate
output=$(command 2>&1)
status=$?

if [ $status -ne 0 ]; then
    echo "Error: Command failed with status $status" >&2
    echo "Output: $output" >&2
    exit 1
fi

# Validate output content
if [ -z "$output" ]; then
    echo "Error: Command produced no output" >&2
    exit 1
fi

# Validate format
if ! echo "$output" | grep -q "expected_pattern"; then
    echo "Error: Unexpected output format" >&2
    echo "Output: $output" >&2
    exit 1
fi
```

---

### BASH-372 — Network Error Handling

```bash copy
#!/bin/bash

# HTTP request with error handling
make_request() {
    local url=$1
    local max_attempts=3
    local timeout=10
    
    for attempt in $(seq 1 $max_attempts); do
        echo "Attempt $attempt/$max_attempts..."
        
        if response=$(curl -sf --max-time $timeout "$url" 2>&1); then
            echo "$response"
            return 0
        fi
        
        if [ $attempt -lt $max_attempts ]; then
            sleep $((attempt * 2))
        fi
    done
    
    echo "Error: Failed to reach $url after $max_attempts attempts" >&2
    return 1
}
```

</div>

</details>

---

<details>
<summary><strong>5. Trap and Cleanup</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-373 — Basic Trap

```bash copy
#!/bin/bash

cleanup() {
    echo "Cleaning up..."
    rm -f /tmp/lockfile
    # More cleanup
}

# Trap EXIT (runs on any exit)
trap cleanup EXIT

# Script logic
echo "Running..."
sleep 5
```

---

### BASH-374 — Trap Multiple Signals

```bash copy
#!/bin/bash

cleanup() {
    local exit_code=$?
    echo "Cleanup (exit code: $exit_code)"
    
    # Clean temp files
    rm -rf "$temp_dir"
    
    # Kill background jobs
    jobs -p | xargs -r kill 2>/dev/null
    
    exit $exit_code
}

trap cleanup EXIT
trap 'exit 130' INT   # Ctrl+C
trap 'exit 143' TERM  # Termination

temp_dir=$(mktemp -d)
# Work...
```

---

### BASH-375 — Error Trap

```bash copy
#!/bin/bash
set -eE  # -E: inherit ERR trap

error_handler() {
    local line=$1
    echo "Error on line $line" >&2
    echo "Command: ${BASH_COMMAND}" >&2
    echo "Exit code: $?" >&2
    
    # Show context
    sed -n "$((line-2)),$((line+2))p" "$0" | \
        awk '{printf "%4s: %s\n", NR, $0}'
    
    exit 1
}

trap 'error_handler $LINENO' ERR

# Code that might fail
command1
command2
command3
```

---

### BASH-376 — Nested Traps

```bash copy
#!/bin/bash

outer_cleanup() {
    echo "Outer cleanup"
}

trap outer_cleanup EXIT

function_with_trap() {
    inner_cleanup() {
        echo "Inner cleanup"
    }
    
    trap inner_cleanup RETURN
    
    # Work...
}

function_with_trap
# Both cleanups will run
```

---

### BASH-377 — Trap with State

```bash copy
#!/bin/bash

# Track what needs cleanup
declare -a temp_files=()
declare -a background_pids=()

cleanup() {
    echo "Cleaning up..."
    
    # Remove temp files
    for file in "${temp_files[@]}"; do
        [ -f "$file" ] && rm "$file"
    done
    
    # Kill background processes
    for pid in "${background_pids[@]}"; do
        kill $pid 2>/dev/null || true
    done
}

trap cleanup EXIT

# Register resources
temp_file=$(mktemp)
temp_files+=("$temp_file")

long_process &
background_pids+=($!)
```

</div>

</details>

---

<details>
<summary><strong>6. Logging and Error Messages</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-378 — Structured Logging

```bash copy
#!/bin/bash

# Log levels
readonly LOG_ERROR=0
readonly LOG_WARN=1
readonly LOG_INFO=2
readonly LOG_DEBUG=3

# Current log level (set via environment)
LOG_LEVEL=${LOG_LEVEL:-$LOG_INFO}

log() {
    local level=$1
    shift
    local message="$@"
    
    if [ $level -le $LOG_LEVEL ]; then
        local level_name
        case $level in
            $LOG_ERROR) level_name="ERROR" ;;
            $LOG_WARN)  level_name="WARN"  ;;
            $LOG_INFO)  level_name="INFO"  ;;
            $LOG_DEBUG) level_name="DEBUG" ;;
        esac
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level_name] $message"
    fi
}

log_error() { log $LOG_ERROR "$@" >&2; }
log_warn()  { log $LOG_WARN "$@"; }
log_info()  { log $LOG_INFO "$@"; }
log_debug() { log $LOG_DEBUG "$@"; }

# Usage
log_info "Starting deployment"
log_debug "Configuration: $config"
log_warn "High memory usage detected"
log_error "Deployment failed"
```

---

### BASH-379 — Error Messages to stderr

```bash copy
#!/bin/bash

# Always send errors to stderr
error() {
    echo "ERROR: $@" >&2
}

warn() {
    echo "WARNING: $@" >&2
}

die() {
    error "$@"
    exit 1
}

# Usage
[ ! -f "$file" ] && die "File not found: $file"
[ ! -w "$dir" ] && die "No write permission: $dir"
```

---

### BASH-380 — Contextual Error Messages

```bash copy
#!/bin/bash

deploy() {
    local env=$1
    local version=$2
    
    log_info "Deploying $version to $env"
    
    if ! pull_image "$version"; then
        log_error "Failed to pull image: $version"
        log_error "Environment: $env"
        log_error "Registry: $DOCKER_REGISTRY"
        return 1
    fi
    
    if ! update_deployment "$env" "$version"; then
        log_error "Failed to update deployment"
        log_error "Environment: $env"
        log_error "Version: $version"
        log_error "Rollback may be required"
        return 1
    fi
    
    log_info "Deployment successful"
}
```

---

### BASH-381 — Log to File and Console

```bash copy
#!/bin/bash

log_file="/var/log/script.log"

# Redirect both stdout and stderr to file and console
exec > >(tee -a "$log_file")
exec 2>&1

echo "This goes to both console and log file"
echo "Errors too!" >&2

# Or log specific messages
log_and_echo() {
    echo "$@" | tee -a "$log_file"
}
```

</div>

</details>

---

<details>
<summary><strong>7. Debugging Techniques</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-382 — Enable Debug Mode

```bash copy
#!/bin/bash

# Method 1: Set in script
set -x  # Enable tracing
command1
command2
set +x  # Disable tracing

# Method 2: Run with bash -x
# bash -x script.sh

# Method 3: Debug flag
DEBUG=${DEBUG:-0}

debug() {
    [ "$DEBUG" = "1" ] && echo "DEBUG: $@" >&2
}

# Usage
debug "Variable value: $var"
DEBUG=1 ./script.sh
```

---

### BASH-383 — Conditional Debugging

```bash copy
#!/bin/bash

# Debug specific section
debug_section() {
    set -x
    "$@"
    { set +x; } 2>/dev/null
}

# Usage
debug_section command1
debug_section command2

# Or wrap complex operation
debug_section cat << EOF
Line 1
Line 2
EOF
```

---

### BASH-384 — Debug with PS4

```bash copy
#!/bin/bash
set -x

# Customize debug output
export PS4='+ ${BASH_SOURCE}:${LINENO}: '

# Shows: + script.sh:10: command

# More verbose
export PS4='+ ${BASH_SOURCE}:${LINENO}:${FUNCNAME[0]}: '

# Shows: + script.sh:10:function_name: command
```

---

### BASH-385 — Print Variable State

```bash copy
#!/bin/bash

# Debug helper
dump_vars() {
    echo "=== Variable Dump ===" >&2
    for var in "$@"; do
        echo "$var = ${!var}" >&2
    done
    echo "====================" >&2
}

# Usage
environment="production"
version="v1.2.3"
replicas=5

dump_vars environment version replicas
```

---

### BASH-386 — Trace Function Calls

```bash copy
#!/bin/bash

# Enable function tracing
set -T

trace_functions() {
    echo "Called: ${FUNCNAME[1]} from ${BASH_SOURCE[1]}:${BASH_LINENO[0]}" >&2
}

trap trace_functions DEBUG

function1() {
    echo "In function1"
}

function2() {
    echo "In function2"
    function1
}

function2
```

---

### BASH-387 — Interactive Debugging

```bash copy
#!/bin/bash

# Breakpoint function
breakpoint() {
    local line=${BASH_LINENO[0]}
    local file=${BASH_SOURCE[1]}
    
    echo "Breakpoint: $file:$line" >&2
    echo "Variables:" >&2
    echo "  \$@: $@" >&2
    
    # Print local variables
    local var
    while IFS='=' read -r var _; do
        [[ $var =~ ^[A-Z_]+$ ]] && continue  # Skip env vars
        echo "  $var = ${!var}" >&2
    done < <(compgen -v)
    
    read -p "Press Enter to continue..."
}

# Usage
function_to_debug() {
    local x=10
    local y=20
    
    breakpoint  # Execution pauses here
    
    echo $((x + y))
}
```

</div>

</details>

---

<details>
<summary><strong>8. Testing and Validation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-388 — Unit Testing Pattern

```bash copy
#!/bin/bash

# Test framework
tests_passed=0
tests_failed=0

assert_equals() {
    local expected=$1
    local actual=$2
    local test_name=$3
    
    if [ "$expected" = "$actual" ]; then
        echo "✓ PASS: $test_name"
        ((tests_passed++))
    else
        echo "✗ FAIL: $test_name" >&2
        echo "  Expected: $expected" >&2
        echo "  Actual: $actual" >&2
        ((tests_failed++))
    fi
}

# Test functions
test_add() {
    local result=$(add 2 3)
    assert_equals 5 "$result" "add 2 3"
}

test_subtract() {
    local result=$(subtract 5 2)
    assert_equals 3 "$result" "subtract 5 2"
}

# Run tests
test_add
test_subtract

# Summary
echo ""
echo "Tests passed: $tests_passed"
echo "Tests failed: $tests_failed"

[ $tests_failed -eq 0 ]
```

---

### BASH-389 — Integration Testing

```bash copy
#!/bin/bash

# Setup
setup() {
    test_dir=$(mktemp -d)
    export TEST_DIR=$test_dir
}

# Teardown
teardown() {
    rm -rf "$test_dir"
}

trap teardown EXIT
setup

# Test case
test_file_creation() {
    local file="$TEST_DIR/test.txt"
    
    # Execute
    create_file "$file"
    
    # Verify
    [ -f "$file" ] || {
        echo "FAIL: File not created" >&2
        return 1
    }
    
    local content=$(cat "$file")
    [ "$content" = "expected" ] || {
        echo "FAIL: Unexpected content" >&2
        return 1
    }
    
    echo "PASS: File creation"
}

test_file_creation
```

---

### BASH-390 — Dry Run Mode

```bash copy
#!/bin/bash

DRY_RUN=${DRY_RUN:-0}

execute() {
    if [ "$DRY_RUN" = "1" ]; then
        echo "[DRY RUN] Would execute: $@"
    else
        "$@"
    fi
}

# Usage
execute rm -rf /tmp/data
execute kubectl apply -f deployment.yaml

# Run in dry run mode
# DRY_RUN=1 ./script.sh
```

---

### BASH-391 — Validation Checklist

```bash copy
#!/bin/bash

validate() {
    local checks_passed=0
    local checks_failed=0
    
    # Check 1: Required commands
    echo "Checking required commands..."
    for cmd in curl jq aws; do
        if command -v "$cmd" &>/dev/null; then
            echo "  ✓ $cmd"
            ((checks_passed++))
        else
            echo "  ✗ $cmd not found" >&2
            ((checks_failed++))
        fi
    done
    
    # Check 2: Required files
    echo "Checking required files..."
    for file in config.yaml secrets.env; do
        if [ -f "$file" ]; then
            echo "  ✓ $file"
            ((checks_passed++))
        else
            echo "  ✗ $file not found" >&2
            ((checks_failed++))
        fi
    done
    
    # Check 3: Environment variables
    echo "Checking environment variables..."
    for var in DATABASE_URL API_KEY; do
        if [ -n "${!var:-}" ]; then
            echo "  ✓ $var"
            ((checks_passed++))
        else
            echo "  ✗ $var not set" >&2
            ((checks_failed++))
        fi
    done
    
    echo ""
    echo "Checks passed: $checks_passed"
    echo "Checks failed: $checks_failed"
    
    return $checks_failed
}

if ! validate; then
    echo "Validation failed" >&2
    exit 1
fi
```

</div>

</details>

---

<details>
<summary><strong>9. Common Pitfalls</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-392 — Unquoted Variables

```bash copy
# WRONG
file="my document.txt"
cat $file  # Tries to cat "my" and "document.txt"

# RIGHT
cat "$file"
```

---

### BASH-393 — Command Substitution in Conditions

```bash copy
# WRONG - command runs even if not needed
if [ "$var" = "value" ] && [ $(expensive_command) = "result" ]; then
    :
fi

# RIGHT - short-circuit evaluation
if [ "$var" = "value" ]; then
    if [ $(expensive_command) = "result" ]; then
        :
    fi
fi
```

---

### BASH-394 — Word Splitting in Loops

```bash copy
# WRONG
for file in $(ls *.txt); do
    process "$file"  # Breaks on spaces
done

# RIGHT
for file in *.txt; do
    process "$file"
done

# Or with find
while IFS= read -r file; do
    process "$file"
done < <(find . -name "*.txt")
```

---

### BASH-395 — Globbing Issues

```bash copy
# WRONG
files="*.txt"
rm $files  # Expands at assignment, not usage

# RIGHT
rm *.txt

# Or
files=(*.txt)
rm "${files[@]}"
```

---

### BASH-396 — Pipe Subshell Variable Loss

```bash copy
# WRONG - count stays 0
count=0
cat file.txt | while read line; do
    ((count++))
done
echo $count  # 0 (subshell!)

# RIGHT
count=0
while read line; do
    ((count++))
done < file.txt
echo $count  # Correct value
```

---

### BASH-397 — Missing Error Checks

```bash copy
# WRONG
cd /some/directory
rm -rf *  # Dangerous if cd failed!

# RIGHT
cd /some/directory || exit 1
rm -rf *

# Or
if cd /some/directory; then
    rm -rf *
fi
```

</div>

</details>

---

<details>
<summary><strong>10. Best Practices</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-398 — Script Template

```bash copy
#!/bin/bash
#
# script_name.sh - Brief description
#
# USAGE:
#   script_name.sh [OPTIONS] <args>
#
# OPTIONS:
#   -h, --help     Show this help
#   -v, --verbose  Verbose output
#   -d, --debug    Debug mode
#
# EXAMPLES:
#   script_name.sh production v1.2.3
#
# EXIT CODES:
#   0 - Success
#   1 - General error
#   2 - Invalid arguments
#
# AUTHOR: Your Name
# DATE: 2024-11-19

set -euo pipefail

# Constants
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

# Default values
VERBOSE=0
DEBUG=0

# Logging
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $@"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $@" >&2
}

log_debug() {
    [ $DEBUG -eq 1 ] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] [DEBUG] $@" >&2
}

# Cleanup
cleanup() {
    log_info "Cleaning up..."
    # Cleanup code here
}

trap cleanup EXIT

# Show help
show_help() {
    sed -n '/^#/!q;s/^# \?//p' "$0"
    exit 0
}

# Parse arguments
while [ $# -gt 0 ]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -d|--debug)
            DEBUG=1
            set -x
            shift
            ;;
        -*)
            log_error "Unknown option: $1"
            exit 2
            ;;
        *)
            break
            ;;
    esac
done

# Main function
main() {
    log_info "Script starting"
    
    # Your code here
    
    log_info "Script complete"
}

# Run
main "$@"
```

---

### BASH-399 — Error Handling Checklist

```bash copy
#!/bin/bash

# ✓ Shebang
#!/bin/bash

# ✓ Strict mode
set -euo pipefail

# ✓ Trap cleanup
trap cleanup EXIT

# ✓ Validate prerequisites
check_prerequisites() {
    # Commands
    # Files
    # Environment
}

# ✓ Validate arguments
validate_args() {
    # Count
    # Format
    # Values
}

# ✓ Check before operations
# File exists and readable
# Directory writable
# Sufficient disk space

# ✓ Meaningful error messages
log_error "Failed to X because Y"

# ✓ Proper exit codes
exit 1  # or specific error code

# ✓ Cleanup on exit
cleanup() {
    # Remove temp files
    # Kill background jobs
    # Restore state
}
```

---

### BASH-400 — Defensive Programming

```bash copy
#!/bin/bash

# Fail fast
set -euo pipefail

# Validate early
[ $# -lt 1 ] && die "Missing arguments"
[ ! -f "$file" ] && die "File not found: $file"

# Use readonly for constants
readonly MAX_RETRIES=3
readonly TIMEOUT=30

# Quote everything
echo "$var"
process "$file"

# Check before destructive operations
if [ -d "$target_dir" ]; then
    read -p "Delete $target_dir? (yes/no) " confirm
    [ "$confirm" = "yes" ] || exit 0
    rm -rf "$target_dir"
fi

# Use trap for cleanup
trap 'rm -f "$temp_file"' EXIT

# Check command success
if ! command; then
    log_error "Command failed"
    return 1
fi

# Validate output
result=$(command)
[ -z "$result" ] && die "Command produced no output"
```

</div>

</details>

---

<details>
<summary><strong>11. Debugging Tools</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-401 — ShellCheck

```bash copy
# Static analysis tool
shellcheck script.sh

# Common issues it catches:
# - Unquoted variables
# - Useless cat
# - Incorrect comparisons
# - Missing error checks
# - And many more

# Ignore specific warnings
# shellcheck disable=SC2086
variable_without_quotes=$variable
```

---

### BASH-402 — Bash Debugger (bashdb)

```bash copy
# Install bashdb
# Ubuntu: apt-get install bashdb
# macOS: brew install bashdb

# Run with debugger
bashdb script.sh

# Commands:
# s - step
# n - next
# c - continue
# l - list
# p var - print variable
# b line - set breakpoint
# q - quit
```

---

### BASH-403 — Profiling Scripts

```bash copy
#!/bin/bash

# Time entire script
time ./script.sh

# Time specific section
start=$(date +%s%N)
# ... code to profile ...
end=$(date +%s%N)
echo "Elapsed: $(((end - start) / 1000000))ms"

# Profile function calls
profile_function() {
    local func=$1
    shift
    
    local start=$(date +%s%N)
    $func "$@"
    local end=$(date +%s%N)
    
    echo "$func took $(((end - start) / 1000000))ms" >&2
}
```

---

### BASH-404 — Memory Usage Tracking

```bash copy
#!/bin/bash

track_memory() {
    local pid=$$
    
    while kill -0 $pid 2>/dev/null; do
        mem=$(ps -p $pid -o rss= | awk '{print $1/1024}')
        echo "$(date +%s) $mem" >> memory.log
        sleep 1
    done
}

# Start tracking in background
track_memory &
tracker_pid=$!

# Your script
# ...

# Stop tracking
kill $tracker_pid

# Analyze
echo "Peak memory usage:"
awk '{print $2}' memory.log | sort -n | tail -1
```

</div>

</details>

---

<details>
<summary><strong>12. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Robust Deployment Script

```bash copy
#!/bin/bash
#
# deploy.sh - Production deployment with comprehensive error handling
#

set -euo pipefail

# Constants
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_FILE="/var/log/deploy.log"
readonly LOCK_FILE="/var/run/deploy.lock"

# Exit codes
readonly ERR_INVALID_ARGS=1
readonly ERR_VALIDATION_FAILED=2
readonly ERR_DEPLOYMENT_FAILED=3
readonly ERR_ROLLBACK_FAILED=4

# Logging
log() {
    local level=$1
    shift
    local message="$@"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@" >&2; }
log_error() { log "ERROR" "$@" >&2; }

# Cleanup
cleanup() {
    local exit_code=$?
    
    log_info "Cleanup started (exit code: $exit_code)"
    
    # Remove lock file
    rm -f "$LOCK_FILE"
    
    # Kill background jobs
    jobs -p | xargs -r kill 2>/dev/null
    
    # Notification
    if [ $exit_code -eq 0 ]; then
        notify "Deployment successful"
    else
        notify "Deployment failed (exit code: $exit_code)"
    fi
    
    log_info "Cleanup complete"
    exit $exit_code
}

trap cleanup EXIT
trap 'exit 130' INT
trap 'exit 143' TERM

# Lock mechanism
acquire_lock() {
    if [ -f "$LOCK_FILE" ]; then
        local pid=$(cat "$LOCK_FILE")
        if kill -0 $pid 2>/dev/null; then
            log_error "Deployment already running (PID: $pid)"
            return 1
        fi
        log_warn "Removing stale lock file"
        rm -f "$LOCK_FILE"
    fi
    
    echo $$ > "$LOCK_FILE"
    log_info "Lock acquired"
}

# Validation
validate_environment() {
    local env=$1
    
    log_info "Validating environment: $env"
    
    case $env in
        dev|staging|production)
            log_info "Environment valid"
            ;;
        *)
            log_error "Invalid environment: $env"
            log_error "Must be: dev, staging, or production"
            return $ERR_INVALID_ARGS
            ;;
    esac
}

validate_version() {
    local version=$1
    
    log_info "Validating version: $version"
    
    if [[ ! $version =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log_error "Invalid version format: $version"
        log_error "Expected: vX.Y.Z (e.g., v1.2.3)"
        return $ERR_INVALID_ARGS
    fi
    
    log_info "Version valid"
}

check_prerequisites() {
    log_info "Checking prerequisites"
    
    local required_commands=(docker kubectl aws)
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            log_error "Required command not found: $cmd"
            return $ERR_VALIDATION_FAILED
        fi
        log_info "✓ $cmd available"
    done
    
    log_info "Prerequisites OK"
}

# Deployment steps
pull_image() {
    local version=$1
    local image="registry.example.com/myapp:$version"
    
    log_info "Pulling image: $image"
    
    local max_attempts=3
    for attempt in $(seq 1 $max_attempts); do
        if docker pull "$image"; then
            log_info "Image pulled successfully"
            return 0
        fi
        
        log_warn "Pull failed (attempt $attempt/$max_attempts)"
        if [ $attempt -lt $max_attempts ]; then
            sleep $((attempt * 2))
        fi
    done
    
    log_error "Failed to pull image after $max_attempts attempts"
    return $ERR_DEPLOYMENT_FAILED
}

update_deployment() {
    local env=$1
    local version=$2
    
    log_info "Updating deployment"
    
    if ! kubectl set image deployment/myapp \
        myapp="registry.example.com/myapp:$version" \
        --namespace="$env"; then
        log_error "Failed to update deployment"
        return $ERR_DEPLOYMENT_FAILED
    fi
    
    log_info "Deployment updated"
}

wait_for_rollout() {
    local env=$1
    local timeout=300
    
    log_info "Waiting for rollout (timeout: ${timeout}s)"
    
    if ! kubectl rollout status deployment/myapp \
        --namespace="$env" \
        --timeout="${timeout}s"; then
        log_error "Rollout failed or timed out"
        return $ERR_DEPLOYMENT_FAILED
    fi
    
    log_info "Rollout complete"
}

verify_deployment() {
    local env=$1
    
    log_info "Verifying deployment"
    
    local health_url="https://$env.example.com/health"
    local max_attempts=10
    
    for attempt in $(seq 1 $max_attempts); do
        if curl -sf "$health_url" &>/dev/null; then
            log_info "Health check passed"
            return 0
        fi
        
        log_warn "Health check failed (attempt $attempt/$max_attempts)"
        sleep 5
    done
    
    log_error "Health check failed after $max_attempts attempts"
    return $ERR_DEPLOYMENT_FAILED
}

rollback_deployment() {
    local env=$1
    
    log_error "Rolling back deployment"
    
    if ! kubectl rollout undo deployment/myapp \
        --namespace="$env"; then
        log_error "Rollback failed - manual intervention required!"
        return $ERR_ROLLBACK_FAILED
    fi
    
    log_info "Rollback initiated"
    
    if ! kubectl rollout status deployment/myapp \
        --namespace="$env" \
        --timeout=300s; then
        log_error "Rollback verification failed"
        return $ERR_ROLLBACK_FAILED
    fi
    
    log_info "Rollback complete"
}

# Notification
notify() {
    local message=$1
    log_info "Notification: $message"
    # Implement actual notification (Slack, email, etc.)
}

# Main deployment
deploy() {
    local env=$1
    local version=$2
    
    log_info "=== Deployment Started ==="
    log_info "Environment: $env"
    log_info "Version: $version"
    
    # Validate
    validate_environment "$env" || return $?
    validate_version "$version" || return $?
    check_prerequisites || return $?
    
    # Production confirmation
    if [ "$env" = "production" ]; then
        read -p "Deploy to PRODUCTION? Type 'yes' to confirm: " confirm
        if [ "$confirm" != "yes" ]; then
            log_info "Deployment cancelled"
            return 0
        fi
    fi
    
    # Deploy
    if ! pull_image "$version"; then
        log_error "Pull image failed"
        return $ERR_DEPLOYMENT_FAILED
    fi
    
    if ! update_deployment "$env" "$version"; then
        log_error "Update deployment failed"
        return $ERR_DEPLOYMENT_FAILED
    fi
    
    if ! wait_for_rollout "$env"; then
        log_error "Rollout failed"
        rollback_deployment "$env"
        return $ERR_DEPLOYMENT_FAILED
    fi
    
    if ! verify_deployment "$env"; then
        log_error "Verification failed"
        rollback_deployment "$env"
        return $ERR_DEPLOYMENT_FAILED
    fi
    
    log_info "=== Deployment Complete ==="
}

# Entry point
main() {
    if [ $# -ne 2 ]; then
        echo "Usage: $0 <environment> <version>" >&2
        echo "Example: $0 production v1.2.3" >&2
        return $ERR_INVALID_ARGS
    fi
    
    if ! acquire_lock; then
        return $ERR_VALIDATION_FAILED
    fi
    
    deploy "$1" "$2"
}

main "$@"
```

---

### Scenario 2: Self-Healing Script

```bash copy
#!/bin/bash
#
# self_healing.sh - Monitor and auto-recover from failures
#

set -euo pipefail

readonly LOG_FILE="/var/log/self-healing.log"
readonly STATE_FILE="/var/lib/self-healing/state"

# State tracking
declare -A failure_counts
declare -A last_restart_times

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $@" | tee -a "$LOG_FILE"
}

# Load state
load_state() {
    [ -f "$STATE_FILE" ] || return 0
    
    while IFS='=' read -r key value; do
        if [[ $key == failure_* ]]; then
            service=${key#failure_}
            failure_counts[$service]=$value
        elif [[ $key == restart_* ]]; then
            service=${key#restart_}
            last_restart_times[$service]=$value
        fi
    done < "$STATE_FILE"
}

# Save state
save_state() {
    mkdir -p "$(dirname "$STATE_FILE")"
    {
        for service in "${!failure_counts[@]}"; do
            echo "failure_$service=${failure_counts[$service]}"
        done
        for service in "${!last_restart_times[@]}"; do
            echo "restart_$service=${last_restart_times[$service]}"
        done
    } > "$STATE_FILE"
}

# Check service health
check_service() {
    local service=$1
    
    if systemctl is-active "$service" &>/dev/null; then
        return 0
    else
        return 1
    fi
}

# Restart with backoff
restart_service() {
    local service=$1
    local now=$(date +%s)
    
    # Get failure count
    local failures=${failure_counts[$service]:-0}
    local last_restart=${last_restart_times[$service]:-0}
    
    # Calculate backoff
    local backoff=$((2 ** failures))
    local min_interval=$((backoff * 60))
    
    # Check if enough time passed
    if ((now - last_restart < min_interval)); then
        log "Skipping restart of $service (backoff: ${backoff}m)"
        return 1
    fi
    
    log "Restarting $service (attempt $((failures + 1)))"
    
    if systemctl restart "$service"; then
        log "✓ $service restarted successfully"
        failure_counts[$service]=0
        last_restart_times[$service]=$now
        save_state
        return 0
    else
        log "✗ Failed to restart $service"
        ((failure_counts[$service]++))
        last_restart_times[$service]=$now
        save_state
        return 1
    fi
}

# Monitor and heal
monitor() {
    local -a services=(nginx postgresql redis)
    
    log "=== Health Check Started ==="
    
    for service in "${services[@]}"; do
        if check_service "$service"; then
            log "✓ $service is healthy"
            # Reset failure count on success
            if [ ${failure_counts[$service]:-0} -gt 0 ]; then
                failure_counts[$service]=0
                save_state
            fi
        else
            log "✗ $service is unhealthy"
            restart_service "$service"
        fi
    done
    
    log "=== Health Check Complete ==="
}

# Cleanup
cleanup() {
    log "Monitor stopped"
    save_state
}

trap cleanup EXIT INT TERM

# Main loop
main() {
    log "Self-healing monitor started"
    load_state
    
    while true; do
        monitor
        sleep 60
    done
}

main
```

---

### Scenario 3: Debug-Friendly Script Template

```bash copy
#!/bin/bash
#
# debug_template.sh - Script with comprehensive debugging support
#

set -euo pipefail

# Debug configuration
DEBUG=${DEBUG:-0}
TRACE=${TRACE:-0}

[ $TRACE -eq 1 ] && set -x

# Debug output
debug() {
    [ $DEBUG -eq 1 ] && echo "[DEBUG] $@" >&2
}

# Error tracking
error_handler() {
    local line=$1
    local command=$2
    local code=$3
    
    echo "ERROR on line $line" >&2
    echo "Command: $command" >&2
    echo "Exit code: $code" >&2
    echo "" >&2
    
    # Show context
    echo "Context:" >&2
    sed -n "$((line-3)),$((line+3))p" "$0" | \
        awk -v line=$line '{
            if (NR == line) 
                printf ">>> %4d: %s\n", NR, $0
            else
                printf "    %4d: %s\n", NR, $0
        }' >&2
    
    # Show variables
    echo "" >&2
    echo "Variables:" >&2
    local var
    for var in $(compgen -v); do
        [[ $var =~ ^(BASH_|FUNCNAME|_) ]] && continue
        printf "  %s = %s\n" "$var" "${!var}" >&2
    done | head -20
}

trap 'error_handler ${LINENO} "${BASH_COMMAND}" $?' ERR

# Function call tracking
CALL_DEPTH=0

function_enter() {
    ((CALL_DEPTH++))
    local indent=$(printf '%*s' $((CALL_DEPTH * 2)) '')
    debug "${indent}→ ${FUNCNAME[1]}($@)"
}

function_exit() {
    local indent=$(printf '%*s' $((CALL_DEPTH * 2)) '')
    debug "${indent}← ${FUNCNAME[1]} = $1"
    ((CALL_DEPTH--))
}

# Instrumented function example
instrumented_function() {
    function_enter "$@"
    
    local param1=$1
    local param2=$2
    
    debug "Processing: param1=$param1, param2=$param2"
    
    # Function logic
    local result=$((param1 + param2))
    
    function_exit "$result"
    return 0
}

# Variable dump
dump_env() {
    echo "=== Environment Dump ===" >&2
    env | sort | while IFS='=' read -r key value; do
        printf "%-30s = %s\n" "$key" "$value"
    done >&2
    echo "======================" >&2
}

# State checkpoint
checkpoint() {
    local name=$1
    debug "CHECKPOINT: $name"
    debug "  Variables: $(compgen -v | wc -l)"
    debug "  Functions: $(compgen -A function | wc -l)"
    debug "  Aliases: $(compgen -a | wc -l)"
}

# Main with debugging
main() {
    checkpoint "main_start"
    
    debug "Arguments: $@"
    debug "Working directory: $(pwd)"
    debug "Script directory: $(dirname "$0")"
    
    # Your logic here
    instrumented_function 10 20
    
    checkpoint "main_end"
}

# Usage examples
if [ $DEBUG -eq 1 ]; then
    echo "Debug mode enabled" >&2
    dump_env
fi

main "$@"
```

</div>

</details>

---

<details>
<summary><strong>13. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Strict mode
set -euo pipefail
```

```bash copy
# Enable debug tracing
set -x
```

```bash copy
# Check exit status
if command; then
    echo "Success"
fi
```

```bash copy
# Trap signals
trap 'cleanup' EXIT
trap 'handler' ERR
```

```bash copy
# Log to stderr
echo "Error message" >&2
```

```bash copy
# Die on error
die() {
    echo "ERROR: $@" >&2
    exit 1
}
```

```bash copy
# Validate command exists
command -v tool &>/dev/null || die "tool not found"
```

```bash copy
# Check file exists
[ -f file.txt ] || die "File not found"
```

```bash copy
# Debug output
debug() {
    [ "$DEBUG" = "1" ] && echo "DEBUG: $@" >&2
}
```

```bash copy
# Run with bash -x
bash -x script.sh
```

```bash copy
# ShellCheck static analysis
shellcheck script.sh
```

```bash copy
# Time execution
time ./script.sh
```

```bash copy
# Customize debug output
export PS4='+ ${BASH_SOURCE}:${LINENO}: '
set -x
```

</div>

</details>

---

<details>
<summary><strong>14. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Exit status 0 = success, non-zero = failure
- `set -e` exits on error
- `set -u` exits on undefined variables
- `set -o pipefail` fails if any command in pipe fails
- `trap` ensures cleanup happens
- Always send errors to stderr with `>&2`

---

**Strict Mode:**

| Setting | Effect |
|---------|--------|
| `set -e` | Exit on error |
| `set -u` | Exit on undefined variable |
| `set -o pipefail` | Fail on pipe error |
| `set -x` | Trace execution |
| `set -E` | Inherit ERR trap |

**Recommended:**
```bash copy
set -euo pipefail
```

---

**Exit Codes:**

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | General error |
| 2 | Misuse/invalid args |
| 126 | Cannot execute |
| 127 | Command not found |
| 130 | Terminated by Ctrl+C |
| 255 | Out of range |

---

**Trap Signals:**

| Signal | Use Case |
|--------|----------|
| EXIT | Always runs on exit |
| ERR | On command failure |
| INT | On Ctrl+C |
| TERM | On termination signal |
| RETURN | Function return |

---

**Common Patterns:**

```bash copy
# Strict mode
set -euo pipefail

# Cleanup trap
cleanup() {
    rm -f "$temp_file"
}
trap cleanup EXIT

# Error handler
error_handler() {
    echo "Error on line $LINENO" >&2
    exit 1
}
trap 'error_handler' ERR

# Validate prerequisites
for cmd in curl jq aws; do
    command -v "$cmd" &>/dev/null || die "$cmd not found"
done

# Check file
[ -f "$file" ] || die "File not found: $file"

# Logging
log_error() {
    echo "[ERROR] $@" >&2
}

# Debug mode
DEBUG=${DEBUG:-0}
debug() {
    [ $DEBUG -eq 1 ] && echo "DEBUG: $@" >&2
}
```

---

**Error Handling Checklist:**

- [ ] Use `set -euo pipefail`
- [ ] Set up `trap` for cleanup
- [ ] Validate all prerequisites
- [ ] Check command success
- [ ] Provide meaningful error messages
- [ ] Use proper exit codes
- [ ] Log to stderr for errors
- [ ] Quote all variables
- [ ] Check file operations
- [ ] Handle signals gracefully

---

**Debugging Techniques:**

| Technique | Command |
|-----------|---------|
| Trace execution | `set -x` or `bash -x` |
| Custom trace | `PS4='+ ${BASH_SOURCE}:${LINENO}: '` |
| Conditional debug | `[ $DEBUG = 1 ] && echo` |
| Static analysis | `shellcheck script.sh` |
| Function trace | `set -T; trap handler DEBUG` |
| Breakpoint | Read from stdin mid-script |

---

**Best Practices:**

1. **Start with strict mode**
   ```bash copy
   set -euo pipefail
   ```

2. **Always trap EXIT**
   ```bash copy
   trap cleanup EXIT
   ```

3. **Validate early**
   ```bash copy
   [ $# -eq 0 ] && die "Missing arguments"
   ```

4. **Check command success**
   ```bash copy
   command || die "Command failed"
   ```

5. **Meaningful errors**
   ```bash copy
   echo "Error: $reason (details: $context)" >&2
   ```

6. **Use readonly for constants**
   ```bash copy
   readonly MAX_RETRIES=3
   ```

7. **Quote everything**
   ```bash copy
   echo "$var"
   command "$file"
   ```

---

**What's Next:**
Now that you can handle errors and debug scripts, the next file covers advanced scripting techniques — command-line parsing, configuration management, and production patterns.

</div>

</details>

---