# **06. File Operations & I/O — Reading, Writing, and Managing Files**
> How to interact with the filesystem efficiently and safely.

---

## Table of Contents
- [1. Why File Operations Matter](#1-why-file-operations-matter)
- [2. Reading Files](#2-reading-files)
- [3. Writing Files](#3-writing-files)
- [4. File Descriptors](#4-file-descriptors)
- [5. Redirection](#5-redirection)
- [6. Pipes and Process Substitution](#6-pipes-and-process-substitution)
- [7. Here Documents and Here Strings](#7-here-documents-and-here-strings)
- [8. File Testing and Information](#8-file-testing-and-information)
- [9. File Manipulation](#9-file-manipulation)
- [10. Temporary Files](#10-temporary-files)
- [11. File Locking](#11-file-locking)
- [12. Real-World Scenarios](#12-real-world-scenarios)
- [13. Commands Reference](#13-commands-reference)
- [14. Quick Reference](#14-quick-reference)

---

<details>
<summary><strong>1. Why File Operations Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every automation task involves files.

Reading configurations? File I/O.
Writing logs? File I/O.
Processing data? File I/O.
Generating reports? File I/O.

Understanding file operations means:
- you can read and parse any file format
- you can write data safely and efficiently
- you can redirect output for logging and debugging
- you can handle files without race conditions

This isn't about memorizing commands.
It's about understanding how Bash interacts with files — so you can build robust scripts that handle data reliably.

</div>

</details>

---

<details>
<summary><strong>2. Reading Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-256 — Read Entire File

```bash copy
# Method 1: Command substitution
content=$(cat file.txt)
echo "$content"

# Method 2: Built-in (faster for small files)
content=$(<file.txt)
echo "$content"

# Method 3: mapfile (into array)
mapfile -t lines < file.txt
echo "${lines[@]}"
```

---

### BASH-257 — Read Line by Line

```bash copy
# Standard pattern
while IFS= read -r line; do
    echo "Line: $line"
done < file.txt

# With line numbers
line_num=0
while IFS= read -r line; do
    ((line_num++))
    echo "$line_num: $line"
done < file.txt
```

**Critical Pattern:**
- `IFS=` → preserves leading/trailing whitespace
- `-r` → prevents backslash interpretation
- `< file.txt` → redirects file as input (no subshell)

---

### BASH-258 — Read with Custom Delimiter

```bash copy
# CSV file
while IFS=',' read -r col1 col2 col3; do
    echo "Col1: $col1"
    echo "Col2: $col2"
    echo "Col3: $col3"
done < data.csv

# Colon-separated (like /etc/passwd)
while IFS=':' read -r user pass uid gid info home shell; do
    echo "User: $user (UID: $uid)"
done < /etc/passwd
```

---

### BASH-259 — Skip Lines

```bash copy
# Skip first line (header)
{
    read  # Skip header
    while IFS= read -r line; do
        echo "$line"
    done
} < file.txt

# Skip first N lines
{
    for i in {1..3}; do
        read  # Skip 3 lines
    done
    while IFS= read -r line; do
        echo "$line"
    done
} < file.txt
```

---

### BASH-260 — Read Until Pattern

```bash copy
# Read until marker
while IFS= read -r line; do
    [[ $line == "END" ]] && break
    echo "$line"
done < file.txt

# Read section between markers
in_section=false
while IFS= read -r line; do
    [[ $line == "START" ]] && in_section=true && continue
    [[ $line == "END" ]] && break
    $in_section && echo "$line"
done < file.txt
```

---

### BASH-261 — Read Into Array

```bash copy
# mapfile (readarray)
mapfile -t lines < file.txt
echo "Total lines: ${#lines[@]}"

# Process array
for line in "${lines[@]}"; do
    echo "$line"
done

# Skip empty lines
mapfile -t lines < <(grep -v '^$' file.txt)
```

---

### BASH-262 — Read Binary Files

```bash copy
# Read binary file safely
if [[ -f file.bin ]]; then
    # Check if binary
    if file file.bin | grep -q "text"; then
        echo "Text file"
    else
        echo "Binary file"
        # Process as binary
        hexdump -C file.bin | head
    fi
fi
```

</div>

</details>

---

<details>
<summary><strong>3. Writing Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-263 — Basic Writing

```bash copy
# Overwrite file
echo "Hello World" > file.txt

# Append to file
echo "New line" >> file.txt

# Multiple lines
cat > file.txt << EOF
Line 1
Line 2
Line 3
EOF
```

---

### BASH-264 — Write with printf

```bash copy
# Formatted output
printf "Name: %s\nAge: %d\n" "Alice" 30 > output.txt

# Append formatted
printf "Score: %.2f\n" 95.567 >> output.txt

# Table formatting
printf "%-20s %-10s %s\n" "Name" "Age" "Job" > table.txt
printf "%-20s %-10s %s\n" "Alice" "30" "Engineer" >> table.txt
printf "%-20s %-10s %s\n" "Bob" "25" "Designer" >> table.txt
```

---

### BASH-265 — Atomic Writes

```bash copy
# Write to temp file, then move (atomic)
temp_file=$(mktemp)
trap "rm -f '$temp_file'" EXIT

# Write data
echo "Important data" > "$temp_file"

# Validate
if [ -s "$temp_file" ]; then
    # Atomic move
    mv "$temp_file" /etc/config.conf
else
    echo "Write failed" >&2
    exit 1
fi
```

---

### BASH-266 — Safe File Updates

```bash copy
# Backup before writing
update_file() {
    local file=$1
    local content=$2
    
    # Create backup
    if [ -f "$file" ]; then
        cp "$file" "${file}.backup"
    fi
    
    # Write new content
    echo "$content" > "$file"
    
    # Verify
    if [ $? -ne 0 ]; then
        # Restore backup
        [ -f "${file}.backup" ] && mv "${file}.backup" "$file"
        return 1
    fi
    
    return 0
}

# Usage
if update_file "config.txt" "new content"; then
    echo "File updated successfully"
fi
```

---

### BASH-267 — Append with Timestamp

```bash copy
# Log function
log() {
    local log_file="/var/log/myapp.log"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $@" >> "$log_file"
}

# Usage
log "Application started"
log "Processing request"
log "Task completed"
```

---

### BASH-268 — Write Multiple Files

```bash copy
# Write to multiple files simultaneously
{
    echo "Line 1"
    echo "Line 2"
    echo "Line 3"
} | tee file1.txt file2.txt file3.txt > /dev/null

# With different content per file
echo "Content for file1" > file1.txt
echo "Content for file2" > file2.txt
echo "Content for file3" > file3.txt
```

</div>

</details>

---

<details>
<summary><strong>4. File Descriptors</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-269 — Understanding File Descriptors

```bash copy
# Standard file descriptors
# 0 = stdin  (standard input)
# 1 = stdout (standard output)
# 2 = stderr (standard error)

# Redirect stdout
command > output.txt          # fd 1 to file

# Redirect stderr
command 2> error.txt          # fd 2 to file

# Redirect both
command > output.txt 2>&1     # stderr to stdout, then stdout to file
command &> output.txt         # Both to file (Bash 4+)
```

---

### BASH-270 — Custom File Descriptors

```bash copy
# Open file descriptor 3 for reading
exec 3< input.txt

# Read from fd 3
while IFS= read -r line <&3; do
    echo "$line"
done

# Close fd 3
exec 3<&-

# Open fd 4 for writing
exec 4> output.txt

# Write to fd 4
echo "Line 1" >&4
echo "Line 2" >&4

# Close fd 4
exec 4>&-
```

---

### BASH-271 — Read and Write Same File

```bash copy
# Open file for both reading and writing
exec 3<> data.txt

# Read current content
cat <&3

# Write new content
echo "New line" >&3

# Close
exec 3>&-
```

---

### BASH-272 — Save and Restore stdout

```bash copy
# Save stdout to fd 6
exec 6>&1

# Redirect stdout to file
exec > output.txt

# Now all echo goes to file
echo "This goes to file"
echo "This too"

# Restore stdout
exec 1>&6

# Close fd 6
exec 6>&-

# Now echo goes to terminal again
echo "This goes to terminal"
```

---

### BASH-273 — Practical Use: Logging

```bash copy
#!/bin/bash
# Setup logging to file and terminal

log_file="/var/log/script.log"

# Redirect both stdout and stderr to log file and terminal
exec > >(tee -a "$log_file")
exec 2>&1

echo "Script started: $(date)"
echo "This appears in both terminal and log file"

# Run commands - all output logged
ls /nonexistent  # Error also logged
```

</div>

</details>

---

<details>
<summary><strong>5. Redirection</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-274 — Output Redirection

```bash copy
# Overwrite file
command > file.txt

# Append to file
command >> file.txt

# Redirect stderr
command 2> error.txt

# Redirect both stdout and stderr
command > output.txt 2>&1
command &> output.txt         # Bash 4+

# Append both
command >> output.txt 2>&1
command &>> output.txt        # Bash 4+
```

---

### BASH-275 — Input Redirection

```bash copy
# Read from file
command < input.txt

# Here document
command << EOF
line 1
line 2
EOF

# Here string
command <<< "single line input"
```

---

### BASH-276 — Discard Output

```bash copy
# Discard stdout
command > /dev/null

# Discard stderr
command 2> /dev/null

# Discard both
command > /dev/null 2>&1
command &> /dev/null

# Quiet execution
if command &> /dev/null; then
    echo "Command succeeded silently"
fi
```

---

### BASH-277 — Redirect to Multiple Destinations

```bash copy
# Using tee
command | tee output.txt              # stdout to file and terminal
command | tee -a output.txt           # append
command 2>&1 | tee output.txt         # include stderr

# Multiple files
command | tee file1.txt file2.txt file3.txt

# To file and pipe
command | tee output.txt | grep pattern
```

---

### BASH-278 — Conditional Redirection

```bash copy
# Redirect only if file doesn't exist
[ ! -f output.txt ] && command > output.txt

# Redirect based on condition
if [ "$DEBUG" = "1" ]; then
    command > debug.log 2>&1
else
    command > /dev/null 2>&1
fi
```

---

### BASH-279 — Redirect in Functions

```bash copy
# Redirect function output
log_and_run() {
    local log_file="$1"
    shift
    
    {
        echo "=== $(date) ==="
        echo "Command: $@"
        "$@"
        echo "Exit code: $?"
        echo ""
    } >> "$log_file" 2>&1
}

# Usage
log_and_run "command.log" ls -la /tmp
```

</div>

</details>

---

<details>
<summary><strong>6. Pipes and Process Substitution</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-280 — Basic Pipes

```bash copy
# Chain commands
cat file.txt | grep pattern | sort | uniq

# With redirection
cat file.txt | grep pattern > matches.txt

# Multiple pipes
ps aux | grep nginx | awk '{print $2}' | xargs kill
```

---

### BASH-281 — Process Substitution

```bash copy
# Compare output of two commands
diff <(ls dir1) <(ls dir2)

# Read from process
while IFS= read -r line; do
    echo "$line"
done < <(find /var/log -name "*.log")

# Multiple inputs
paste <(seq 1 5) <(seq 6 10)
```

---

### BASH-282 — Named Pipes (FIFOs)

```bash copy
# Create named pipe
mkfifo mypipe

# Write to pipe (in background)
echo "Hello" > mypipe &

# Read from pipe
cat mypipe
```

---

### BASH-283 — Pipefail

```bash copy
# Without pipefail - only last command status matters
false | true
echo $?  # 0 (success)

# With pipefail - any failure fails the pipeline
set -o pipefail
false | true
echo $?  # 1 (failure)

# Use in scripts for better error detection
set -euo pipefail
```

---

### BASH-284 — Pipeline Patterns

```bash copy
# Filter and transform
cat access.log | \
    grep "GET" | \
    awk '{print $7}' | \
    sort | \
    uniq -c | \
    sort -rn | \
    head -10

# Process in parallel
find . -name "*.txt" | \
    xargs -P 4 -I {} bash -c 'process_file "$@"' _ {}
```

</div>

</details>

---

<details>
<summary><strong>7. Here Documents and Here Strings</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-285 — Here Documents

```bash copy
# Basic here document
cat << EOF
Line 1
Line 2
Line 3
EOF

# Write to file
cat > config.txt << EOF
host=localhost
port=5432
database=myapp
EOF

# With variable expansion
name="Alice"
cat << EOF
Hello, $name!
Today is $(date)
EOF
```

---

### BASH-286 — Quoted Here Documents

```bash copy
# Prevent variable expansion (quote delimiter)
cat << 'EOF'
Price: $100
Variable: $variable
Command: $(date)
EOF

# Output:
# Price: $100
# Variable: $variable
# Command: $(date)
```

---

### BASH-287 — Indented Here Documents

```bash copy
# Remove leading tabs (use <<-)
if true; then
    cat <<- EOF
		Line 1
		Line 2
		Line 3
	EOF
fi

# Note: Must use tabs, not spaces
```

---

### BASH-288 — Here Strings

```bash copy
# Pass string as input
grep "pattern" <<< "some text to search"

# With variables
text="Hello World"
grep "World" <<< "$text"

# In while loop
while IFS= read -r line; do
    echo "$line"
done <<< "Line 1
Line 2
Line 3"
```

---

### BASH-289 — Multi-line Scripts

```bash copy
# Generate script with here document
cat > script.sh << 'EOF'
#!/bin/bash
set -euo pipefail

echo "Generated script"
date
EOF

chmod +x script.sh

# Generate configuration
cat > /etc/myapp/config.conf << EOF
# Generated on $(date)
SERVER_HOST=$(hostname)
SERVER_PORT=8080
DATABASE_URL=$DATABASE_URL
EOF
```

---

### BASH-290 — Here Document with Functions

```bash copy
# Create file with function
create_config() {
    local env=$1
    local file="config.${env}.conf"
    
    cat > "$file" << EOF
# Configuration for $env environment
# Generated: $(date)

[database]
host=db-${env}.example.com
port=5432
name=myapp_${env}

[server]
host=0.0.0.0
port=8080
workers=4
EOF
    
    echo "Created: $file"
}

# Usage
create_config production
```

</div>

</details>

---

<details>
<summary><strong>8. File Testing and Information</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-291 — File Existence Tests

```bash copy
# File exists (any type)
[ -e file.txt ] && echo "Exists"

# Regular file
[ -f file.txt ] && echo "Regular file"

# Directory
[ -d /path/to/dir ] && echo "Directory"

# Symbolic link
[ -L link ] && echo "Symbolic link"

# Named pipe
[ -p mypipe ] && echo "Named pipe"

# Socket
[ -S /var/run/docker.sock ] && echo "Socket"
```

---

### BASH-292 — File Properties

```bash copy
# File is empty
[ -s file.txt ] && echo "Not empty" || echo "Empty"

# File is readable
[ -r file.txt ] && echo "Readable"

# File is writable
[ -w file.txt ] && echo "Writable"

# File is executable
[ -x script.sh ] && echo "Executable"

# File owned by user
[ -O file.txt ] && echo "I own this"

# File owned by group
[ -G file.txt ] && echo "My group owns this"
```

---

### BASH-293 — File Comparisons

```bash copy
# file1 newer than file2
[ file1.txt -nt file2.txt ] && echo "file1 is newer"

# file1 older than file2
[ file1.txt -ot file2.txt ] && echo "file1 is older"

# Same file (hard links)
[ file1.txt -ef file2.txt ] && echo "Same file"
```

---

### BASH-294 — File Information

```bash copy
# Get file size
size=$(stat -f%z file.txt 2>/dev/null || stat -c%s file.txt)
echo "Size: $size bytes"

# Get modification time
mtime=$(stat -f%m file.txt 2>/dev/null || stat -c%Y file.txt)
echo "Modified: $(date -r $mtime)"

# Get file type
file_type=$(file -b file.txt)
echo "Type: $file_type"

# Get permissions
perms=$(stat -f%A file.txt 2>/dev/null || stat -c%a file.txt)
echo "Permissions: $perms"
```

---

### BASH-295 — Check Multiple Conditions

```bash copy
# File exists and is readable
if [ -f file.txt ] && [ -r file.txt ]; then
    echo "File exists and is readable"
fi

# Using [[]]
if [[ -f file.txt && -r file.txt ]]; then
    echo "File exists and is readable"
fi

# Check before processing
validate_file() {
    local file=$1
    
    [ ! -e "$file" ] && echo "File not found" && return 1
    [ ! -f "$file" ] && echo "Not a regular file" && return 1
    [ ! -r "$file" ] && echo "Not readable" && return 1
    [ ! -s "$file" ] && echo "File is empty" && return 1
    
    return 0
}
```

</div>

</details>

---

<details>
<summary><strong>9. File Manipulation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-296 — Copy Files

```bash copy
# Basic copy
cp source.txt destination.txt

# Copy with options
cp -i source.txt dest.txt     # Interactive (confirm overwrite)
cp -v source.txt dest.txt     # Verbose
cp -p source.txt dest.txt     # Preserve attributes

# Copy directory
cp -r source_dir dest_dir

# Copy multiple files
cp file1.txt file2.txt file3.txt /destination/

# Backup while copying
cp --backup=numbered file.txt dest.txt
```

---

### BASH-297 — Move and Rename

```bash copy
# Rename file
mv oldname.txt newname.txt

# Move file
mv file.txt /destination/

# Move with options
mv -i file.txt dest.txt       # Interactive
mv -v file.txt dest.txt       # Verbose

# Move multiple files
mv file1.txt file2.txt file3.txt /destination/
```

---

### BASH-298 — Remove Files

```bash copy
# Remove file
rm file.txt

# Remove with confirmation
rm -i file.txt

# Force remove
rm -f file.txt

# Remove directory
rm -r directory/
rm -rf directory/              # Force recursive

# Remove empty directory
rmdir directory/
```

---

### BASH-299 — Create Files and Directories

```bash copy
# Create empty file
touch file.txt

# Create directory
mkdir directory

# Create nested directories
mkdir -p path/to/nested/directory

# Create with specific permissions
mkdir -m 755 directory

# Create multiple directories
mkdir dir1 dir2 dir3
```

---

### BASH-300 — Links

```bash copy
# Hard link
ln source.txt hardlink.txt

# Symbolic link
ln -s source.txt symlink.txt

# Symbolic link to directory
ln -s /path/to/dir linkname

# Force symbolic link (overwrite if exists)
ln -sf source.txt symlink.txt

# Check if symlink
if [ -L symlink.txt ]; then
    target=$(readlink symlink.txt)
    echo "Points to: $target"
fi
```

---

### BASH-301 — File Permissions

```bash copy
# Change permissions (numeric)
chmod 644 file.txt            # rw-r--r--
chmod 755 script.sh           # rwxr-xr-x

# Change permissions (symbolic)
chmod u+x script.sh           # Add execute for user
chmod g+w file.txt            # Add write for group
chmod o-r file.txt            # Remove read for others

# Change ownership
chown user:group file.txt
chown user file.txt
chgrp group file.txt

# Recursive
chmod -R 755 directory/
chown -R user:group directory/
```

---

### BASH-302 — Find and Process Files

```bash copy
# Find files
find /path -name "*.txt"
find /path -type f -name "*.log"
find /path -type d -name "cache"

# Find and execute
find /path -name "*.tmp" -delete
find /path -name "*.log" -exec gzip {} \;

# Find by age
find /path -mtime +30             # Older than 30 days
find /path -mtime -7              # Newer than 7 days

# Find by size
find /path -size +100M            # Larger than 100MB
find /path -size -1M              # Smaller than 1MB
```

</div>

</details>

---

<details>
<summary><strong>10. Temporary Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-303 — Create Temporary Files

```bash copy
# Create temp file
temp_file=$(mktemp)
echo "Using temp file: $temp_file"

# Create temp file with template
temp_file=$(mktemp /tmp/myapp.XXXXXX)

# Create temp directory
temp_dir=$(mktemp -d)
echo "Using temp dir: $temp_dir"
```

---

### BASH-304 — Cleanup Temporary Files

```bash copy
#!/bin/bash
# Automatic cleanup with trap

temp_file=$(mktemp)
temp_dir=$(mktemp -d)

# Setup cleanup
cleanup() {
    rm -f "$temp_file"
    rm -rf "$temp_dir"
}

trap cleanup EXIT

# Use temp files
echo "Working..." > "$temp_file"
cd "$temp_dir"

# Cleanup happens automatically on exit
```

---

### BASH-305 — Secure Temporary Files

```bash copy
# Create temp file with restricted permissions
temp_file=$(mktemp)
chmod 600 "$temp_file"  # Owner read/write only

# Write sensitive data
echo "password=secret" > "$temp_file"

# Process
process_sensitive_data "$temp_file"

# Cleanup
shred -u "$temp_file"  # Secure delete
```

---

### BASH-306 — Temporary File Patterns

```bash copy
#!/bin/bash
# Process data in temp file

process_data() {
    local input=$1
    local temp=$(mktemp)
    
    # Ensure cleanup
    trap "rm -f '$temp'" RETURN
    
    # Transform data
    transform_data "$input" > "$temp"
    
    # Validate
    if validate_data "$temp"; then
        # Move to final location
        mv "$temp" "${input}.processed"
    else
        echo "Validation failed" >&2
        return 1
    fi
}
```

</div>

</details>

---

<details>
<summary><strong>11. File Locking</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-307 — Simple Lock Files

```bash copy
#!/bin/bash
# Prevent multiple instances

lock_file="/var/run/myscript.lock"

# Check if already running
if [ -f "$lock_file" ]; then
    echo "Script is already running" >&2
    exit 1
fi

# Create lock file
echo $$ > "$lock_file"

# Cleanup on exit
trap "rm -f '$lock_file'" EXIT

# Do work
echo "Script running..."
sleep 10
```

---

### BASH-308 — PID-Based Locking

```bash copy
#!/bin/bash
# Lock with PID validation

lock_file="/var/run/myscript.lock"

acquire_lock() {
    # Check if lock exists
    if [ -f "$lock_file" ]; then
        # Get PID from lock file
        old_pid=$(cat "$lock_file")
        
        # Check if process is still running
        if kill -0 "$old_pid" 2>/dev/null; then
            echo "Script already running (PID: $old_pid)" >&2
            return 1
        else
            echo "Removing stale lock file"
            rm -f "$lock_file"
        fi
    fi
    
    # Create lock
    echo $$ > "$lock_file"
    return 0
}

release_lock() {
    rm -f "$lock_file"
}

# Main script
if ! acquire_lock; then
    exit 1
fi

trap release_lock EXIT

# Do work
echo "Script running (PID: $$)"
sleep 10
```

---

### BASH-309 — Flock-Based Locking

```bash copy
#!/bin/bash
# Robust locking with flock

lock_file="/var/run/myscript.lock"

# Exclusive lock
exec 200>"$lock_file"
if ! flock -n 200; then
    echo "Could not acquire lock" >&2
    exit 1
fi

# Lock acquired - do work
echo "Script running with exclusive lock"
sleep 10

# Lock released automatically on exit
```

---

### BASH-310 — Timed Lock

```bash copy
#!/bin/bash
# Try to acquire lock with timeout

lock_file="/var/run/myscript.lock"

# Try for 10 seconds
exec 200>"$lock_file"
if ! flock -w 10 200; then
    echo "Could not acquire lock within 10 seconds" >&2
    exit 1
fi

echo "Lock acquired"
# Do work
```

---

### BASH-311 — Shared vs Exclusive Locks

```bash copy
#!/bin/bash
# Multiple readers, single writer

lock_file="/var/run/data.lock"

read_data() {
    # Shared lock (multiple readers OK)
    exec 200>"$lock_file"
    flock -s 200
    
    # Read data
    cat data.txt
    
    # Lock released when fd 200 closes
}

write_data() {
    # Exclusive lock (no other readers or writers)
    exec 200>"$lock_file"
    flock -x 200
    
    # Write data
    echo "new data" >> data.txt
}
```

</div>

</details>

---

<details>
<summary><strong>12. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Log Rotation Script

```bash copy
#!/bin/bash
# rotate_logs.sh - Rotate and compress log files

set -euo pipefail

log_file=${1:?"Log file required"}
max_size=${2:-104857600}  # 100MB default
keep_rotations=${3:-5}

# Check if log exists
if [[ ! -f "$log_file" ]]; then
    echo "Log file not found: $log_file" >&2
    exit 1
fi

# Get current size
current_size=$(stat -c%s "$log_file" 2>/dev/null || stat -f%z "$log_file")

echo "Log file: $log_file"
echo "Current size: $((current_size / 1024 / 1024))MB"
echo "Max size: $((max_size / 1024 / 1024))MB"

# Check if rotation needed
if [[ $current_size -lt $max_size ]]; then
    echo "Rotation not needed"
    exit 0
fi

echo "Starting rotation..."

# Get base name and directory
log_dir=$(dirname "$log_file")
log_name=$(basename "$log_file")

# Rotate existing logs
for ((i = keep_rotations - 1; i >= 1; i--)); do
    old_log="${log_dir}/${log_name}.${i}.gz"
    new_log="${log_dir}/${log_name}.$((i + 1)).gz"
    
    if [[ -f "$old_log" ]]; then
        mv "$old_log" "$new_log"
        echo "Rotated: $(basename "$old_log") -> $(basename "$new_log")"
    fi
done

# Rotate current log
rotated="${log_dir}/${log_name}.1"

# Use temporary file for atomic operation
temp_log=$(mktemp)
trap "rm -f '$temp_log'" EXIT

# Move current log to temp
if mv "$log_file" "$temp_log"; then
    # Create new empty log
    touch "$log_file"
    
    # Copy permissions
    chmod --reference="$temp_log" "$log_file" 2>/dev/null || \
    chmod $(stat -c%a "$temp_log" 2>/dev/null || stat -f%A "$temp_log") "$log_file"
    
    # Compress rotated log
    gzip -c "$temp_log" > "${rotated}.gz"
    
    echo "✓ Rotated and compressed: ${log_name}.1.gz"
else
    echo "✗ Failed to rotate log" >&2
    exit 1
fi

# Remove oldest rotation
oldest="${log_dir}/${log_name}.$((keep_rotations + 1)).gz"
if [[ -f "$oldest" ]]; then
    rm "$oldest"
    echo "Removed oldest: $(basename "$oldest")"
fi

# Summary
total_size=0
count=0

for rotated_log in "${log_dir}/${log_name}".*.gz; do
    [[ -f "$rotated_log" ]] || continue
    size=$(stat -c%s "$rotated_log" 2>/dev/null || stat -f%z "$rotated_log")
    ((total_size += size))
    ((count++))
done

echo ""
echo "=== Rotation Complete ==="
echo "Total rotated logs: $count"
echo "Total size: $((total_size / 1024 / 1024))MB"
```

---

### Scenario 2: Configuration File Manager

```bash copy
#!/bin/bash
# config_sync.sh - Sync and validate configuration files

set -euo pipefail

source_dir=${1:?"Source directory required"}
dest_dir=${2:?"Destination directory required"}

# Validate directories
[[ ! -d "$source_dir" ]] && echo "Source not found: $source_dir" >&2 && exit 1
[[ ! -d "$dest_dir" ]] && echo "Destination not found: $dest_dir" >&2 && exit 1

echo "=== Configuration Sync ==="
echo "Source: $source_dir"
echo "Destination: $dest_dir"
echo ""

# Backup function
backup_file() {
    local file=$1
    local backup="${file}.backup-$(date +%Y%m%d-%H%M%S)"
    cp "$file" "$backup"
    echo "  Backup created: $(basename "$backup")"
}

# Validate configuration
validate_config() {
    local file=$1
    
    # Check syntax based on file type
    case "$file" in
        *.json)
            if command -v jq &>/dev/null; then
                jq empty "$file" 2>/dev/null
            else
                python -m json.tool "$file" &>/dev/null
            fi
            ;;
        *.yaml|*.yml)
            if command -v yamllint &>/dev/null; then
                yamllint -d relaxed "$file" &>/dev/null
            fi
            ;;
        *.xml)
            if command -v xmllint &>/dev/null; then
                xmllint --noout "$file" &>/dev/null
            fi
            ;;
    esac
}

# Process each config file
updated=0
failed=0

while IFS= read -r source_file; do
    rel_path=${source_file#$source_dir/}
    dest_file="${dest_dir}/${rel_path}"
    
    echo "Processing: $rel_path"
    
    # Validate source file
    if ! validate_config "$source_file"; then
        echo "  ✗ Validation failed"
        ((failed++))
        continue
    fi
    
    echo "  ✓ Validation passed"
    
    # Check if destination exists
    if [[ -f "$dest_file" ]]; then
        # Compare files
        if cmp -s "$source_file" "$dest_file"; then
            echo "  = No changes"
            continue
        fi
        
        # Backup existing file
        backup_file "$dest_file"
    else
        # Create directory structure
        mkdir -p "$(dirname "$dest_file")"
    fi
    
    # Copy file
    if cp "$source_file" "$dest_file"; then
        echo "  ✓ Updated"
        ((updated++))
        
        # Set permissions
        chmod 644 "$dest_file"
    else
        echo "  ✗ Copy failed"
        ((failed++))
    fi
    
    echo ""
done < <(find "$source_dir" -type f -name "*.conf" -o -name "*.json" -o -name "*.yaml" -o -name "*.yml")

# Summary
echo "=== Sync Complete ==="
echo "Updated: $updated"
echo "Failed: $failed"

[[ $failed -gt 0 ]] && exit 1
exit 0
```

---

### Scenario 3: File Integrity Monitor

```bash copy
#!/bin/bash
# file_monitor.sh - Monitor files for changes

set -euo pipefail

watch_dir=${1:-"/etc"}
checksum_file="/var/lib/file-monitor/checksums.txt"

mkdir -p "$(dirname "$checksum_file")"

# Generate checksums
generate_checksums() {
    local dir=$1
    local output=$2
    
    find "$dir" -type f -exec sha256sum {} \; | sort > "$output"
}

# Compare checksums
compare_checksums() {
    local old=$1
    local new=$2
    
    # Files added
    echo "=== Added Files ==="
    comm -13 <(cut -d' ' -f2- "$old" | sort) <(cut -d' ' -f2- "$new" | sort) | \
    while IFS= read -r file; do
        echo "  + $file"
    done
    
    # Files removed
    echo ""
    echo "=== Removed Files ==="
    comm -23 <(cut -d' ' -f2- "$old" | sort) <(cut -d' ' -f2- "$new" | sort) | \
    while IFS= read -r file; do
        echo "  - $file"
    done
    
    # Files modified
    echo ""
    echo "=== Modified Files ==="
    
    while IFS= read -r checksum file; do
        old_checksum=$(grep -F "$file" "$old" | cut -d' ' -f1)
        
        if [[ -n "$old_checksum" && "$checksum" != "$old_checksum" ]]; then
            echo "  M $file"
            echo "    Old: $old_checksum"
            echo "    New: $checksum"
        fi
    done < "$new"
}

# Initialize or check
if [[ ! -f "$checksum_file" ]]; then
    echo "Initializing file monitor for: $watch_dir"
    generate_checksums "$watch_dir" "$checksum_file"
    echo "Baseline created: $checksum_file"
    exit 0
fi

echo "Checking for changes in: $watch_dir"

# Generate current checksums
current_checksums=$(mktemp)
trap "rm -f '$current_checksums'" EXIT

generate_checksums "$watch_dir" "$current_checksums"

# Compare
if ! diff -q "$checksum_file" "$current_checksums" &>/dev/null; then
    echo "Changes detected!"
    echo ""
    compare_checksums "$checksum_file" "$current_checksums"
    
    # Update baseline
    read -p "Update baseline? (yes/no): " response
    if [[ "$response" == "yes" ]]; then
        mv "$current_checksums" "$checksum_file"
        echo "Baseline updated"
    fi
else
    echo "No changes detected"
fi
```

---

### Scenario 4: Atomic File Updates

```bash copy
#!/bin/bash
# atomic_update.sh - Safely update files with rollback

set -euo pipefail

update_file_atomic() {
    local target=$1
    local content=$2
    
    # Validate target
    if [[ -z "$target" ]]; then
        echo "Target file required" >&2
        return 1
    fi
    
    echo "Updating: $target"
    
    # Create backup if file exists
    local backup=""
    if [[ -f "$target" ]]; then
        backup="${target}.backup-$(date +%Y%m%d-%H%M%S)"
        cp "$target" "$backup"
        echo "  Backup: $backup"
    fi
    
    # Write to temporary file
    local temp=$(mktemp)
    trap "rm -f '$temp'" RETURN
    
    echo "$content" > "$temp"
    
    # Validate content if validator provided
    if [[ -n "${VALIDATOR:-}" ]]; then
        echo "  Validating..."
        if ! $VALIDATOR "$temp"; then
            echo "  ✗ Validation failed" >&2
            [[ -n "$backup" ]] && rm "$backup"
            return 1
        fi
        echo "  ✓ Validation passed"
    fi
    
    # Atomic move
    if mv "$temp" "$target"; then
        echo "  ✓ Update successful"
        
        # Set permissions
        if [[ -n "$backup" ]]; then
            chmod --reference="$backup" "$target" 2>/dev/null || \
            chmod $(stat -c%a "$backup" 2>/dev/null || stat -f%A "$backup") "$target"
        else
            chmod 644 "$target"
        fi
        
        # Cleanup old backup
        [[ -n "$backup" ]] && rm "$backup"
        return 0
    else
        echo "  ✗ Update failed" >&2
        # Restore backup
        [[ -n "$backup" ]] && mv "$backup" "$target"
        return 1
    fi
}

# Example: Update JSON config
VALIDATOR="jq empty"

config=$(cat << 'EOF'
{
  "host": "localhost",
  "port": 5432,
  "database": "myapp",
  "pool_size": 10
}
EOF
)

update_file_atomic "/etc/myapp/config.json" "$config"
```

---

### Scenario 5: Parallel File Processor

```bash copy
#!/bin/bash
# parallel_process.sh - Process files in parallel

set -euo pipefail

input_dir=${1:?"Input directory required"}
output_dir=${2:?"Output directory required"}
max_jobs=${3:-4}

[[ ! -d "$input_dir" ]] && echo "Input directory not found" >&2 && exit 1

mkdir -p "$output_dir"

echo "=== Parallel File Processing ==="
echo "Input: $input_dir"
echo "Output: $output_dir"
echo "Max parallel jobs: $max_jobs"
echo ""

# Process single file
process_file() {
    local input=$1
    local output=$2
    
    local filename=$(basename "$input")
    echo "[$(date +%H:%M:%S)] Processing: $filename"
    
    # Simulate processing (replace with actual work)
    sleep 1
    
    # Transform file
    if sed 's/old/new/g' "$input" > "$output"; then
        echo "[$(date +%H:%M:%S)] ✓ Complete: $filename"
        return 0
    else
        echo "[$(date +%H:%M:%S)] ✗ Failed: $filename" >&2
        return 1
    fi
}

export -f process_file

# Find files and process in parallel
find "$input_dir" -type f -name "*.txt" | \
    parallel -j "$max_jobs" process_file {} "$output_dir/{/}"

# Alternative without GNU parallel
# job_count=0
# 
# find "$input_dir" -type f -name "*.txt" | while IFS= read -r input; do
#     filename=$(basename "$input")
#     output="$output_dir/$filename"
#     
#     process_file "$input" "$output" &
#     ((job_count++))
#     
#     # Limit concurrent jobs
#     if ((job_count >= max_jobs)); then
#         wait -n
#         ((job_count--))
#     fi
# done
# 
# wait  # Wait for remaining jobs

echo ""
echo "=== Processing Complete ==="
echo "Total files: $(find "$output_dir" -type f | wc -l)"
```

</div>

</details>

---

<details>
<summary><strong>13. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Read entire file
content=$(<file.txt)
```

```bash copy
# Read line by line
while IFS= read -r line; do
    echo "$line"
done < file.txt
```

```bash copy
# Write to file (overwrite)
echo "content" > file.txt
```

```bash copy
# Append to file
echo "content" >> file.txt
```

```bash copy
# Redirect stdout and stderr
command > output.txt 2>&1
command &> output.txt
```

```bash copy
# Discard output
command > /dev/null 2>&1
```

```bash copy
# Here document
cat << EOF
line 1
line 2
EOF
```

```bash copy
# Here string
grep "pattern" <<< "text"
```

```bash copy
# Process substitution
diff <(ls dir1) <(ls dir2)
```

```bash copy
# Pipe to multiple files
command | tee file1.txt file2.txt
```

```bash copy
# Create temp file
temp=$(mktemp)
```

```bash copy
# Create temp directory
temp_dir=$(mktemp -d)
```

```bash copy
# File tests
[ -f file.txt ]  # Regular file
[ -d dir ]       # Directory
[ -e file ]      # Exists
[ -r file ]      # Readable
[ -w file ]      # Writable
[ -x file ]      # Executable
```

```bash copy
# Copy file
cp source.txt dest.txt
```

```bash copy
# Move/rename file
mv oldname.txt newname.txt
```

```bash copy
# Remove file
rm file.txt
```

```bash copy
# Create directory
mkdir -p path/to/dir
```

```bash copy
# Symbolic link
ln -s target linkname
```

```bash copy
# Find files
find /path -name "*.txt"
```

```bash copy
# File locking
exec 200>/var/run/lock
flock -n 200 || exit 1
```

</div>

</details>

---

<details>
<summary><strong>14. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Use `while IFS= read -r` for reading files line by line
- Always use `mktemp` for temporary files
- Redirect to `/dev/null` to discard output
- Use `trap` to ensure cleanup of temp files
- File descriptors: 0=stdin, 1=stdout, 2=stderr
- Process substitution `<()` treats command output as file

---

**Reading Files:**

| Method | Use Case | Example |
|--------|----------|---------|
| `$(<file)` | Small files | `content=$(<file.txt)` |
| `while read` | Line by line | `while IFS= read -r line; do` |
| `mapfile` | Into array | `mapfile -t lines < file.txt` |
| `cat` | Display/pipe | `cat file.txt \| grep pattern` |

---

**Writing Files:**

| Method | Effect | Example |
|--------|--------|---------|
| `>` | Overwrite | `echo "text" > file.txt` |
| `>>` | Append | `echo "text" >> file.txt` |
| `tee` | Write and display | `command \| tee file.txt` |
| `tee -a` | Append and display | `command \| tee -a file.txt` |

---

**Redirection:**

| Syntax | Effect |
|--------|--------|
| `command > file` | Redirect stdout to file |
| `command 2> file` | Redirect stderr to file |
| `command &> file` | Redirect both to file |
| `command >> file` | Append stdout to file |
| `command > /dev/null` | Discard stdout |
| `command 2>&1` | Redirect stderr to stdout |
| `command \| tee file` | To file and stdout |

---

**File Tests:**

| Test | True If |
|------|---------|
| `[ -e file ]` | Exists (any type) |
| `[ -f file ]` | Regular file |
| `[ -d file ]` | Directory |
| `[ -L file ]` | Symbolic link |
| `[ -r file ]` | Readable |
| `[ -w file ]` | Writable |
| `[ -x file ]` | Executable |
| `[ -s file ]` | Not empty |
| `[ f1 -nt f2 ]` | f1 newer than f2 |
| `[ f1 -ot f2 ]` | f1 older than f2 |

---

**Common Patterns:**

```bash copy
# Safe file reading
while IFS= read -r line; do
    process "$line"
done < file.txt

# Atomic file update
temp=$(mktemp)
echo "content" > "$temp"
mv "$temp" target.txt

# Temporary file with cleanup
temp=$(mktemp)
trap "rm -f '$temp'" EXIT

# File locking
exec 200>/var/run/script.lock
flock -n 200 || exit 1

# Here document
cat > file.txt << EOF
content here
EOF

# Process multiple files
find /path -name "*.txt" -exec process {} \;
```

---

**Best Practices:**

1. **Always quote file paths**
   ```bash copy
   cat "$file"     # Correct
   cat $file       # Wrong
   ```

2. **Use temp files safely**
   ```bash copy
   temp=$(mktemp)
   trap "rm -f '$temp'" EXIT
   ```

3. **Check before processing**
   ```bash copy
   [ -f "$file" ] || exit 1
   [ -r "$file" ] || exit 1
   ```

4. **Atomic updates**
   ```bash copy
   temp=$(mktemp)
   echo "data" > "$temp"
   mv "$temp" "$target"
   ```

5. **Proper error handling**
   ```bash copy
   if ! cp source dest; then
       echo "Copy failed" >&2
       exit 1
   fi
   ```

---

**What's Next:**
Now that you can handle files and I/O, the next file covers process management and job control — how to manage running processes and background jobs.

</div>

</details>

---