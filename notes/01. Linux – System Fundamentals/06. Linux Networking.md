# Networking

Every service you deploy needs to communicate. Web servers listen for HTTP requests. Databases accept connections from applications. Containers pull images from registries. Monitoring agents push metrics to collectors. Your SSH session right now — that's networking.

Linux networking is powerful and deep. The kernel handles everything from raw ethernet frames to complex routing decisions, from simple ping responses to load-balanced traffic across multiple paths. You don't need to master every layer, but you need working knowledge of how interfaces are configured, how traffic flows, how firewalls filter, and how to diagnose when things break.

This file gives you that working knowledge. By the end, you'll configure network interfaces, understand IP addressing and routing, manage firewall rules, and troubleshoot connectivity issues with confidence.

---

## Table of Contents

1. [Networking Fundamentals](#1-networking-fundamentals)
2. [Network Interfaces](#2-network-interfaces)
3. [IP Addresses and Configuration](#3-ip-addresses-and-configuration)
4. [Routing](#4-routing)
5. [DNS Resolution](#5-dns-resolution)
6. [Ports and Sockets](#6-ports-and-sockets)
7. [Firewalls — iptables and firewalld](#7-firewalls--iptables-and-firewalld)
8. [Network Diagnostic Tools](#8-network-diagnostic-tools)
9. [Practical Troubleshooting](#9-practical-troubleshooting)
10. [Where We Go From Here](#10-where-we-go-from-here)

---

<details>
<summary><strong>1. Networking Fundamentals</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Before diving into commands, understand what's happening when data moves between machines.

### The TCP/IP model

Network communication happens in layers. Each layer has a job:

| Layer | Purpose | Examples |
|-------|---------|----------|
| Application | What the data means | HTTP, SSH, DNS, SMTP |
| Transport | Reliable delivery | TCP, UDP |
| Network | Addressing and routing | IP, ICMP |
| Link | Physical transmission | Ethernet, Wi-Fi |

When ChillSpot sends video to a user, the application creates HTTP data, TCP ensures reliable delivery, IP routes packets across the internet, and Ethernet handles the physical wire.

### IP addresses

Every device on a network needs an address. IPv4 addresses look like `192.168.1.100` — four octets, each 0-255. IPv6 addresses are longer: `2001:db8::1`.

Addresses are divided into network and host portions. A `/24` network like `192.168.1.0/24` means:
- First 24 bits (192.168.1) identify the network
- Last 8 bits identify the host (0-255, or 256 addresses)

Special ranges:
- `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16` — Private addresses (not routed on internet)
- `127.0.0.0/8` — Loopback (localhost)
- `0.0.0.0` — All interfaces / any address

### TCP vs UDP

**TCP** (Transmission Control Protocol) — Connection-oriented. Guarantees delivery, maintains order, handles retransmission. Used for HTTP, SSH, databases — anything where data must arrive correctly.

**UDP** (User Datagram Protocol) — Connectionless. Fire and forget. Faster but no guarantees. Used for DNS queries, video streaming, gaming — where speed matters more than perfect delivery.

### Ports

IP addresses identify machines. Ports identify services on that machine. A server might run:
- SSH on port 22
- HTTP on port 80
- HTTPS on port 443
- PostgreSQL on port 5432

When you connect to `192.168.1.100:443`, you're reaching the HTTPS service on that host.

Ports 0-1023 are "well-known" and typically require root to bind. Ports 1024-65535 are available for applications.

</div>
</details>

---

<details>
<summary><strong>2. Network Interfaces</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

A network interface is how your system connects to a network — physical hardware (ethernet card, wifi adapter) or virtual (loopback, bridges, tunnels).

### Viewing interfaces

```bash
ip link show
```

Output:
```
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP
    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff
```

- `lo` — Loopback interface (localhost, 127.0.0.1)
- `eth0` — First ethernet interface (might be `ens33`, `enp0s3` on newer systems)

### Interface naming

Traditional names like `eth0` are simple but unstable — adding hardware could change numbering. Modern systems use predictable names:

- `enp0s3` — Ethernet, PCI bus 0, slot 3
- `ens33` — Ethernet, hotplug slot 33
- `wlp2s0` — Wireless, PCI bus 2, slot 0

The names encode the physical location, so they don't change when you add hardware.

### Bringing interfaces up and down

```bash
sudo ip link set eth0 up             # Enable interface
sudo ip link set eth0 down           # Disable interface
```

### Viewing IP addresses

```bash
ip addr show
ip a                                  # Short form
```

Output includes interface status plus assigned addresses:
```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 ...
    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
    inet6 fe80::5054:ff:fe12:3456/64 scope link
```

### The old commands

You'll still see `ifconfig` in tutorials and older systems:

```bash
ifconfig                             # Show interfaces (deprecated)
ifconfig eth0 192.168.1.100          # Set IP (deprecated)
```

`ifconfig` is part of `net-tools`, which is deprecated. Use `ip` commands instead — they're more powerful and consistent.

</div>
</details>

---

<details>
<summary><strong>3. IP Addresses and Configuration</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Machines need IP addresses to communicate. You can assign them manually (static) or let a DHCP server assign them automatically.

### Temporary IP assignment

```bash
sudo ip addr add 192.168.1.100/24 dev eth0
sudo ip addr del 192.168.1.100/24 dev eth0
```

These changes don't survive reboot. For persistent configuration, use system tools.

### Persistent configuration — Ubuntu/Debian (Netplan)

Modern Ubuntu uses Netplan. Configuration lives in `/etc/netplan/`:

```yaml
# /etc/netplan/01-network.yaml
network:
  version: 2
  ethernets:
    eth0:
      dhcp4: true
```

For static IP:

```yaml
network:
  version: 2
  ethernets:
    eth0:
      addresses:
        - 192.168.1.100/24
      gateway4: 192.168.1.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
```

Apply changes:

```bash
sudo netplan apply
```

### Persistent configuration — RHEL/Rocky/Alma (NetworkManager)

Configuration lives in `/etc/NetworkManager/system-connections/` or use `nmcli`:

```bash
# Show connections
nmcli connection show

# Create static connection
sudo nmcli connection add con-name "static-eth0" \
    ifname eth0 type ethernet \
    ip4 192.168.1.100/24 gw4 192.168.1.1

# Set DNS
sudo nmcli connection modify "static-eth0" ipv4.dns "8.8.8.8 8.8.4.4"

# Activate
sudo nmcli connection up "static-eth0"
```

For DHCP:

```bash
sudo nmcli connection add con-name "dhcp-eth0" \
    ifname eth0 type ethernet \
    ipv4.method auto
```

### Checking your configuration

```bash
ip addr show eth0                    # Current IP
ip route show                        # Routing table
cat /etc/resolv.conf                 # DNS servers
```

</div>
</details>

---

<details>
<summary><strong>4. Routing</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Routing determines where packets go. When you send data to an IP address, the kernel consults the routing table to decide which interface and gateway to use.

### Viewing the routing table

```bash
ip route show
```

Output:
```
default via 192.168.1.1 dev eth0 proto static
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100
```

Reading this:
- **default via 192.168.1.1** — Traffic with no specific route goes to 192.168.1.1 (the gateway/router)
- **192.168.1.0/24 dev eth0** — Traffic for the local network goes directly out eth0

### The default gateway

The default gateway is your exit to the broader network. Local traffic (same subnet) goes directly to the destination. Everything else goes to the gateway, which routes it further.

```bash
ip route | grep default
```

### Adding and removing routes

```bash
# Add a route
sudo ip route add 10.0.0.0/8 via 192.168.1.254

# Add default gateway
sudo ip route add default via 192.168.1.1

# Remove a route
sudo ip route del 10.0.0.0/8
```

Like IP addresses, these changes are temporary. For persistence, configure through Netplan or NetworkManager.

### Checking if routing works

```bash
# Trace the path to a destination
traceroute google.com

# Or with mtr (combines ping and traceroute)
mtr google.com
```

Each hop shows where your packet traveled. Useful for finding where connectivity breaks.

### IP forwarding

By default, Linux doesn't forward packets between interfaces — it's not a router. To enable forwarding:

```bash
# Temporary
sudo sysctl -w net.ipv4.ip_forward=1

# Permanent — add to /etc/sysctl.conf
net.ipv4.ip_forward = 1
```

You'd enable this if your Linux box routes traffic between networks, acts as a VPN server, or runs containers with complex networking.

</div>
</details>

---

<details>
<summary><strong>5. DNS Resolution</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

DNS translates names to IP addresses. When you access `chillspot.io`, DNS resolves it to an IP your system can route to.

### How resolution works

1. Application calls `getaddrinfo("chillspot.io")`
2. System checks `/etc/hosts` for static mappings
3. System queries DNS servers listed in `/etc/resolv.conf`
4. DNS server returns IP address
5. Application connects to that IP

### /etc/hosts — Local overrides

Static name-to-IP mappings:

```
127.0.0.1   localhost
192.168.1.50   db.chillspot.internal
192.168.1.51   cache.chillspot.internal
```

Checked before DNS. Useful for internal names, development overrides, or blocking domains.

### /etc/resolv.conf — DNS servers

```
nameserver 8.8.8.8
nameserver 8.8.4.4
search chillspot.internal
```

- `nameserver` — DNS servers to query (up to 3)
- `search` — Domain to append to short names (so `db` resolves as `db.chillspot.internal`)

On systems with NetworkManager or systemd-resolved, this file might be managed automatically. Check before editing manually.

### systemd-resolved

Modern systems often use systemd-resolved as a local DNS stub:

```bash
resolvectl status
```

Shows the actual DNS servers per interface. The `/etc/resolv.conf` might just point to `127.0.0.53` (the local resolver).

### Testing DNS

```bash
# Simple lookup
host chillspot.io
nslookup chillspot.io

# Detailed lookup
dig chillspot.io

# Query specific DNS server
dig @8.8.8.8 chillspot.io

# Trace the resolution path
dig +trace chillspot.io
```

### Common DNS issues

**Wrong nameserver** — Check `/etc/resolv.conf` or `resolvectl status`

**DNS not responding** — Try `dig @8.8.8.8 google.com` to test with a known server

**Cached stale record** — Clear local cache:
```bash
sudo systemd-resolve --flush-caches    # systemd-resolved
sudo systemctl restart nscd            # if using nscd
```

</div>
</details>

---

<details>
<summary><strong>6. Ports and Sockets</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Services listen on ports. Understanding what's listening where is essential for configuration and security.

### Viewing listening ports

```bash
ss -tlnp
```

| Flag | Meaning |
|------|---------|
| -t | TCP sockets |
| -u | UDP sockets |
| -l | Listening only |
| -n | Numeric (don't resolve names) |
| -p | Show process using socket |

Output:
```
State    Recv-Q   Send-Q   Local Address:Port   Peer Address:Port   Process
LISTEN   0        128      0.0.0.0:22           0.0.0.0:*           users:(("sshd",pid=1234))
LISTEN   0        128      0.0.0.0:80           0.0.0.0:*           users:(("nginx",pid=5678))
LISTEN   0        128      127.0.0.1:5432       0.0.0.0:*           users:(("postgres",pid=9012))
```

Reading this:
- SSH listens on all interfaces (`0.0.0.0:22`)
- Nginx listens on all interfaces port 80
- PostgreSQL only listens on localhost (`127.0.0.1:5432`) — not accessible remotely

### The old netstat command

```bash
netstat -tlnp                        # Same as ss -tlnp
```

`netstat` is in `net-tools` (deprecated). Use `ss` instead — it's faster and more detailed.

### Viewing all connections

```bash
ss -tan                              # All TCP connections
ss -tan state established           # Only established connections
```

### Checking if a port is in use

```bash
ss -tlnp | grep :80
lsof -i :80                          # Alternative using lsof
```

### Binding to ports

Services bind to ports when they start. Common issues:

**Port already in use:**
```
Error: Address already in use
```

Find what's using it:
```bash
ss -tlnp | grep :80
sudo lsof -i :80
```

**Permission denied (ports below 1024):**

Only root can bind to ports 0-1023. Either:
- Run service as root (not recommended)
- Use systemd socket activation
- Use `setcap` to grant capability:
  ```bash
  sudo setcap 'cap_net_bind_service=+ep' /path/to/binary
  ```

### Well-known ports

| Port | Service |
|------|---------|
| 22 | SSH |
| 25 | SMTP |
| 53 | DNS |
| 80 | HTTP |
| 443 | HTTPS |
| 3306 | MySQL |
| 5432 | PostgreSQL |
| 6379 | Redis |
| 8080 | HTTP alternate |

</div>
</details>

---

<details>
<summary><strong>7. Firewalls — iptables and firewalld</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Firewalls filter traffic — deciding what packets are allowed in, out, or forwarded. Linux has powerful firewalling built into the kernel (netfilter), with different tools to configure it.

### iptables — The traditional tool

`iptables` directly manipulates netfilter rules. It's powerful but complex.

**View current rules:**

```bash
sudo iptables -L -n -v
```

**Basic structure:**

Rules are organized into chains:
- **INPUT** — Incoming traffic destined for this machine
- **OUTPUT** — Outgoing traffic from this machine  
- **FORWARD** — Traffic passing through (routing)

**Allow SSH:**

```bash
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```

- `-A INPUT` — Append to INPUT chain
- `-p tcp` — Protocol TCP
- `--dport 22` — Destination port 22
- `-j ACCEPT` — Jump to ACCEPT (allow)

**Block an IP:**

```bash
sudo iptables -A INPUT -s 192.168.1.50 -j DROP
```

**Drop all other incoming:**

```bash
sudo iptables -P INPUT DROP          # Set default policy to DROP
```

**Save rules (Debian/Ubuntu):**

```bash
sudo apt install iptables-persistent
sudo netfilter-persistent save
```

Rules load from `/etc/iptables/rules.v4` on boot.

### firewalld — The modern approach

RHEL, Rocky, Alma, and Fedora use firewalld by default. It's a front-end to netfilter with zones, services, and runtime/permanent distinction.

**Check status:**

```bash
sudo firewall-cmd --state
sudo firewall-cmd --list-all
```

**Allow a service:**

```bash
sudo firewall-cmd --add-service=http --permanent
sudo firewall-cmd --add-service=https --permanent
sudo firewall-cmd --reload
```

**Allow a port:**

```bash
sudo firewall-cmd --add-port=8080/tcp --permanent
sudo firewall-cmd --reload
```

**Remove a rule:**

```bash
sudo firewall-cmd --remove-service=http --permanent
sudo firewall-cmd --reload
```

### ufw — Ubuntu's simple firewall

Ubuntu offers `ufw` (Uncomplicated Firewall) as a simpler iptables front-end:

```bash
sudo ufw enable                      # Enable firewall
sudo ufw status                      # Show rules
sudo ufw allow ssh                   # Allow SSH
sudo ufw allow 80/tcp                # Allow HTTP
sudo ufw allow from 192.168.1.0/24  # Allow subnet
sudo ufw deny 3306                   # Block MySQL externally
```

### Which to use?

- **Ubuntu servers** — ufw for simplicity, iptables for complex needs
- **RHEL/Rocky/Alma** — firewalld (default and well-integrated)
- **Containers/Kubernetes** — Often manage networking at orchestration level

For ChillSpot production servers:

```bash
# Allow web traffic and SSH, block everything else
sudo ufw default deny incoming
sudo ufw allow ssh
sudo ufw allow http
sudo ufw allow https
sudo ufw enable
```

</div>
</details>

---

<details>
<summary><strong>8. Network Diagnostic Tools</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When networking breaks, these tools help you find why.

### ping — Basic connectivity

```bash
ping 192.168.1.1                     # Ping by IP
ping google.com                      # Ping by name (tests DNS too)
ping -c 4 google.com                 # Send 4 packets and stop
```

If ping fails:
- By IP: Network/routing issue
- By name but IP works: DNS issue

### traceroute / tracepath — Path discovery

```bash
traceroute google.com
tracepath google.com                 # Doesn't require root
```

Shows each hop between you and the destination. Useful for finding where connectivity breaks.

### mtr — Combined ping and traceroute

```bash
mtr google.com
```

Continuously updates, showing packet loss and latency at each hop. Excellent for diagnosing intermittent issues.

### dig / nslookup — DNS queries

```bash
dig chillspot.io                     # Query DNS
dig +short chillspot.io              # Just the IP
dig @8.8.8.8 chillspot.io           # Query specific server
nslookup chillspot.io               # Simpler output
```

### curl — HTTP testing

```bash
curl -I https://chillspot.io         # Headers only
curl -v https://chillspot.io         # Verbose (shows connection details)
curl -o /dev/null -s -w "%{http_code}" https://chillspot.io   # Just status code
```

### nc (netcat) — Swiss army knife

```bash
# Test if port is open
nc -zv 192.168.1.100 80

# Listen on a port
nc -l 8080

# Send data to a port
echo "test" | nc 192.168.1.100 8080
```

### tcpdump — Packet capture

See actual packets on the wire:

```bash
sudo tcpdump -i eth0                 # All traffic on eth0
sudo tcpdump -i eth0 port 80         # Only HTTP
sudo tcpdump -i eth0 host 192.168.1.50   # Traffic to/from specific host
sudo tcpdump -i eth0 -w capture.pcap # Save to file for Wireshark
```

### ss and lsof — Socket inspection

```bash
ss -tlnp                             # What's listening
ss -tan                              # All TCP connections
lsof -i :80                          # What's using port 80
lsof -i -P -n                        # All network connections
```

</div>
</details>

---

<details>
<summary><strong>9. Practical Troubleshooting</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When something doesn't connect, work through this systematic approach.

### The troubleshooting ladder

Start at the bottom and work up:

1. **Is the interface up?**
   ```bash
   ip link show eth0
   ```

2. **Do you have an IP address?**
   ```bash
   ip addr show eth0
   ```

3. **Can you reach the gateway?**
   ```bash
   ping 192.168.1.1
   ```

4. **Can you reach external IPs?**
   ```bash
   ping 8.8.8.8
   ```

5. **Does DNS work?**
   ```bash
   dig google.com
   ```

6. **Can you reach the destination?**
   ```bash
   ping destination.com
   curl -v https://destination.com
   ```

7. **Is the service running locally?**
   ```bash
   ss -tlnp | grep :80
   systemctl status nginx
   ```

8. **Is the firewall blocking?**
   ```bash
   sudo iptables -L -n
   sudo ufw status
   ```

### Common scenarios

**"Cannot connect to remote service"**

```bash
# Is it DNS?
ping remote-server.com              # Works?
ping 93.184.216.34                  # Try IP directly

# Is the port open?
nc -zv remote-server.com 443

# Is there a route?
traceroute remote-server.com
```

**"Service won't start — port in use"**

```bash
ss -tlnp | grep :80
# Kill the process or change your service's port
```

**"Connection refused"**

The port is closed or service isn't listening:
```bash
ss -tlnp | grep :PORT
systemctl status SERVICE
```

**"Connection timed out"**

Firewall blocking, routing issue, or host down:
```bash
ping HOST
traceroute HOST
# Check firewall rules on both ends
```

**"No route to host"**

Routing problem:
```bash
ip route show
ping gateway
```

### ChillSpot debugging example

Users report the streaming service is unreachable:

```bash
# Is the service running?
systemctl status chillspot-streaming
ss -tlnp | grep :8080

# Is the firewall allowing traffic?
sudo ufw status | grep 8080

# Can you curl locally?
curl -v http://localhost:8080/health

# Check from outside
# (from another machine)
curl -v http://chillspot-server:8080/health
nc -zv chillspot-server 8080
```

Work through each layer until you find where it breaks.

</div>
</details>

---

## 10. Where We Go From Here

You now understand how Linux handles networking — interfaces, IP addresses, routing, DNS, ports, firewalls, and diagnostic tools. You can configure network settings, secure services with firewall rules, and systematically troubleshoot connectivity issues.

But networks aren't just about connecting services. They're also about storing and moving data. Files need to be stored efficiently, compressed for transfer, archived for backup, and managed across filesystems.

File 07 covers **Storage, Archiving & Files** — disk management, filesystems, mounting, compression, archiving, and the tools you'll use to handle data at scale.

Your network is configured. Let's manage what flows through it.
