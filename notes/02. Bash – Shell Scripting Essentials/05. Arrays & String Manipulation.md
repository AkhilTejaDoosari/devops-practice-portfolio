# **05. Arrays & String Manipulation — Working with Collections and Text**
> How to store, process, and transform data efficiently.

---

## Table of Contents
- [1. Why Arrays and Strings Matter](#1-why-arrays-and-strings-matter)
- [2. Indexed Arrays](#2-indexed-arrays)
- [3. Associative Arrays](#3-associative-arrays)
- [4. Array Operations](#4-array-operations)
- [5. String Manipulation](#5-string-manipulation)
- [6. Pattern Matching and Replacement](#6-pattern-matching-and-replacement)
- [7. String Splitting and Joining](#7-string-splitting-and-joining)
- [8. Case Conversion](#8-case-conversion)
- [9. Text Processing with sed](#9-text-processing-with-sed)
- [10. Text Processing with awk](#10-text-processing-with-awk)
- [11. Regular Expressions](#11-regular-expressions)
- [12. Real-World Scenarios](#12-real-world-scenarios)
- [13. Commands Reference](#13-commands-reference)
- [14. Quick Reference](#14-quick-reference)

---

<details>
<summary><strong>1. Why Arrays and Strings Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Most automation involves collections and text processing.

Working with multiple servers? Store them in an array.
Parsing configuration files? String manipulation.
Processing log entries? Text transformation.
Building dynamic commands? String operations.

Understanding arrays and strings means:
- you can manage collections of data
- you can parse and transform text efficiently
- you can build dynamic configurations
- you can process structured and unstructured data

This isn't about memorizing operations.
It's about understanding how to structure and manipulate data — so you can handle any data processing task that comes up.

</div>

</details>

---

<details>
<summary><strong>2. Indexed Arrays</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-201 — Creating Arrays

```bash copy
# Method 1: Direct assignment
servers=(web01 web02 web03)

# Method 2: Individual elements
servers[0]="web01"
servers[1]="web02"
servers[2]="web03"

# Method 3: Empty array
servers=()

# Method 4: From command output
files=($(ls *.txt))

# Method 5: With declare
declare -a servers=("web01" "web02" "web03")
```

---

### BASH-202 — Accessing Array Elements

```bash copy
servers=(web01 web02 web03 web04)

# Access by index
echo "${servers[0]}"  # web01
echo "${servers[1]}"  # web02

# Last element
echo "${servers[-1]}"  # web04

# All elements
echo "${servers[@]}"  # web01 web02 web03 web04
echo "${servers[*]}"  # web01 web02 web03 web04

# Array length
echo "${#servers[@]}"  # 4
```

**Critical Difference:**
- `"${servers[@]}"` → each element as separate word
- `"${servers[*]}"` → all elements as single word

---

### BASH-203 — Adding Elements

```bash copy
servers=(web01 web02)

# Append element
servers+=(web03)
echo "${servers[@]}"  # web01 web02 web03

# Append multiple
servers+=(web04 web05)
echo "${servers[@]}"  # web01 web02 web03 web04 web05

# Insert at specific index
servers[10]=web10  # Creates sparse array
```

---

### BASH-204 — Removing Elements

```bash copy
servers=(web01 web02 web03 web04)

# Remove by index
unset servers[1]
echo "${servers[@]}"  # web01 web03 web04

# Remove entire array
unset servers
```

---

### BASH-205 — Iterating Over Arrays

```bash copy
servers=(web01 web02 web03)

# Iterate over values
for server in "${servers[@]}"; do
    echo "Server: $server"
done

# Iterate with indices
for i in "${!servers[@]}"; do
    echo "Index $i: ${servers[$i]}"
done

# C-style loop
for ((i = 0; i < ${#servers[@]}; i++)); do
    echo "Server $i: ${servers[$i]}"
done
```

---

### BASH-206 — Array Slicing

```bash copy
servers=(web01 web02 web03 web04 web05)

# Extract subset (from index 1, take 3 elements)
subset=("${servers[@]:1:3}")
echo "${subset[@]}"  # web02 web03 web04

# From index to end
tail=("${servers[@]:2}")
echo "${tail[@]}"  # web03 web04 web05

# Copy entire array
copy=("${servers[@]}")
```

---

### BASH-207 — Checking Array Membership

```bash copy
servers=(web01 web02 web03)

# Check if element exists
if [[ " ${servers[@]} " =~ " web02 " ]]; then
    echo "web02 is in array"
fi

# Function to check membership
contains() {
    local search=$1
    shift
    local array=("$@")
    
    for item in "${array[@]}"; do
        [[ "$item" == "$search" ]] && return 0
    done
    return 1
}

if contains "web02" "${servers[@]}"; then
    echo "Found"
fi
```

---

### BASH-208 — Sorting Arrays

```bash copy
servers=(web03 web01 web04 web02)

# Sort using mapfile and sort
IFS=$'\n' sorted=($(sort <<<"${servers[*]}"))
unset IFS

echo "${sorted[@]}"  # web01 web02 web03 web04

# Sort in function
sort_array() {
    local -n arr=$1
    IFS=$'\n' arr=($(sort <<<"${arr[*]}"))
    unset IFS
}

sort_array servers
echo "${servers[@]}"
```

</div>

</details>

---

<details>
<summary><strong>3. Associative Arrays</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-209 — Creating Associative Arrays

```bash copy
# Declare associative array (Bash 4+)
declare -A config

# Assign values
config[host]="localhost"
config[port]="5432"
config[database]="myapp"

# Multiple assignments
declare -A colors=(
    [red]="#FF0000"
    [green]="#00FF00"
    [blue]="#0000FF"
)
```

---

### BASH-210 — Accessing Associative Arrays

```bash copy
declare -A config
config[host]="localhost"
config[port]="5432"

# Access by key
echo "${config[host]}"  # localhost

# All values
echo "${config[@]}"

# All keys
echo "${!config[@]}"

# Number of elements
echo "${#config[@]}"
```

---

### BASH-211 — Iterating Over Associative Arrays

```bash copy
declare -A config
config[host]="localhost"
config[port]="5432"
config[database]="myapp"

# Iterate over keys
for key in "${!config[@]}"; do
    echo "$key: ${config[$key]}"
done

# Iterate in sorted order
for key in $(echo "${!config[@]}" | tr ' ' '\n' | sort); do
    echo "$key: ${config[$key]}"
done
```

---

### BASH-212 — Checking Key Existence

```bash copy
declare -A config
config[host]="localhost"

# Check if key exists
if [[ -v config[host] ]]; then
    echo "Key 'host' exists"
fi

# Alternative
if [[ -n "${config[host]+x}" ]]; then
    echo "Key 'host' exists"
fi
```

---

### BASH-213 — Removing Keys

```bash copy
declare -A config
config[host]="localhost"
config[port]="5432"

# Remove specific key
unset config[port]

# Remove entire array
unset config
```

---

### BASH-214 — Practical Use Cases

**Configuration Management:**
```bash copy
declare -A environments

environments[dev_host]="dev.example.com"
environments[dev_port]="8080"
environments[staging_host]="staging.example.com"
environments[staging_port]="8080"
environments[prod_host]="prod.example.com"
environments[prod_port]="80"

env="prod"
host="${environments[${env}_host]}"
port="${environments[${env}_port]}"

echo "Connecting to $host:$port"
```

**Counting Occurrences:**
```bash copy
declare -A word_count

while read -r word; do
    ((word_count[$word]++))
done < <(cat file.txt | tr ' ' '\n')

# Display results
for word in "${!word_count[@]}"; do
    echo "$word: ${word_count[$word]}"
done
```

</div>

</details>

---

<details>
<summary><strong>4. Array Operations</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-215 — Merging Arrays

```bash copy
array1=(a b c)
array2=(d e f)

# Merge arrays
merged=("${array1[@]}" "${array2[@]}")
echo "${merged[@]}"  # a b c d e f
```

---

### BASH-216 — Filtering Arrays

```bash copy
servers=(web01 web02 db01 web03 db02)

# Filter elements matching pattern
web_servers=()
for server in "${servers[@]}"; do
    [[ $server == web* ]] && web_servers+=("$server")
done

echo "${web_servers[@]}"  # web01 web02 web03
```

---

### BASH-217 — Mapping Arrays

```bash copy
# Transform each element
numbers=(1 2 3 4 5)
doubled=()

for num in "${numbers[@]}"; do
    doubled+=($((num * 2)))
done

echo "${doubled[@]}"  # 2 4 6 8 10
```

---

### BASH-218 — Reducing Arrays

```bash copy
# Sum all elements
numbers=(1 2 3 4 5)
sum=0

for num in "${numbers[@]}"; do
    ((sum += num))
done

echo "Sum: $sum"  # 15
```

---

### BASH-219 — Finding in Arrays

```bash copy
servers=(web01 web02 web03 web04)

# Find index of element
find_index() {
    local search=$1
    shift
    local array=("$@")
    
    for i in "${!array[@]}"; do
        if [[ "${array[$i]}" == "$search" ]]; then
            echo $i
            return 0
        fi
    done
    return 1
}

index=$(find_index "web03" "${servers[@]}")
echo "Found at index: $index"  # 2
```

---

### BASH-220 — Unique Elements

```bash copy
# Remove duplicates
items=(apple banana apple cherry banana apple)

declare -A seen
unique=()

for item in "${items[@]}"; do
    if [[ ! -v seen[$item] ]]; then
        unique+=("$item")
        seen[$item]=1
    fi
done

echo "${unique[@]}"  # apple banana cherry
```

---

### BASH-221 — Array to String

```bash copy
servers=(web01 web02 web03)

# Join with delimiter
IFS=','
joined="${servers[*]}"
unset IFS

echo "$joined"  # web01,web02,web03

# Join with custom delimiter (function)
join_by() {
    local IFS="$1"
    shift
    echo "$*"
}

result=$(join_by ', ' "${servers[@]}")
echo "$result"  # web01, web02, web03
```

---

### BASH-222 — String to Array

```bash copy
# Split string into array
csv="web01,web02,web03"

# Using IFS
IFS=',' read -ra servers <<< "$csv"
echo "${servers[@]}"  # web01 web02 web03

# Alternative
servers=(${csv//,/ })
echo "${servers[@]}"
```

</div>

</details>

---

<details>
<summary><strong>5. String Manipulation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-223 — String Length

```bash copy
text="Hello World"

# Length
length=${#text}
echo $length  # 11

# Check if empty
if [ -z "$text" ]; then
    echo "String is empty"
fi

# Check if not empty
if [ -n "$text" ]; then
    echo "String is not empty"
fi
```

---

### BASH-224 — Substring Extraction

```bash copy
text="Hello World"

# Extract substring (from position, length)
sub=${text:0:5}
echo $sub  # Hello

# From position to end
sub=${text:6}
echo $sub  # World

# From end (negative index)
sub=${text: -5}
echo $sub  # World

# From end with length
sub=${text: -5:3}
echo $sub  # Wor
```

**Example - Parse Log Timestamp:**
```bash copy
log="2024-11-19 10:30:45 ERROR Database connection failed"

date=${log:0:10}        # 2024-11-19
time=${log:11:8}        # 10:30:45
level=${log:20:5}       # ERROR
message=${log:26}       # Database connection failed

echo "Date: $date"
echo "Time: $time"
echo "Level: $level"
echo "Message: $message"
```

---

### BASH-225 — Pattern Removal

```bash copy
filename="backup_2024_11_19.tar.gz"

# Remove shortest from beginning
echo ${filename#backup_}      # 2024_11_19.tar.gz
echo ${filename#*_}           # 2024_11_19.tar.gz

# Remove longest from beginning
echo ${filename##*_}          # 19.tar.gz

# Remove shortest from end
echo ${filename%.*}           # backup_2024_11_19.tar
echo ${filename%.tar.gz}      # backup_2024_11_19

# Remove longest from end
echo ${filename%%.*}          # backup_2024_11_19
echo ${filename%%_*}          # backup
```

---

### BASH-226 — File Path Manipulation

```bash copy
filepath="/var/www/html/app/index.php"

# Extract directory
dirname=${filepath%/*}
echo $dirname  # /var/www/html/app

# Extract filename
filename=${filepath##*/}
echo $filename  # index.php

# Extract basename (without extension)
basename=${filename%.*}
echo $basename  # index

# Extract extension
extension=${filename##*.}
echo $extension  # php

# Extract all extensions
all_ext=${filename#*.}
echo $all_ext  # php
```

**For files with multiple extensions:**
```bash copy
filename="archive.tar.gz"

# Remove last extension
echo ${filename%.*}    # archive.tar

# Remove all extensions
echo ${filename%%.*}   # archive

# Get last extension
echo ${filename##*.}   # gz

# Get all extensions
echo ${filename#*.}    # tar.gz
```

---

### BASH-227 — Default Values

```bash copy
# Use default if empty
name=${USER:-"guest"}

# Assign default if empty
port=${PORT:=8080}

# Use alternative if set
verbose=${VERBOSE:+"--verbose"}

# Error if empty
required=${REQUIRED:?"REQUIRED must be set"}
```

</div>

</details>

---

<details>
<summary><strong>6. Pattern Matching and Replacement</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-228 — Replace First Occurrence

```bash copy
text="foo bar foo baz"

# Replace first
echo ${text/foo/qux}  # qux bar foo baz

# Example
log="ERROR: Connection failed ERROR: Timeout"
echo ${log/ERROR/WARNING}  # WARNING: Connection failed ERROR: Timeout
```

---

### BASH-229 — Replace All Occurrences

```bash copy
text="foo bar foo baz foo"

# Replace all
echo ${text//foo/qux}  # qux bar qux baz qux

# Remove all (replace with nothing)
echo ${text//foo/}  # bar  baz
```

---

### BASH-230 — Replace at Beginning

```bash copy
path="/usr/local/bin/script"

# Replace at beginning
echo ${path/#\/usr/\/opt}  # /opt/local/bin/script

# Example
url="http://example.com/page"
echo ${url/#http:/https:}  # https://example.com/page
```

---

### BASH-231 — Replace at End

```bash copy
filename="report.txt"

# Replace at end
echo ${filename/%txt/pdf}  # report.pdf

# Example
script="deploy.sh"
echo ${script/%.sh/.bash}  # deploy.bash
```

---

### BASH-232 — Pattern Matching

```bash copy
filename="document.pdf"

# Check pattern match
if [[ $filename == *.pdf ]]; then
    echo "PDF file"
fi

# Multiple patterns
case $filename in
    *.txt|*.md)
        echo "Text file"
        ;;
    *.jpg|*.png)
        echo "Image file"
        ;;
    *.pdf)
        echo "PDF file"
        ;;
esac
```

---

### BASH-233 — Practical Replacements

**Sanitize Filenames:**
```bash copy
filename="My Document (draft).txt"

# Replace spaces with underscores
safe=${filename// /_}
echo $safe  # My_Document_(draft).txt

# Remove special characters
safe=${filename//[^a-zA-Z0-9._-]/}
echo $safe  # MyDocumentdraft.txt
```

**Clean Log Data:**
```bash copy
log="User john@example.com logged in from 192.168.1.100"

# Anonymize email
clean=${log//*@*.com/user@domain.com}

# Anonymize IP
clean=${clean//[0-9]*.[0-9]*.[0-9]*.[0-9]*/XXX.XXX.XXX.XXX}

echo $clean
# User user@domain.com logged in from XXX.XXX.XXX.XXX
```

</div>

</details>

---

<details>
<summary><strong>7. String Splitting and Joining</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-234 — Split String into Array

```bash copy
# Using IFS
csv="apple,banana,cherry"
IFS=',' read -ra fruits <<< "$csv"
echo "${fruits[@]}"  # apple banana cherry

# Split on whitespace (default)
text="word1 word2 word3"
words=($text)
echo "${words[@]}"

# Split on newlines
data="line1
line2
line3"
mapfile -t lines <<< "$data"
echo "${lines[@]}"
```

---

### BASH-235 — Join Array into String

```bash copy
items=(apple banana cherry)

# Join with comma
IFS=','
joined="${items[*]}"
unset IFS
echo $joined  # apple,banana,cherry

# Join function
join_by() {
    local delimiter=$1
    shift
    local first=$1
    shift
    printf "%s" "$first" "${@/#/$delimiter}"
}

result=$(join_by ', ' "${items[@]}")
echo $result  # apple, banana, cherry
```

---

### BASH-236 — Split on Multiple Delimiters

```bash copy
text="apple;banana,cherry:date"

# Replace delimiters with space, then split
text=${text//[;,:]/\ }
items=($text)
echo "${items[@]}"  # apple banana cherry date
```

---

### BASH-237 — Parse CSV Line

```bash copy
csv_line="John,Doe,30,Engineer"

# Split into array
IFS=',' read -ra fields <<< "$csv_line"

first_name=${fields[0]}
last_name=${fields[1]}
age=${fields[2]}
job=${fields[3]}

echo "Name: $first_name $last_name"
echo "Age: $age"
echo "Job: $job"

# Or directly to variables
IFS=',' read -r first last age job <<< "$csv_line"
echo "$first $last is $age years old"
```

</div>

</details>

---

<details>
<summary><strong>8. Case Conversion</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-238 — Lowercase and Uppercase (Bash 4+)

```bash copy
text="Hello World"

# Lowercase
echo ${text,,}      # hello world
echo ${text,}       # hello World (first char only)

# Uppercase
echo ${text^^}      # HELLO WORLD
echo ${text^}       # Hello World (first char only)

# Toggle case
text="HeLLo"
echo ${text~~}      # hEllO (toggle all)
echo ${text~}       # hELLo (toggle first)
```

---

### BASH-239 — Portable Case Conversion

```bash copy
text="Hello World"

# Using tr
lowercase=$(echo "$text" | tr '[:upper:]' '[:lower:]')
echo $lowercase  # hello world

uppercase=$(echo "$text" | tr '[:lower:]' '[:upper:]')
echo $uppercase  # HELLO WORLD
```

---

### BASH-240 — Case-Insensitive Comparison

```bash copy
input="YES"

# Method 1: Convert to lowercase
if [[ "${input,,}" == "yes" ]]; then
    echo "User said yes"
fi

# Method 2: Case-insensitive pattern
if [[ "$input" =~ ^[Yy][Ee][Ss]$ ]]; then
    echo "User said yes"
fi

# Method 3: Using shopt
shopt -s nocasematch
if [[ "$input" == "yes" ]]; then
    echo "User said yes"
fi
shopt -u nocasematch
```

</div>

</details>

---

<details>
<summary><strong>9. Text Processing with sed</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-241 — Basic sed Substitution

```bash copy
# Replace first occurrence
echo "foo bar foo" | sed 's/foo/qux/'
# qux bar foo

# Replace all occurrences
echo "foo bar foo" | sed 's/foo/qux/g'
# qux bar qux

# Replace in file
sed 's/old/new/g' file.txt > output.txt

# In-place editing
sed -i 's/old/new/g' file.txt
```

---

### BASH-242 — sed Delete Lines

```bash copy
# Delete line 3
sed '3d' file.txt

# Delete lines 2-4
sed '2,4d' file.txt

# Delete lines matching pattern
sed '/pattern/d' file.txt

# Delete empty lines
sed '/^$/d' file.txt

# Delete comments
sed '/^#/d' file.txt
```

---

### BASH-243 — sed Extract Lines

```bash copy
# Print line 5
sed -n '5p' file.txt

# Print lines 10-20
sed -n '10,20p' file.txt

# Print lines matching pattern
sed -n '/pattern/p' file.txt

# Print first match
sed -n '/pattern/p; /pattern/q' file.txt
```

---

### BASH-244 — sed Multiple Operations

```bash copy
# Multiple substitutions
sed 's/foo/qux/g; s/bar/baz/g' file.txt

# Using -e flag
sed -e 's/foo/qux/g' -e 's/bar/baz/g' file.txt

# From file
sed -f commands.sed file.txt
```

---

### BASH-245 — Practical sed Examples

**Extract IP addresses:**
```bash copy
# Extract IPv4 addresses
sed -n 's/.*\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\).*/\1/p' log.txt
```

**Sanitize config file:**
```bash copy
# Remove comments and empty lines
sed -e 's/#.*//' -e '/^$/d' config.conf
```

**Add line numbers:**
```bash copy
sed = file.txt | sed 'N;s/\n/: /'
```

</div>

</details>

---

<details>
<summary><strong>10. Text Processing with awk</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-246 — Basic awk

```bash copy
# Print specific column
echo "one two three" | awk '{print $2}'  # two

# Print multiple columns
echo "one two three" | awk '{print $1, $3}'  # one three

# With custom separator
echo "one:two:three" | awk -F':' '{print $2}'  # two

# Print last column
echo "one two three four" | awk '{print $NF}'  # four
```

---

### BASH-247 — awk Conditions

```bash copy
# Print lines where column 3 > 100
awk '$3 > 100' file.txt

# Print lines matching pattern
awk '/pattern/' file.txt

# Combine conditions
awk '$3 > 100 && $1 == "active"' file.txt

# Print specific columns if condition met
awk '$3 > 100 {print $1, $3}' file.txt
```

---

### BASH-248 — awk Calculations

```bash copy
# Sum column 3
awk '{sum += $3} END {print sum}' file.txt

# Average
awk '{sum += $3; count++} END {print sum/count}' file.txt

# Count lines
awk 'END {print NR}' file.txt

# Count matching lines
awk '/pattern/ {count++} END {print count}' file.txt
```

---

### BASH-249 — awk Built-in Variables

```bash copy
# NR - line number
awk '{print NR, $0}' file.txt

# NF - number of fields
awk '{print NF}' file.txt

# FS - field separator (input)
awk -F':' '{print $1}' /etc/passwd

# OFS - output field separator
awk 'BEGIN {OFS=","} {print $1, $2}' file.txt
```

---

### BASH-250 — Practical awk Examples

**Process CSV:**
```bash copy
# Extract columns 1 and 3 from CSV
awk -F',' '{print $1, $3}' data.csv

# Sum column 2
awk -F',' '{sum += $2} END {print sum}' data.csv
```

**Parse logs:**
```bash copy
# Count errors per hour
awk '/ERROR/ {print substr($1,12,2)}' app.log | sort | uniq -c

# Get top 10 IP addresses
awk '{print $1}' access.log | sort | uniq -c | sort -rn | head -10
```

**Format output:**
```bash copy
# Pretty print table
awk '{printf "%-20s %-10s %s\n", $1, $2, $3}' file.txt
```

</div>

</details>

---

<details>
<summary><strong>11. Regular Expressions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-251 — Basic Regex in Bash

```bash copy
text="hello@example.com"

# Match pattern
if [[ $text =~ ^[a-z]+@[a-z]+\.[a-z]+$ ]]; then
    echo "Valid email format"
fi

# Extract matched groups
if [[ $text =~ ^([a-z]+)@([a-z]+)\.([a-z]+)$ ]]; then
    user="${BASH_REMATCH[1]}"
    domain="${BASH_REMATCH[2]}"
    tld="${BASH_REMATCH[3]}"
    echo "User: $user"
    echo "Domain: $domain"
    echo "TLD: $tld"
fi
```

---

### BASH-252 — Common Regex Patterns

```bash copy
# Email
[[ $email =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$ ]]

# IP address
[[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]

# URL
[[ $url =~ ^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,} ]]

# Phone (US)
[[ $phone =~ ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ ]]

# Version (semantic)
[[ $version =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]

# Hexadecimal color
[[ $color =~ ^#[0-9A-Fa-f]{6}$ ]]
```

---

### BASH-253 — Validation Functions

```bash copy
is_valid_email() {
    [[ $1 =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$ ]]
}

is_valid_ip() {
    [[ $1 =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]
}

is_valid_url() {
    [[ $1 =~ ^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,} ]]
}

# Usage
if is_valid_email "user@example.com"; then
    echo "Valid email"
fi
```

---

### BASH-254 — Extract with Regex

```bash copy
# Extract version from string
release="myapp-v1.2.3.tar.gz"

if [[ $release =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
    major="${BASH_REMATCH[1]}"
    minor="${BASH_REMATCH[2]}"
    patch="${BASH_REMATCH[3]}"
    echo "Version: $major.$minor.$patch"
fi

# Extract date components
log="2024-11-19 10:30:45 ERROR"

if [[ $log =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]; then
    year="${BASH_REMATCH[1]}"
    month="${BASH_REMATCH[2]}"
    day="${BASH_REMATCH[3]}"
    echo "Date: $year/$month/$day"
fi
```

---

### BASH-255 — Regex with grep

```bash copy
# Basic grep
grep "pattern" file.txt

# Extended regex
grep -E "pattern1|pattern2" file.txt

# Case-insensitive
grep -i "pattern" file.txt

# Invert match
grep -v "pattern" file.txt

# Count matches
grep -c "pattern" file.txt

# Show line numbers
grep -n "pattern" file.txt

# Only matching part
grep -o "pattern" file.txt

# Quiet (just exit status)
grep -q "pattern" file.txt
```

**Common patterns:**
```bash copy
# Find IP addresses
grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' file.txt

# Find emails
grep -oE '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}' file.txt

# Find URLs
grep -oE 'https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}[^ ]*' file.txt
```

</div>

</details>

---

<details>
<summary><strong>12. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Log Analysis Tool

```bash copy
#!/bin/bash
# analyze_logs.sh - Parse and analyze application logs

set -euo pipefail

log_file=${1:?"Log file required"}

if [[ ! -f "$log_file" ]]; then
    echo "Log file not found: $log_file" >&2
    exit 1
fi

echo "=== Log Analysis Report ==="
echo "File: $log_file"
echo ""

# Count by log level
declare -A level_counts
while IFS= read -r line; do
    if [[ $line =~ \[(ERROR|WARN|INFO|DEBUG)\] ]]; then
        level="${BASH_REMATCH[1]}"
        ((level_counts[$level]++))
    fi
done < "$log_file"

echo "=== Log Levels ==="
for level in ERROR WARN INFO DEBUG; do
    count=${level_counts[$level]:-0}
    echo "$level: $count"
done
echo ""

# Extract and count unique errors
echo "=== Top 10 Errors ==="
grep "\[ERROR\]" "$log_file" | \
    sed 's/^.*\[ERROR\] //' | \
    sort | uniq -c | sort -rn | head -10
echo ""

# Errors per hour
echo "=== Errors by Hour ==="
grep "\[ERROR\]" "$log_file" | \
    awk '{print substr($2,1,2)}' | \
    sort | uniq -c | \
    awk '{printf "%02d:00 - %d errors\n", $2, $1}'
echo ""

# Extract unique IP addresses
echo "=== Unique IP Addresses ==="
grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' "$log_file" | \
    sort -u | wc -l
echo ""

# Top 10 IP addresses
echo "=== Top 10 Active IPs ==="
grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' "$log_file" | \
    sort | uniq -c | sort -rn | head -10 | \
    awk '{printf "%-15s : %d requests\n", $2, $1}'
echo ""

# Response time statistics (if present)
if grep -q "response_time" "$log_file"; then
    echo "=== Response Time Statistics ==="
    
    response_times=($(grep "response_time" "$log_file" | \
        grep -oE 'response_time=[0-9]+' | \
        cut -d= -f2))
    
    if [[ ${#response_times[@]} -gt 0 ]]; then
        # Calculate stats
        sum=0
        min=${response_times[0]}
        max=${response_times[0]}
        
        for time in "${response_times[@]}"; do
            ((sum += time))
            ((time < min)) && min=$time
            ((time > max)) && max=$time
        done
        
        avg=$((sum / ${#response_times[@]}))
        
        echo "Count: ${#response_times[@]}"
        echo "Min: ${min}ms"
        echo "Max: ${max}ms"
        echo "Avg: ${avg}ms"
    fi
fi
```

---

### Scenario 2: Configuration File Manager

```bash copy
#!/bin/bash
# config_manager.sh - Manage application configurations

set -euo pipefail

declare -A config

# Load configuration from file
load_config() {
    local file=$1
    
    if [[ ! -f "$file" ]]; then
        echo "Config file not found: $file" >&2
        return 1
    fi
    
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ $key =~ ^#.*$ || -z $key ]] && continue
        
        # Trim whitespace
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        # Store in associative array
        config[$key]="$value"
    done < "$file"
    
    echo "Loaded ${#config[@]} configuration values"
}

# Save configuration to file
save_config() {
    local file=$1
    
    # Sort keys and save
    for key in $(printf '%s\n' "${!config[@]}" | sort); do
        echo "$key=${config[$key]}"
    done > "$file"
    
    echo "Saved configuration to $file"
}

# Get configuration value
get_value() {
    local key=$1
    
    if [[ -v config[$key] ]]; then
        echo "${config[$key]}"
    else
        echo "Key not found: $key" >&2
        return 1
    fi
}

# Set configuration value
set_value() {
    local key=$1
    local value=$2
    
    config[$key]="$value"
    echo "Set $key=$value"
}

# Delete configuration key
delete_key() {
    local key=$1
    
    if [[ -v config[$key] ]]; then
        unset config[$key]
        echo "Deleted key: $key"
    else
        echo "Key not found: $key" >&2
        return 1
    fi
}

# List all configuration
list_config() {
    echo "=== Configuration ==="
    for key in $(printf '%s\n' "${!config[@]}" | sort); do
        printf "%-20s = %s\n" "$key" "${config[$key]}"
    done
}

# Validate configuration
validate_config() {
    local required_keys=(host port database)
    local missing=()
    
    for key in "${required_keys[@]}"; do
        if [[ ! -v config[$key] ]]; then
            missing+=("$key")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Missing required keys:" >&2
        printf '  - %s\n' "${missing[@]}" >&2
        return 1
    fi
    
    # Validate port is numeric
    if [[ ! ${config[port]} =~ ^[0-9]+$ ]]; then
        echo "Invalid port: ${config[port]}" >&2
        return 1
    fi
    
    echo "Configuration is valid"
    return 0
}

# Main function
main() {
    local config_file="config.conf"
    
    case ${1:-} in
        load)
            load_config "${2:-$config_file}"
            ;;
        save)
            save_config "${2:-$config_file}"
            ;;
        get)
            get_value "${2:?"Key required"}"
            ;;
        set)
            set_value "${2:?"Key required"}" "${3:?"Value required"}"
            ;;
        delete)
            delete_key "${2:?"Key required"}"
            ;;
        list)
            list_config
            ;;
        validate)
            validate_config
            ;;
        *)
            cat << EOF
Usage: $0 <command> [args]

Commands:
    load [file]       Load configuration from file
    save [file]       Save configuration to file
    get <key>         Get configuration value
    set <key> <val>   Set configuration value
    delete <key>      Delete configuration key
    list              List all configuration
    validate          Validate configuration
EOF
            exit 1
            ;;
    esac
}

main "$@"
```

---

### Scenario 3: CSV Data Processor

```bash copy
#!/bin/bash
# process_csv.sh - Process and analyze CSV data

set -euo pipefail

csv_file=${1:?"CSV file required"}

if [[ ! -f "$csv_file" ]]; then
    echo "File not found: $csv_file" >&2
    exit 1
fi

# Read header
IFS=',' read -ra headers < "$csv_file"

echo "=== CSV Analysis ==="
echo "File: $csv_file"
echo "Columns: ${#headers[@]}"
echo ""

# Display column names
echo "=== Columns ==="
for i in "${!headers[@]}"; do
    echo "$((i+1)). ${headers[$i]}"
done
echo ""

# Count rows (excluding header)
row_count=$(($(wc -l < "$csv_file") - 1))
echo "Total rows: $row_count"
echo ""

# Extract specific column
extract_column() {
    local col_num=$1
    local col_name=${headers[$((col_num-1))]}
    
    echo "=== Column: $col_name ==="
    
    # Skip header, extract column
    tail -n +2 "$csv_file" | cut -d',' -f"$col_num"
}

# Calculate statistics for numeric column
column_stats() {
    local col_num=$1
    local col_name=${headers[$((col_num-1))]}
    
    echo "=== Statistics: $col_name ==="
    
    # Extract values
    values=($(tail -n +2 "$csv_file" | cut -d',' -f"$col_num"))
    
    # Check if numeric
    if [[ ! ${values[0]} =~ ^[0-9]+$ ]]; then
        echo "Column is not numeric"
        return 1
    fi
    
    # Calculate statistics
    sum=0
    min=${values[0]}
    max=${values[0]}
    
    for val in "${values[@]}"; do
        ((sum += val))
        ((val < min)) && min=$val
        ((val > max)) && max=$val
    done
    
    avg=$((sum / ${#values[@]}))
    
    echo "Count: ${#values[@]}"
    echo "Sum: $sum"
    echo "Min: $min"
    echo "Max: $max"
    echo "Avg: $avg"
}

# Filter rows by condition
filter_rows() {
    local col_num=$1
    local operator=$2
    local value=$3
    local col_name=${headers[$((col_num-1))]}
    
    echo "=== Filtered Rows: $col_name $operator $value ==="
    
    # Print header
    echo "${headers[*]}" | tr ' ' ','
    
    # Filter and print matching rows
    tail -n +2 "$csv_file" | while IFS=',' read -ra row; do
        col_value=${row[$((col_num-1))]}
        
        case $operator in
            "=")
                [[ "$col_value" == "$value" ]] && echo "${row[*]}" | tr ' ' ','
                ;;
            ">")
                [[ $col_value -gt $value ]] && echo "${row[*]}" | tr ' ' ','
                ;;
            "<")
                [[ $col_value -lt $value ]] && echo "${row[*]}" | tr ' ' ','
                ;;
        esac
    done
}

# Group by and count
group_by() {
    local col_num=$1
    local col_name=${headers[$((col_num-1))]}
    
    echo "=== Group By: $col_name ==="
    
    declare -A counts
    
    # Count occurrences
    while IFS=',' read -ra row; do
        value=${row[$((col_num-1))]}
        ((counts[$value]++))
    done < <(tail -n +2 "$csv_file")
    
    # Display results
    for key in $(printf '%s\n' "${!counts[@]}" | sort); do
        printf "%-20s : %d\n" "$key" "${counts[$key]}"
    done
}

# Export to different format
export_json() {
    echo "["
    
    local first=true
    while IFS=',' read -ra row; do
        if [[ $first == true ]]; then
            first=false
            continue  # Skip header
        fi
        
        echo "  {"
        for i in "${!headers[@]}"; do
            printf '    "%s": "%s"' "${headers[$i]}" "${row[$i]}"
            [[ $i -lt $((${#headers[@]} - 1)) ]] && echo "," || echo ""
        done
        echo "  },"
    done < "$csv_file"
    
    echo "]"
}

# Example usage
column_stats 3  # Statistics for column 3
echo ""
group_by 2      # Group by column 2
```

---

### Scenario 4: String Utilities Library

```bash copy
#!/bin/bash
# string_utils.sh - Reusable string manipulation functions

# Trim whitespace
trim() {
    local str="$1"
    # Remove leading whitespace
    str="${str#"${str%%[![:space:]]*}"}"
    # Remove trailing whitespace
    str="${str%"${str##*[![:space:]]}"}"
    echo "$str"
}

# Uppercase
to_upper() {
    echo "$1" | tr '[:lower:]' '[:upper:]'
}

# Lowercase
to_lower() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

# Title case
to_title() {
    echo "$1" | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1'
}

# Reverse string
reverse() {
    echo "$1" | rev
}

# Check if string contains substring
contains() {
    [[ "$1" == *"$2"* ]]
}

# Check if string starts with
starts_with() {
    [[ "$1" == "$2"* ]]
}

# Check if string ends with
ends_with() {
    [[ "$1" == *"$2" ]]
}

# Repeat string N times
repeat() {
    local str=$1
    local count=$2
    printf "%${count}s" | tr ' ' "$str"
}

# Pad left
pad_left() {
    local str=$1
    local width=$2
    local pad=${3:- }
    printf "%${width}s" "$str" | tr ' ' "$pad"
}

# Pad right
pad_right() {
    local str=$1
    local width=$2
    local pad=${3:- }
    printf "%-${width}s" "$str" | tr ' ' "$pad"
}

# Center text
center() {
    local str=$1
    local width=$2
    local len=${#str}
    local pad=$(((width - len) / 2))
    printf "%${pad}s%s%${pad}s\n" "" "$str" ""
}

# Slugify (make URL-safe)
slugify() {
    echo "$1" | \
        tr '[:upper:]' '[:lower:]' | \
        tr -cs '[:alnum:]' '-' | \
        sed 's/^-//; s/-$//'
}

# Extract between delimiters
extract_between() {
    local str=$1
    local start=$2
    local end=$3
    echo "$str" | sed "s/.*${start}\(.*\)${end}.*/\1/"
}

# Usage examples
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "=== String Utilities Demo ==="
    echo ""
    
    text="  Hello World  "
    echo "Original: '$text'"
    echo "Trimmed: '$(trim "$text")'"
    echo ""
    
    echo "Uppercase: $(to_upper "hello")"
    echo "Lowercase: $(to_lower "HELLO")"
    echo "Title: $(to_title "hello world")"
    echo ""
    
    echo "Reverse: $(reverse "hello")"
    echo "Repeat '-' 10 times: $(repeat '-' 10)"
    echo ""
    
    echo "Pad left: '$(pad_left "test" 10)'"
    echo "Pad right: '$(pad_right "test" 10)'"
    echo "Center: '$(center "test" 20)'"
    echo ""
    
    echo "Slugify: $(slugify "Hello World! Test 123")"
fi
```

---

### Scenario 5: Array Processing Library

```bash copy
#!/bin/bash
# array_utils.sh - Array manipulation utilities

# Check if array contains element
array_contains() {
    local search=$1
    shift
    local array=("$@")
    
    for item in "${array[@]}"; do
        [[ "$item" == "$search" ]] && return 0
    done
    return 1
}

# Remove duplicates
array_unique() {
    local -n arr=$1
    declare -A seen
    local unique=()
    
    for item in "${arr[@]}"; do
        if [[ ! -v seen[$item] ]]; then
            unique+=("$item")
            seen[$item]=1
        fi
    done
    
    arr=("${unique[@]}")
}

# Sort array
array_sort() {
    local -n arr=$1
    IFS=$'\n' arr=($(sort <<<"${arr[*]}"))
    unset IFS
}

# Reverse array
array_reverse() {
    local -n arr=$1
    local reversed=()
    
    for ((i=${#arr[@]}-1; i>=0; i--)); do
        reversed+=("${arr[$i]}")
    done
    
    arr=("${reversed[@]}")
}

# Filter array
array_filter() {
    local pattern=$1
    local -n arr=$2
    local filtered=()
    
    for item in "${arr[@]}"; do
        [[ "$item" == $pattern ]] && filtered+=("$item")
    done
    
    arr=("${filtered[@]}")
}

# Map array (apply function to each element)
array_map() {
    local func=$1
    local -n arr=$2
    local mapped=()
    
    for item in "${arr[@]}"; do
        mapped+=("$($func "$item")")
    done
    
    arr=("${mapped[@]}")
}

# Join array with delimiter
array_join() {
    local delimiter=$1
    shift
    local first=$1
    shift
    printf "%s" "$first" "${@/#/$delimiter}"
}

# Sum numeric array
array_sum() {
    local array=("$@")
    local sum=0
    
    for num in "${array[@]}"; do
        ((sum += num))
    done
    
    echo $sum
}

# Max value in array
array_max() {
    local array=("$@")
    local max=${array[0]}
    
    for num in "${array[@]}"; do
        ((num > max)) && max=$num
    done
    
    echo $max
}

# Min value in array
array_min() {
    local array=("$@")
    local min=${array[0]}
    
    for num in "${array[@]}"; do
        ((num < min)) && min=$num
    done
    
    echo $min
}

# Usage examples
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "=== Array Utilities Demo ==="
    echo ""
    
    # Test contains
    fruits=(apple banana cherry)
    if array_contains "banana" "${fruits[@]}"; then
        echo "✓ Found banana in array"
    fi
    echo ""
    
    # Test unique
    items=(a b a c b d c)
    echo "Original: ${items[@]}"
    array_unique items
    echo "Unique: ${items[@]}"
    echo ""
    
    # Test sort
    numbers=(5 2 8 1 9)
    echo "Unsorted: ${numbers[@]}"
    array_sort numbers
    echo "Sorted: ${numbers[@]}"
    echo ""
    
    # Test join
    echo "Joined: $(array_join ', ' "${fruits[@]}")"
    echo ""
    
    # Test numeric operations
    nums=(10 20 30 40 50)
    echo "Array: ${nums[@]}"
    echo "Sum: $(array_sum "${nums[@]}")"
    echo "Max: $(array_max "${nums[@]}")"
    echo "Min: $(array_min "${nums[@]}")"
fi
```

</div>

</details>

---

<details>
<summary><strong>13. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Create indexed array
array=(item1 item2 item3)
```

```bash copy
# Access element
echo "${array[0]}"
```

```bash copy
# All elements
echo "${array[@]}"
```

```bash copy
# Array length
echo "${#array[@]}"
```

```bash copy
# Append element
array+=(item4)
```

```bash copy
# Iterate array
for item in "${array[@]}"; do
    echo "$item"
done
```

```bash copy
# Create associative array
declare -A config
config[key]="value"
```

```bash copy
# Access associative array
echo "${config[key]}"
```

```bash copy
# All keys
echo "${!config[@]}"
```

```bash copy
# String length
echo ${#string}
```

```bash copy
# Substring
echo ${string:start:length}
```

```bash copy
# Remove from beginning
echo ${string#pattern}
echo ${string##pattern}
```

```bash copy
# Remove from end
echo ${string%pattern}
echo ${string%%pattern}
```

```bash copy
# Replace first
echo ${string/old/new}
```

```bash copy
# Replace all
echo ${string//old/new}
```

```bash copy
# Uppercase/lowercase (Bash 4+)
echo ${string^^}  # uppercase
echo ${string,,}  # lowercase
```

```bash copy
# Split string into array
IFS=',' read -ra array <<< "a,b,c"
```

```bash copy
# Join array to string
IFS=','
joined="${array[*]}"
```

```bash copy
# sed substitution
sed 's/old/new/g' file.txt
```

```bash copy
# awk print column
awk '{print $2}' file.txt
```

```bash copy
# grep pattern
grep "pattern" file.txt
```

```bash copy
# Regex match
[[ $string =~ pattern ]]
```

</div>

</details>

---

<details>
<summary><strong>14. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Indexed arrays store ordered lists (0-indexed)
- Associative arrays store key-value pairs (Bash 4+)
- Always quote array expansions: `"${array[@]}"`
- String manipulation is built into Bash
- Use `sed` for stream editing, `awk` for column processing
- Regular expressions validate and extract patterns

---

**Array Operations:**

| Operation | Indexed Array | Associative Array |
|-----------|---------------|-------------------|
| Create | `arr=(a b c)` | `declare -A arr` |
| Assign | `arr[0]="value"` | `arr[key]="value"` |
| Access | `${arr[0]}` | `${arr[key]}` |
| All elements | `${arr[@]}` | `${arr[@]}` |
| All keys/indices | `${!arr[@]}` | `${!arr[@]}` |
| Length | `${#arr[@]}` | `${#arr[@]}` |
| Append | `arr+=(item)` | `arr[key]="value"` |
| Delete element | `unset arr[0]` | `unset arr[key]` |

---

**String Manipulation:**

| Operation | Syntax | Example |
|-----------|--------|---------|
| Length | `${#str}` | `${#text}` → 5 |
| Substring | `${str:pos:len}` | `${text:0:3}` → "Hel" |
| Remove prefix (short) | `${str#pattern}` | `${file#*/}` |
| Remove prefix (long) | `${str##pattern}` | `${file##*/}` |
| Remove suffix (short) | `${str%pattern}` | `${file%.*}` |
| Remove suffix (long) | `${str%%pattern}` | `${file%%.*}` |
| Replace first | `${str/old/new}` | `${text/foo/bar}` |
| Replace all | `${str//old/new}` | `${text//foo/bar}` |
| Uppercase | `${str^^}` | `${text^^}` |
| Lowercase | `${str,,}` | `${text,,}` |

---

**Common Patterns:**

```bash copy
# File path manipulation
filepath="/path/to/file.txt"
dirname=${filepath%/*}       # /path/to
filename=${filepath##*/}     # file.txt
basename=${filename%.*}      # file
extension=${filename##*.}    # txt

# Split and join
IFS=',' read -ra parts <<< "a,b,c"
joined=$(IFS=,; echo "${parts[*]}")

# Remove duplicates
declare -A seen
unique=()
for item in "${array[@]}"; do
    [[ ! -v seen[$item] ]] && unique+=("$item") && seen[$item]=1
done

# Sort array
IFS=$'\n' sorted=($(sort <<<"${array[*]}"))

# Contains check
if [[ " ${array[@]} " =~ " search " ]]; then
    echo "Found"
fi
```

---

**Text Processing:**

| Tool | Use Case | Example |
|------|----------|---------|
| `sed` | Stream editing | `sed 's/old/new/g' file` |
| `awk` | Column processing | `awk '{print $2}' file` |
| `grep` | Pattern matching | `grep 'pattern' file` |
| `cut` | Extract columns | `cut -d',' -f2 file` |
| `tr` | Character translation | `tr '[:lower:]' '[:upper:]'` |
| `sort` | Sort lines | `sort file` |
| `uniq` | Remove duplicates | `uniq file` |

---

**Regular Expressions:**

```bash copy
# Validation
[[ $email =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$ ]]
[[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]
[[ $url =~ ^https?:// ]]

# Extraction
if [[ $text =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
    major="${BASH_REMATCH[1]}"
    minor="${BASH_REMATCH[2]}"
    patch="${BASH_REMATCH[3]}"
fi
```

---

**Best Practices:**

1. **Always quote array expansions**
   ```bash copy
   for item in "${array[@]}"; do  # Correct
   for item in ${array[@]}; do     # Wrong
   ```

2. **Use associative arrays for lookups**
   ```bash copy
   declare -A cache
   cache[key]="value"
   ```

3. **Validate before processing**
   ```bash copy
   [[ ${#array[@]} -eq 0 ]] && return
   ```

4. **Use built-in operations when possible**
   ```bash copy
   # Built-in (fast)
   ${string//foo/bar}
   
   # External (slow)
   echo "$string" | sed 's/foo/bar/g'
   ```

---

**What's Next:**
Now that you can handle collections and text, the next file covers file operations and I/O — how to read, write, and manipulate files efficiently.

</div>

</details>

---