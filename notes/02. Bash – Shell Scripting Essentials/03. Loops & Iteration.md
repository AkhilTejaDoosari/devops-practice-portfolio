# **03. Loops & Iteration — Repeating Operations Efficiently**
> How to process collections and repeat tasks automatically.

---

## Table of Contents
- [1. Why Loops Matter](#1-why-loops-matter)
- [2. The for Loop](#2-the-for-loop)
- [3. The while Loop](#3-the-while-loop)
- [4. The until Loop](#4-the-until-loop)
- [5. Loop Control: break and continue](#5-loop-control-break-and-continue)
- [6. Reading Files Line by Line](#6-reading-files-line-by-line)
- [7. Infinite Loops](#7-infinite-loops)
- [8. C-Style Loops](#8-c-style-loops)
- [9. Iterating Over Arrays](#9-iterating-over-arrays)
- [10. Nested Loops](#10-nested-loops)
- [11. Loop Performance Considerations](#11-loop-performance-considerations)
- [12. Common Loop Patterns](#12-common-loop-patterns)
- [13. Real-World Scenarios](#13-real-world-scenarios)
- [14. Commands Reference](#14-commands-reference)
- [15. Quick Reference](#15-quick-reference)

---

<details>
<summary><strong>1. Why Loops Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Automation is repetition with intelligence.

Process multiple files? Loop through them.
Check service status repeatedly? Loop with delays.
Retry failed operations? Loop until success.
Deploy to multiple servers? Loop over the list.

Understanding loops means:
- you can automate batch operations
- you can process large datasets efficiently
- you can implement retry logic
- you can handle collections without manual repetition

This isn't about memorizing syntax.
It's about understanding when and how to repeat operations — so you can write scripts that handle scale.

</div>

</details>

---

<details>
<summary><strong>2. The for Loop</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The `for` loop iterates over a list of items.

---

### BASH-100 — Basic for Loop

```bash copy
# Iterate over list
for item in item1 item2 item3; do
    echo "Processing: $item"
done
```

**Example:**
```bash copy
for server in web01 web02 web03; do
    echo "Pinging $server..."
    ping -c 1 $server
done
```

---

### BASH-101 — Iterating Over Files

```bash copy
# All files in directory
for file in /var/log/*.log; do
    echo "Processing: $file"
done

# Multiple patterns
for file in *.txt *.md; do
    echo "Found: $file"
done

# Recursive (with globstar)
shopt -s globstar
for file in **/*.sh; do
    echo "Script: $file"
done
```

**Example:**
```bash copy
#!/bin/bash
# Process all log files

for logfile in /var/log/myapp/*.log; do
    # Skip if no files match
    [ -f "$logfile" ] || continue
    
    echo "Compressing: $logfile"
    gzip "$logfile"
done
```

---

### BASH-102 — Iterating Over Command Output

```bash copy
# Process output line by line
for user in $(cat /etc/passwd | cut -d: -f1); do
    echo "User: $user"
done

# Better: use while read (covered later)
```

**Caution:**
Word splitting occurs with `for` over command output. Use `while read` for files.

---

### BASH-103 — Sequence Iteration

```bash copy
# Using brace expansion
for i in {1..5}; do
    echo "Number: $i"
done

# With step
for i in {0..10..2}; do
    echo "Even: $i"
done

# Using seq
for i in $(seq 1 5); do
    echo "Number: $i"
done
```

**Example:**
```bash copy
#!/bin/bash
# Create multiple backup directories

for month in {01..12}; do
    backup_dir="/backups/2024-${month}"
    mkdir -p "$backup_dir"
    echo "Created: $backup_dir"
done
```

---

### BASH-104 — Iterating Over Arguments

```bash copy
#!/bin/bash
# Process all script arguments

for arg in "$@"; do
    echo "Argument: $arg"
done

# Example: deploy to multiple environments
for env in "$@"; do
    echo "Deploying to: $env"
    ./deploy.sh "$env"
done
```

---

### BASH-105 — Loop with Index

```bash copy
# Using array
servers=(web01 web02 web03)

for i in "${!servers[@]}"; do
    echo "Index $i: ${servers[$i]}"
done
```

---

### BASH-106 — for Loop Patterns

**Process Files:**
```bash copy
for file in *.txt; do
    [ -f "$file" ] || continue  # Skip if no files
    cp "$file" backup/
done
```

**Batch Operations:**
```bash copy
for server in web{01..05}; do
    ssh "$server" "systemctl restart nginx"
done
```

**Generate Files:**
```bash copy
for i in {1..100}; do
    touch "file_${i}.txt"
done
```

**Parallel Processing (Background Jobs):**
```bash copy
for server in web{01..10}; do
    ping -c 1 "$server" &
done
wait  # Wait for all background jobs
```

</div>

</details>

---

<details>
<summary><strong>3. The while Loop</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The `while` loop executes as long as a condition is true.

---

### BASH-107 — Basic while Loop

```bash copy
# Basic syntax
while [ condition ]; do
    # commands
done
```

**Example:**
```bash copy
count=1

while [ $count -le 5 ]; do
    echo "Count: $count"
    ((count++))
done
```

---

### BASH-108 — while with Arithmetic

```bash copy
# Using (( ))
count=1

while ((count <= 5)); do
    echo "Count: $count"
    ((count++))
done
```

**Example - Countdown:**
```bash copy
seconds=10

while ((seconds > 0)); do
    echo "Time remaining: $seconds seconds"
    sleep 1
    ((seconds--))
done

echo "Time's up!"
```

---

### BASH-109 — Reading Files with while

```bash copy
# Best way to read files line by line
while IFS= read -r line; do
    echo "Line: $line"
done < file.txt
```

**Why This is Better Than for:**
- Preserves whitespace
- Handles spaces in lines
- No word splitting issues
- Memory efficient

**Example:**
```bash copy
#!/bin/bash
# Process configuration file

while IFS='=' read -r key value; do
    # Skip comments and empty lines
    [[ $key =~ ^#.*$ || -z $key ]] && continue
    
    # Remove whitespace
    key=$(echo "$key" | xargs)
    value=$(echo "$value" | xargs)
    
    echo "Config: $key = $value"
done < /etc/myapp/config.conf
```

---

### BASH-110 — Reading Command Output

```bash copy
# Process command output line by line
command | while read -r line; do
    echo "Processing: $line"
done

# Example
ps aux | while read -r line; do
    echo "$line"
done
```

**Example - Process Running Services:**
```bash copy
systemctl list-units --type=service --state=running | \
while read -r unit load active sub description; do
    [[ $unit == UNIT ]] && continue  # Skip header
    echo "Service: $unit - $sub"
done
```

---

### BASH-111 — Waiting for Condition

```bash copy
# Wait until file exists
while [ ! -f /tmp/ready ]; do
    echo "Waiting for file..."
    sleep 1
done
echo "File appeared!"
```

**Example - Wait for Service:**
```bash copy
#!/bin/bash
# Wait for service to be ready

service="postgresql"
timeout=30
elapsed=0

while ! systemctl is-active "$service" &>/dev/null; do
    if ((elapsed >= timeout)); then
        echo "Timeout waiting for $service" >&2
        exit 1
    fi
    
    echo "Waiting for $service... ($elapsed/$timeout)"
    sleep 1
    ((elapsed++))
done

echo "$service is ready"
```

---

### BASH-112 — Processing Multiple Files

```bash copy
# Read file list
find /var/log -name "*.log" | while read -r logfile; do
    echo "Processing: $logfile"
    grep "ERROR" "$logfile" >> errors.txt
done
```

**Example - Batch File Processing:**
```bash copy
#!/bin/bash
# Compress all large log files

find /var/log -type f -name "*.log" -size +100M | \
while read -r logfile; do
    echo "Compressing: $logfile"
    
    if gzip "$logfile"; then
        echo "  ✓ Compressed successfully"
    else
        echo "  ✗ Compression failed" >&2
    fi
done
```

</div>

</details>

---

<details>
<summary><strong>4. The until Loop</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The `until` loop executes until a condition becomes true (opposite of `while`).

---

### BASH-113 — Basic until Loop

```bash copy
# Runs until condition is true
until [ condition ]; do
    # commands
done
```

**Example:**
```bash copy
count=1

until [ $count -gt 5 ]; do
    echo "Count: $count"
    ((count++))
done
```

---

### BASH-114 — until vs while

```bash copy
# These are equivalent

# while (condition is false)
while [ ! -f /tmp/ready ]; do
    echo "Not ready..."
    sleep 1
done

# until (condition is true)
until [ -f /tmp/ready ]; do
    echo "Not ready..."
    sleep 1
done
```

**Use until when:**
- Waiting for something to become true
- Retry logic
- More readable than `while [ ! condition ]`

---

### BASH-115 — Retry Pattern

```bash copy
# Retry until success
max_attempts=5
attempt=0

until command || [ $attempt -eq $max_attempts ]; do
    ((attempt++))
    echo "Attempt $attempt failed, retrying..."
    sleep 2
done

if [ $attempt -eq $max_attempts ]; then
    echo "Failed after $max_attempts attempts" >&2
    exit 1
fi
```

**Example - Database Connection:**
```bash copy
#!/bin/bash
# Wait for database to be ready

max_wait=60
elapsed=0

until pg_isready -h localhost &>/dev/null; do
    if ((elapsed >= max_wait)); then
        echo "Database not ready after ${max_wait}s" >&2
        exit 1
    fi
    
    echo "Waiting for database... ($elapsed/$max_wait)"
    sleep 1
    ((elapsed++))
done

echo "Database is ready"
```

---

### BASH-116 — until with Command Success

```bash copy
# Run until command succeeds
until curl -s http://localhost:8080/health &>/dev/null; do
    echo "Service not ready..."
    sleep 2
done

echo "Service is healthy"
```

</div>

</details>

---

<details>
<summary><strong>5. Loop Control: break and continue</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-117 — The break Statement

Exits the loop immediately:

```bash copy
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        echo "Breaking at 5"
        break
    fi
    echo "Number: $i"
done
```

**Example - Find First Match:**
```bash copy
#!/bin/bash
# Find first available server

servers=(web01 web02 web03 web04)

for server in "${servers[@]}"; do
    if ping -c 1 "$server" &>/dev/null; then
        echo "Found available server: $server"
        available_server="$server"
        break
    fi
done

if [ -z "$available_server" ]; then
    echo "No servers available" >&2
    exit 1
fi
```

---

### BASH-118 — The continue Statement

Skips to next iteration:

```bash copy
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        echo "Skipping 5"
        continue
    fi
    echo "Number: $i"
done
```

**Example - Process Only Specific Files:**
```bash copy
#!/bin/bash
# Process only .txt files

for file in *; do
    # Skip directories
    [ -d "$file" ] && continue
    
    # Skip non-.txt files
    [[ ! "$file" == *.txt ]] && continue
    
    echo "Processing: $file"
    # Process file here
done
```

---

### BASH-119 — break with Nested Loops

```bash copy
# break N - exit N levels of loops
for i in {1..3}; do
    for j in {1..3}; do
        echo "i=$i, j=$j"
        if [ $i -eq 2 ] && [ $j -eq 2 ]; then
            break 2  # Exit both loops
        fi
    done
done
```

---

### BASH-120 — Practical break/continue

**Skip Failed Operations:**
```bash copy
for server in web{01..10}; do
    if ! ping -c 1 "$server" &>/dev/null; then
        echo "Skipping unreachable server: $server"
        continue
    fi
    
    echo "Deploying to $server..."
    ssh "$server" "systemctl restart myapp"
done
```

**Exit on Critical Error:**
```bash copy
for file in *.tar.gz; do
    echo "Extracting: $file"
    
    if ! tar -xzf "$file"; then
        echo "Critical: Extraction failed for $file" >&2
        break
    fi
done
```

</div>

</details>

---

<details>
<summary><strong>6. Reading Files Line by Line</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-121 — The Standard Pattern

```bash copy
# Best practice for reading files
while IFS= read -r line; do
    echo "$line"
done < file.txt
```

**Explanation:**
- `IFS=` → preserves leading/trailing whitespace
- `-r` → prevents backslash interpretation
- `< file.txt` → redirects file as input

---

### BASH-122 — Reading with Custom Delimiter

```bash copy
# CSV file (comma-separated)
while IFS=',' read -r col1 col2 col3; do
    echo "Column 1: $col1"
    echo "Column 2: $col2"
    echo "Column 3: $col3"
done < data.csv
```

**Example - Process /etc/passwd:**
```bash copy
#!/bin/bash
# Parse /etc/passwd

while IFS=':' read -r username password uid gid info home shell; do
    # Skip system users (UID < 1000)
    [ $uid -lt 1000 ] && continue
    
    echo "User: $username"
    echo "  UID: $uid"
    echo "  Home: $home"
    echo "  Shell: $shell"
    echo ""
done < /etc/passwd
```

---

### BASH-123 — Reading and Modifying

```bash copy
#!/bin/bash
# Read file, modify, write to new file

while IFS= read -r line; do
    # Process line
    modified_line=$(echo "$line" | sed 's/old/new/g')
    echo "$modified_line"
done < input.txt > output.txt
```

---

### BASH-124 — Skipping Lines

```bash copy
# Skip header line
{
    read  # Skip first line
    while IFS= read -r line; do
        echo "Data: $line"
    done
} < file_with_header.txt

# Skip multiple lines
{
    read  # Skip line 1
    read  # Skip line 2
    while IFS= read -r line; do
        echo "Data: $line"
    done
} < file.txt
```

---

### BASH-125 — Reading Until Pattern

```bash copy
# Read until marker
while IFS= read -r line; do
    [[ $line == "END" ]] && break
    echo "$line"
done < file.txt
```

**Example - Extract Section:**
```bash copy
#!/bin/bash
# Extract section between markers

in_section=false

while IFS= read -r line; do
    if [[ $line == "START_SECTION" ]]; then
        in_section=true
        continue
    fi
    
    if [[ $line == "END_SECTION" ]]; then
        break
    fi
    
    if $in_section; then
        echo "$line"
    fi
done < config.txt
```

---

### BASH-126 — Line Counter

```bash copy
#!/bin/bash
# Count and number lines

line_number=0

while IFS= read -r line; do
    ((line_number++))
    echo "$line_number: $line"
done < file.txt
```

</div>

</details>

---

<details>
<summary><strong>7. Infinite Loops</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-127 — Creating Infinite Loops

```bash copy
# while infinite loop
while true; do
    echo "Running..."
    sleep 1
done

# for infinite loop (rare)
for ((;;)); do
    echo "Running..."
    sleep 1
done

# until infinite loop
until false; do
    echo "Running..."
    sleep 1
done
```

---

### BASH-128 — Service Monitor Loop

```bash copy
#!/bin/bash
# Monitor service continuously

service="nginx"

while true; do
    if systemctl is-active "$service" &>/dev/null; then
        echo "$(date): $service is running"
    else
        echo "$(date): $service is down, restarting..."
        systemctl restart "$service"
    fi
    
    sleep 10
done
```

---

### BASH-129 — Menu Loop

```bash copy
#!/bin/bash
# Interactive menu

while true; do
    echo ""
    echo "=== Service Manager ==="
    echo "1) Start service"
    echo "2) Stop service"
    echo "3) Restart service"
    echo "4) Status"
    echo "5) Exit"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1) systemctl start myapp ;;
        2) systemctl stop myapp ;;
        3) systemctl restart myapp ;;
        4) systemctl status myapp ;;
        5) echo "Exiting"; break ;;
        *) echo "Invalid option" ;;
    esac
done
```

---

### BASH-130 — Rate-Limited Loop

```bash copy
#!/bin/bash
# Process queue with rate limiting

requests_per_minute=60
sleep_time=$((60 / requests_per_minute))

while true; do
    # Check if queue has items
    if [ ! -f /tmp/queue ]; then
        echo "Queue empty, waiting..."
        sleep 5
        continue
    fi
    
    # Process one item
    item=$(head -n 1 /tmp/queue)
    echo "Processing: $item"
    # Process item here
    
    # Remove from queue
    sed -i '1d' /tmp/queue
    
    # Rate limit
    sleep $sleep_time
done
```

---

### BASH-131 — Loop with Graceful Shutdown

```bash copy
#!/bin/bash
# Infinite loop with signal handling

running=true

# Trap SIGINT and SIGTERM
trap 'running=false' SIGINT SIGTERM

echo "Starting service (Ctrl+C to stop)..."

while $running; do
    echo "$(date): Processing..."
    # Do work here
    sleep 2
done

echo "Shutting down gracefully..."
# Cleanup here
```

</div>

</details>

---

<details>
<summary><strong>8. C-Style Loops</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-132 — C-Style for Loop

```bash copy
# Traditional C syntax
for ((i = 0; i < 10; i++)); do
    echo "Number: $i"
done

# Multiple variables
for ((i = 0, j = 10; i < 10; i++, j--)); do
    echo "i=$i, j=$j"
done
```

---

### BASH-133 — Common C-Style Patterns

**Count Up:**
```bash copy
for ((i = 1; i <= 5; i++)); do
    echo "Count: $i"
done
```

**Count Down:**
```bash copy
for ((i = 5; i > 0; i--)); do
    echo "Countdown: $i"
done
```

**Step by N:**
```bash copy
for ((i = 0; i <= 100; i += 10)); do
    echo "Value: $i"
done
```

**Array Indexing:**
```bash copy
servers=(web01 web02 web03)

for ((i = 0; i < ${#servers[@]}; i++)); do
    echo "Server $i: ${servers[$i]}"
done
```

---

### BASH-134 — When to Use C-Style

**Use C-style when:**
- Need precise index control
- Complex increment logic
- Multiple loop variables
- Coming from C/Java background

**Use standard for when:**
- Iterating over collections
- File globbing
- Simpler intent

**Example - Matrix Processing:**
```bash copy
#!/bin/bash
# Process 2D array

rows=5
cols=10

for ((i = 0; i < rows; i++)); do
    for ((j = 0; j < cols; j++)); do
        echo -n "[$i,$j] "
    done
    echo
done
```

</div>

</details>

---

<details>
<summary><strong>9. Iterating Over Arrays</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-135 — Array Iteration

```bash copy
# Indexed array
servers=(web01 web02 web03)

# Iterate over values
for server in "${servers[@]}"; do
    echo "Server: $server"
done

# Iterate with indices
for i in "${!servers[@]}"; do
    echo "Index $i: ${servers[$i]}"
done
```

---

### BASH-136 — Associative Array Iteration

```bash copy
# Declare associative array
declare -A ports
ports[http]=80
ports[https]=443
ports[ssh]=22

# Iterate over keys
for service in "${!ports[@]}"; do
    echo "$service: ${ports[$service]}"
done
```

**Example - Environment Configuration:**
```bash copy
#!/bin/bash
# Deploy to multiple environments

declare -A environments
environments[dev]="dev-cluster"
environments[staging]="staging-cluster"
environments[prod]="prod-cluster"

for env in "${!environments[@]}"; do
    cluster="${environments[$env]}"
    echo "Deploying to $env ($cluster)..."
    kubectl config use-context "$cluster"
    kubectl apply -f deployment.yaml
done
```

---

### BASH-137 — Parallel Processing with Arrays

```bash copy
#!/bin/bash
# Process array items in parallel

servers=(web01 web02 web03 web04 web05)

for server in "${servers[@]}"; do
    (
        echo "Pinging $server..."
        if ping -c 1 "$server" &>/dev/null; then
            echo "$server: OK"
        else
            echo "$server: FAILED"
        fi
    ) &
done

# Wait for all background jobs
wait
echo "All servers checked"
```

---

### BASH-138 — Array Modification During Iteration

```bash copy
# Build new array during iteration
old_array=(1 2 3 4 5)
new_array=()

for num in "${old_array[@]}"; do
    # Double each number
    new_array+=($((num * 2)))
done

echo "Old: ${old_array[@]}"
echo "New: ${new_array[@]}"
```

</div>

</details>

---

<details>
<summary><strong>10. Nested Loops</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-139 — Basic Nested Loops

```bash copy
# Two levels
for i in {1..3}; do
    for j in {1..3}; do
        echo "i=$i, j=$j"
    done
done
```

---

### BASH-140 — Processing Multi-Dimensional Data

```bash copy
#!/bin/bash
# Deploy to multiple environments and regions

environments=(dev staging prod)
regions=(us-east us-west eu-west)

for env in "${environments[@]}"; do
    for region in "${regions[@]}"; do
        echo "Deploying to $env in $region..."
        kubectl config use-context "${env}-${region}"
        kubectl apply -f deployment.yaml
    done
done
```

---

### BASH-141 — File Matrix Processing

```bash copy
#!/bin/bash
# Process all combinations

directories=(logs configs backups)
extensions=(txt log conf)

for dir in "${directories[@]}"; do
    for ext in "${extensions[@]}"; do
        echo "Processing: $dir/*.$ext"
        for file in "$dir"/*."$ext"; do
            [ -f "$file" ] || continue
            echo "  File: $file"
        done
    done
done
```

---

### BASH-142 — Breaking Out of Nested Loops

```bash copy
#!/bin/bash
# Find first match in 2D structure

found=false

for i in {1..10}; do
    for j in {1..10}; do
        if [ $((i * j)) -eq 42 ]; then
            echo "Found: $i * $j = 42"
            found=true
            break 2  # Exit both loops
        fi
    done
done

if ! $found; then
    echo "Not found"
fi
```

</div>

</details>

---

<details>
<summary><strong>11. Loop Performance Considerations</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-143 — Avoid Subshells in Loops

```bash copy
# SLOW - creates subshell per iteration
count=0
cat file.txt | while read line; do
    ((count++))
done
echo $count  # Will be 0! (subshell doesn't affect parent)

# FAST - no subshell
count=0
while read line; do
    ((count++))
done < file.txt
echo $count  # Correct count
```

---

### BASH-144 — Minimize External Commands

```bash copy
# SLOW - external command per iteration
for file in *.txt; do
    size=$(du -b "$file" | cut -f1)
    echo "$file: $size bytes"
done

# FASTER - use built-in features
for file in *.txt; do
    size=$(wc -c < "$file")
    echo "$file: $size bytes"
done
```

---

### BASH-145 — Batch Operations

```bash copy
# SLOW - one operation per file
for file in *.txt; do
    cp "$file" backup/
done

# FASTER - batch operation
cp *.txt backup/
```

---

### BASH-146 — Parallel Processing

```bash copy
#!/bin/bash
# Process files in parallel

max_jobs=4
job_count=0

for file in *.log; do
    {
        echo "Processing: $file"
        gzip "$file"
    } &
    
    ((job_count++))
    
    # Limit concurrent jobs
    if ((job_count >= max_jobs)); then
        wait -n  # Wait for any job to finish
        ((job_count--))
    fi
done

wait  # Wait for remaining jobs
echo "All files processed"
```

</div>

</details>

---

<details>
<summary><strong>12. Common Loop Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-147 — Retry with Backoff

```bash copy
#!/bin/bash
# Exponential backoff retry

max_attempts=5
wait_time=1

for attempt in $(seq 1 $max_attempts); do
    echo "Attempt $attempt..."
    
    if command; then
        echo "Success!"
        exit 0
    fi
    
    if [ $attempt -lt $max_attempts ]; then
        echo "Failed, waiting ${wait_time}s..."
        sleep $wait_time
        wait_time=$((wait_time * 2))  # Exponential backoff
    fi
done

echo "Failed after $max_attempts attempts" >&2
exit 1
```

---

### BASH-148 — Progress Indicator

```bash copy
#!/bin/bash
# Show progress while processing

total=100

for ((i = 1; i <= total; i++)); do
    # Process item
    sleep 0.1
    
    # Show progress
    percent=$((i * 100 / total))
    printf "\rProgress: [%-50s] %d%%" \
        $(printf '#%.0s' $(seq 1 $((percent / 2)))) \
        $percent
done

echo ""  # New line after progress bar
echo "Complete!"
```

---

### BASH-149 — Batch Processing with Status

```bash copy
#!/bin/bash
# Process files with status tracking

files=(*.txt)
total=${#files[@]}
success=0
failed=0

for file in "${files[@]}"; do
    if process_file "$file"; then
        ((success++))
    else
        ((failed++))
    fi
done

echo "Processed: $total files"
echo "Success: $success"
echo "Failed: $failed"
```

---

### BASH-150 — Rate Limiting

```bash copy
#!/bin/bash
# Process with rate limit

items=(item1 item2 item3)
requests_per_second=2
sleep_time=$(echo "scale=2; 1 / $requests_per_second" | bc)

for item in "${items[@]}"; do
    echo "Processing: $item"
    # Process item
    
    sleep $sleep_time
done
```

---

### BASH-151 — Collect Results

```bash copy
#!/bin/bash
# Collect results from multiple operations

results=()

for server in web{01..05}; do
    result=$(ssh "$server" "uptime")
    results+=("$server: $result")
done

# Display all results
for result in "${results[@]}"; do
    echo "$result"
done
```

---

### BASH-152 — Skip and Resume

```bash copy
#!/bin/bash
# Resume processing from checkpoint

checkpoint_file="/tmp/checkpoint"
start_from=0

# Load checkpoint
if [ -f "$checkpoint_file" ]; then
    start_from=$(cat "$checkpoint_file")
    echo "Resuming from index $start_from"
fi

files=(*.txt)

for i in "${!files[@]}"; do
    # Skip already processed
    [ $i -lt $start_from ] && continue
    
    file="${files[$i]}"
    echo "Processing: $file"
    
    # Process file
    # ...
    
    # Update checkpoint
    echo $((i + 1)) > "$checkpoint_file"
done

# Remove checkpoint on completion
rm -f "$checkpoint_file"
```

</div>

</details>

---

<details>
<summary><strong>13. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Log Aggregation

```bash copy
#!/bin/bash
# aggregate_logs.sh - Collect logs from multiple servers

set -euo pipefail

servers=(web01 web02 web03 app01 app02)
output_dir="/tmp/logs_$(date +%Y%m%d_%H%M%S)"
failed_servers=()

# Create output directory
mkdir -p "$output_dir"

echo "Collecting logs from ${#servers[@]} servers..."
echo "Output directory: $output_dir"
echo ""

for server in "${servers[@]}"; do
    echo "Processing: $server"
    server_dir="$output_dir/$server"
    mkdir -p "$server_dir"
    
    # Check if server is reachable
    if ! ping -c 1 -W 2 "$server" &>/dev/null; then
        echo "  ✗ Server unreachable"
        failed_servers+=("$server")
        continue
    fi
    
    # Collect logs
    log_files=(
        "/var/log/syslog"
        "/var/log/auth.log"
        "/var/log/myapp/app.log"
    )
    
    for log in "${log_files[@]}"; do
        log_name=$(basename "$log")
        echo "  Fetching: $log_name"
        
        if ssh "$server" "[ -f $log ]"; then
            scp -q "$server:$log" "$server_dir/$log_name" 2>/dev/null || {
                echo "    ⚠ Failed to copy $log_name"
            }
        else
            echo "    - Not found: $log"
        fi
    done
    
    echo "  ✓ Complete"
    echo ""
done

# Create archive
echo "Creating archive..."
archive_file="${output_dir}.tar.gz"
tar -czf "$archive_file" -C "$(dirname "$output_dir")" "$(basename "$output_dir")"

archive_size=$(du -h "$archive_file" | awk '{print $1}')
echo "✓ Archive created: $archive_file ($archive_size)"

# Report
echo ""
echo "=== Summary ==="
echo "Total servers: ${#servers[@]}"
echo "Successful: $((${#servers[@]} - ${#failed_servers[@]}))"
echo "Failed: ${#failed_servers[@]}"

if [ ${#failed_servers[@]} -gt 0 ]; then
    echo ""
    echo "Failed servers:"
    for server in "${failed_servers[@]}"; do
        echo "  - $server"
    done
fi

# Cleanup temp directory
rm -rf "$output_dir"
```

---

### Scenario 2: Database Backup Rotation

```bash copy
#!/bin/bash
# backup_rotate.sh - Backup multiple databases with rotation

set -euo pipefail

databases=(webapp_prod analytics_prod reporting_prod)
backup_dir="/backups/databases"
retention_days=7
timestamp=$(date +%Y%m%d_%H%M%S)

mkdir -p "$backup_dir"

echo "Starting database backups..."
echo "Timestamp: $timestamp"
echo "Retention: $retention_days days"
echo ""

successful=0
failed=0

for db in "${databases[@]}"; do
    echo "Backing up: $db"
    backup_file="$backup_dir/${db}_${timestamp}.sql"
    
    # Create backup
    if pg_dump "$db" > "$backup_file" 2>/dev/null; then
        # Check if backup is not empty
        if [ -s "$backup_file" ]; then
            # Compress
            gzip "$backup_file"
            backup_file="${backup_file}.gz"
            
            size=$(du -h "$backup_file" | awk '{print $1}')
            echo "  ✓ Complete: $size"
            ((successful++))
        else
            echo "  ✗ Backup is empty"
            rm -f "$backup_file"
            ((failed++))
        fi
    else
        echo "  ✗ Backup failed"
        rm -f "$backup_file"
        ((failed++))
    fi
    
    # Rotate old backups
    echo "  Cleaning old backups..."
    deleted=0
    
    while IFS= read -r old_backup; do
        rm "$old_backup"
        ((deleted++))
    done < <(find "$backup_dir" -name "${db}_*.sql.gz" -mtime +$retention_days)
    
    if [ $deleted -gt 0 ]; then
        echo "  Removed $deleted old backup(s)"
    fi
    
    echo ""
done

# Summary
echo "=== Backup Summary ==="
echo "Total databases: ${#databases[@]}"
echo "Successful: $successful"
echo "Failed: $failed"

# Calculate total backup size
total_size=$(du -sh "$backup_dir" | awk '{print $1}')
backup_count=$(find "$backup_dir" -name "*.sql.gz" | wc -l)

echo "Total backups: $backup_count files"
echo "Total size: $total_size"

# Exit with error if any failed
[ $failed -gt 0 ] && exit 1
exit 0
```

---

### Scenario 3: Certificate Expiration Check

```bash copy
#!/bin/bash
# check_certs.sh - Check SSL certificates across domains

set -euo pipefail

domains=(
    "example.com:443"
    "api.example.com:443"
    "www.example.com:443"
    "cdn.example.com:443"
)

warn_days=30
critical_days=7

echo "Checking SSL certificates..."
echo ""

expiring_soon=()
expired=()
errors=()

for domain_port in "${domains[@]}"; do
    domain="${domain_port%:*}"
    port="${domain_port#*:}"
    
    echo "Checking: $domain:$port"
    
    # Get certificate expiration
    expiry=$(echo | openssl s_client -servername "$domain" -connect "$domain:$port" 2>/dev/null | \
             openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
    
    if [ -z "$expiry" ]; then
        echo "  ✗ Failed to get certificate"
        errors+=("$domain")
        echo ""
        continue
    fi
    
    # Calculate days until expiration
    expiry_epoch=$(date -d "$expiry" +%s)
    now_epoch=$(date +%s)
    days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
    
    # Status
    if [ $days_left -lt 0 ]; then
        echo "  ✗ EXPIRED: $days_left days ago"
        expired+=("$domain")
    elif [ $days_left -le $critical_days ]; then
        echo "  ⚠ CRITICAL: $days_left days remaining"
        expiring_soon+=("$domain")
    elif [ $days_left -le $warn_days ]; then
        echo "  ⚠ WARNING: $days_left days remaining"
        expiring_soon+=("$domain")
    else
        echo "  ✓ OK: $days_left days remaining"
    fi
    
    echo "  Expires: $expiry"
    echo ""
done

# Summary
echo "=== Certificate Summary ==="
echo "Total domains: ${#domains[@]}"
echo "OK: $((${#domains[@]} - ${#expiring_soon[@]} - ${#expired[@]} - ${#errors[@]}))"
echo "Expiring soon: ${#expiring_soon[@]}"
echo "Expired: ${#expired[@]}"
echo "Errors: ${#errors[@]}"

# Details
if [ ${#expiring_soon[@]} -gt 0 ]; then
    echo ""
    echo "Domains expiring soon:"
    for domain in "${expiring_soon[@]}"; do
        echo "  - $domain"
    done
fi

if [ ${#expired[@]} -gt 0 ]; then
    echo ""
    echo "EXPIRED domains:"
    for domain in "${expired[@]}"; do
        echo "  - $domain"
    done
fi

if [ ${#errors[@]} -gt 0 ]; then
    echo ""
    echo "Domains with errors:"
    for domain in "${errors[@]}"; do
        echo "  - $domain"
    done
fi

# Alert if issues found
if [ ${#expiring_soon[@]} -gt 0 ] || [ ${#expired[@]} -gt 0 ]; then
    exit 1
fi

exit 0
```

---

### Scenario 4: Container Health Check

```bash copy
#!/bin/bash
# container_health.sh - Check health of all containers

set -euo pipefail

echo "Checking container health..."
echo ""

unhealthy=()
stopped=()
healthy=0

# Get all containers
while IFS= read -r container; do
    # Get container details
    name=$(docker inspect --format='{{.Name}}' "$container" | sed 's/\///')
    status=$(docker inspect --format='{{.State.Status}}' "$container")
    health=$(docker inspect --format='{{.State.Health.Status}}' "$container" 2>/dev/null || echo "none")
    
    echo "Container: $name"
    echo "  Status: $status"
    
    # Check status
    if [ "$status" != "running" ]; then
        echo "  ✗ Container not running"
        stopped+=("$name")
        echo ""
        continue
    fi
    
    # Check health
    if [ "$health" = "none" ]; then
        echo "  - No health check configured"
        ((healthy++))
    elif [ "$health" = "healthy" ]; then
        echo "  ✓ Healthy"
        ((healthy++))
    else
        echo "  ✗ Unhealthy: $health"
        unhealthy+=("$name")
        
        # Get last 5 logs
        echo "  Recent logs:"
        docker logs --tail 5 "$container" 2>&1 | sed 's/^/    /'
    fi
    
    echo ""
done < <(docker ps -aq)

# Summary
total=$((healthy + ${#unhealthy[@]} + ${#stopped[@]}))

echo "=== Health Summary ==="
echo "Total containers: $total"
echo "Healthy: $healthy"
echo "Unhealthy: ${#unhealthy[@]}"
echo "Stopped: ${#stopped[@]}"

if [ ${#unhealthy[@]} -gt 0 ]; then
    echo ""
    echo "Unhealthy containers:"
    for container in "${unhealthy[@]}"; do
        echo "  - $container"
    done
fi

if [ ${#stopped[@]} -gt 0 ]; then
    echo ""
    echo "Stopped containers:"
    for container in "${stopped[@]}"; do
        echo "  - $container"
    done
fi

# Exit with error if issues found
[ ${#unhealthy[@]} -gt 0 ] || [ ${#stopped[@]} -gt 0 ] && exit 1
exit 0
```

---

### Scenario 5: Parallel Deployment

```bash copy
#!/bin/bash
# parallel_deploy.sh - Deploy to multiple servers in parallel

set -euo pipefail

servers=(web01 web02 web03 web04 web05)
version=${1:?"Version required"}
max_parallel=3

echo "Deploying version: $version"
echo "Target servers: ${#servers[@]}"
echo "Max parallel: $max_parallel"
echo ""

# Results
declare -A results
running_jobs=0

deploy_server() {
    local server=$1
    local start_time=$(date +%s)
    
    echo "[$server] Starting deployment..."
    
    # Simulate deployment
    if ssh "$server" "docker pull myapp:$version && \
                      docker stop myapp && \
                      docker rm myapp && \
                      docker run -d --name myapp myapp:$version" &>/dev/null; then
        
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        echo "[$server] ✓ Complete (${duration}s)"
        results[$server]="success"
    else
        echo "[$server] ✗ Failed"
        results[$server]="failed"
    fi
}

# Deploy with parallelism limit
for server in "${servers[@]}"; do
    deploy_server "$server" &
    ((running_jobs++))
    
    # Wait if max parallel reached
    if [ $running_jobs -ge $max_parallel ]; then
        wait -n
        ((running_jobs--))
    fi
done

# Wait for remaining jobs
wait

echo ""
echo "=== Deployment Summary ==="

success=0
failed=0

for server in "${servers[@]}"; do
    if [ "${results[$server]}" = "success" ]; then
        ((success++))
    else
        ((failed++))
    fi
done

echo "Total: ${#servers[@]}"
echo "Success: $success"
echo "Failed: $failed"

if [ $failed -gt 0 ]; then
    echo ""
    echo "Failed servers:"
    for server in "${servers[@]}"; do
        if [ "${results[$server]}" = "failed" ]; then
            echo "  - $server"
        fi
    done
    exit 1
fi

echo ""
echo "✓ All deployments successful"
exit 0
```

</div>

</details>

---

<details>
<summary><strong>14. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# for loop - list
for item in item1 item2 item3; do
    echo "$item"
done
```

```bash copy
# for loop - files
for file in *.txt; do
    echo "$file"
done
```

```bash copy
# for loop - sequence
for i in {1..10}; do
    echo "$i"
done
```

```bash copy
# for loop - C-style
for ((i = 0; i < 10; i++)); do
    echo "$i"
done
```

```bash copy
# for loop - array
for item in "${array[@]}"; do
    echo "$item"
done
```

```bash copy
# while loop
while [ condition ]; do
    # commands
done
```

```bash copy
# while loop - arithmetic
while ((count < 10)); do
    echo "$count"
    ((count++))
done
```

```bash copy
# Read file line by line
while IFS= read -r line; do
    echo "$line"
done < file.txt
```

```bash copy
# until loop
until [ condition ]; do
    # commands
done
```

```bash copy
# Infinite loop
while true; do
    # commands
    sleep 1
done
```

```bash copy
# break - exit loop
for i in {1..10}; do
    [ $i -eq 5 ] && break
    echo "$i"
done
```

```bash copy
# continue - skip iteration
for i in {1..10}; do
    [ $i -eq 5 ] && continue
    echo "$i"
done
```

```bash copy
# Nested loops
for i in {1..3}; do
    for j in {1..3}; do
        echo "i=$i, j=$j"
    done
done
```

```bash copy
# Parallel execution
for server in web{01..05}; do
    ping -c 1 "$server" &
done
wait
```

</div>

</details>

---

<details>
<summary><strong>15. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- `for` loops iterate over lists
- `while` loops run while condition is true
- `until` loops run until condition is true
- Always use `while IFS= read -r` for reading files
- Use `break` to exit loops, `continue` to skip iteration
- Background jobs with `&` for parallel processing

---

**Loop Types:**

| Type | Use Case | Example |
|------|----------|---------|
| `for item in list` | Iterate over items | `for i in {1..5}; do` |
| `for file in *.txt` | Process files | `for f in *.txt; do` |
| `for ((i=0; i<10; i++))` | C-style counter | `for ((i=0; i<10; i++)); do` |
| `while [ condition ]` | Condition-based | `while [ $count -lt 10 ]; do` |
| `while IFS= read -r` | Read files | `while IFS= read -r line; do` |
| `until [ condition ]` | Run until true | `until [ -f ready ]; do` |

---

**Common Patterns:**

```bash copy
# Process all files
for file in *.txt; do
    [ -f "$file" ] || continue
    process "$file"
done

# Read file properly
while IFS= read -r line; do
    echo "$line"
done < file.txt

# Retry logic
until command || [ $attempts -eq $max ]; do
    ((attempts++))
    sleep 2
done

# Parallel processing
for server in "${servers[@]}"; do
    process_server "$server" &
done
wait

# Progress counter
total=${#items[@]}
for i in "${!items[@]}"; do
    percent=$((i * 100 / total))
    echo "Progress: $percent%"
done

# Rate limiting
for item in "${items[@]}"; do
    process "$item"
    sleep 0.5  # Rate limit
done
```

---

**Loop Control:**

| Command | Effect |
|---------|--------|
| `break` | Exit current loop |
| `break 2` | Exit 2 levels of loops |
| `continue` | Skip to next iteration |
| `continue 2` | Skip to next of outer loop |

---

**Performance Tips:**

- Avoid pipes into `while` (creates subshell)
- Use `< file` instead of `cat file |`
- Minimize external commands in loops
- Use background jobs (`&`) for parallel work
- Batch operations when possible

---

**File Reading Best Practices:**

```bash copy
# ALWAYS use this pattern for files
while IFS= read -r line; do
    # process line
done < file.txt

# With custom delimiter (CSV)
while IFS=',' read -r col1 col2 col3; do
    # process columns
done < file.csv

# Skip header
{
    read  # Skip first line
    while IFS= read -r line; do
        # process data
    done
} < file.txt
```

---

**What's Next:**
Now that you can repeat operations with loops, the next file covers functions and modularity — how to organize code into reusable blocks.

</div>

</details>

---