# Package Management

Every process you learned to manage runs software. That software has to come from somewhere — compiled binaries, libraries, configuration templates, documentation. In the early days, you'd download source code, resolve dependencies manually, compile, and pray it worked. One missing library and you'd spend hours hunting it down.

Package managers solved this chaos. They bundle software into packages, track what's installed, resolve dependencies automatically, and handle updates cleanly. When you run `apt install nginx`, hundreds of decisions happen behind the scenes: which version fits your system, what libraries are needed, where files should go, how to configure defaults.

Understanding package management means understanding how software enters your system, how to keep it secure and updated, and how to troubleshoot when packages conflict. This is foundational DevOps knowledge — every server you provision, every container you build, starts with package management.

---

## Table of Contents

1. [How Package Management Works](#1-how-package-management-works)
2. [Debian/Ubuntu — APT and dpkg](#2-debianubuntu--apt-and-dpkg)
3. [RHEL/Rocky/Alma — DNF and rpm](#3-rhelrockyalma--dnf-and-rpm)
4. [Repositories — Where Packages Live](#4-repositories--where-packages-live)
5. [Searching and Inspecting Packages](#5-searching-and-inspecting-packages)
6. [Installing and Removing Software](#6-installing-and-removing-software)
7. [Updating and Upgrading](#7-updating-and-upgrading)
8. [Handling Dependencies](#8-handling-dependencies)
9. [Building from Source](#9-building-from-source)
10. [Where We Go From Here](#10-where-we-go-from-here)

---

<details>
<summary><strong>1. How Package Management Works</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

A package is an archive containing software files plus metadata. The metadata describes what's inside, what the package depends on, where files should be installed, and what scripts to run during installation.

### The two layers

Package management has two layers:

**Low-level tools** (`dpkg`, `rpm`) handle individual packages — extracting files, running install scripts, tracking what's installed. They don't resolve dependencies; if a package needs libssl and you don't have it, the install fails.

**High-level tools** (`apt`, `dnf`) work with repositories — remote servers hosting packages. They calculate dependencies, download everything needed, and call the low-level tools to install. This is what you use daily.

### Package formats

Two dominant formats exist:

**.deb** — Used by Debian, Ubuntu, and derivatives. Managed by `dpkg` and `apt`.

**.rpm** — Used by Red Hat, Fedora, CentOS, Rocky, Alma. Managed by `rpm` and `dnf` (formerly `yum`).

The concepts are identical; only the commands differ.

### What's inside a package

A typical package contains:

- **Binaries** — Executable programs
- **Libraries** — Shared code other programs use
- **Config files** — Default configurations
- **Documentation** — Man pages, README files
- **Metadata** — Dependencies, version, maintainer info
- **Scripts** — Pre/post install/remove actions

When you install nginx, the package places binaries in `/usr/sbin`, config files in `/etc/nginx`, documentation in `/usr/share/doc/nginx`, and runs scripts to create the nginx user and set up initial directories.

### The package database

Your system maintains a database of installed packages. Every file from every package is tracked. This lets you:

- See which package owns a file
- List all files a package installed
- Detect if package files were modified
- Cleanly remove everything when uninstalling

</div>
</details>

---

<details>
<summary><strong>2. Debian/Ubuntu — APT and dpkg</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

If you're on Ubuntu, Debian, or their derivatives, APT is your package manager.

### apt vs apt-get

Both exist. `apt` is newer, designed for interactive use with friendlier output and progress bars. `apt-get` is older, more stable for scripting. For daily use, prefer `apt`.

### Essential commands

```bash
sudo apt update                    # Refresh package lists from repositories
sudo apt upgrade                   # Upgrade all installed packages
sudo apt install nginx             # Install a package
sudo apt remove nginx              # Remove package (keep config)
sudo apt purge nginx               # Remove package and config files
sudo apt autoremove                # Remove unused dependencies
sudo apt search streaming          # Search package names/descriptions
sudo apt show nginx                # Show package details
```

### The update/upgrade distinction

`apt update` doesn't install anything. It downloads fresh package lists from repositories — learning what versions are available. Always run this before installing or upgrading.

`apt upgrade` actually upgrades packages to newer versions based on those lists.

A typical maintenance session:

```bash
sudo apt update && sudo apt upgrade -y
```

### Working with dpkg

For low-level operations or local `.deb` files:

```bash
sudo dpkg -i package.deb           # Install local deb file
sudo dpkg -r nginx                 # Remove package
sudo dpkg -l                       # List all installed packages
sudo dpkg -L nginx                 # List files installed by package
sudo dpkg -S /usr/sbin/nginx       # Find which package owns a file
```

If `dpkg -i` fails due to missing dependencies:

```bash
sudo apt --fix-broken install      # Resolve and install missing deps
```

### Package cache

Downloaded packages live in `/var/cache/apt/archives/`. To reclaim disk space:

```bash
sudo apt clean                     # Remove all cached packages
sudo apt autoclean                 # Remove only obsolete cached packages
```

</div>
</details>

---

<details>
<summary><strong>3. RHEL/Rocky/Alma — DNF and rpm</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

On Red Hat Enterprise Linux, Rocky Linux, AlmaLinux, and Fedora, DNF is the package manager. It replaced YUM, though `yum` commands still work as aliases.

### Essential commands

```bash
sudo dnf check-update              # Check for available updates
sudo dnf upgrade                   # Upgrade all packages
sudo dnf install nginx             # Install a package
sudo dnf remove nginx              # Remove package
sudo dnf autoremove                # Remove unused dependencies
sudo dnf search streaming          # Search packages
sudo dnf info nginx                # Show package details
sudo dnf list installed            # List installed packages
```

### DNF vs YUM

DNF is faster, handles dependencies better, and has cleaner code. If you learned YUM, the commands are nearly identical:

| YUM | DNF |
|-----|-----|
| yum install | dnf install |
| yum update | dnf upgrade |
| yum search | dnf search |
| yum info | dnf info |

### Working with rpm

For low-level operations:

```bash
sudo rpm -ivh package.rpm          # Install local rpm (-i install, -v verbose, -h progress)
sudo rpm -e nginx                  # Erase (remove) package
sudo rpm -qa                       # Query all installed packages
sudo rpm -ql nginx                 # List files from package
sudo rpm -qf /usr/sbin/nginx       # Find which package owns a file
sudo rpm -qi nginx                 # Query package info
```

### Groups and modules

DNF can install groups of related packages:

```bash
dnf group list                     # Show available groups
sudo dnf group install "Development Tools"   # Install a group
```

On RHEL 8+ and derivatives, modules provide multiple versions:

```bash
dnf module list nginx              # Show available nginx versions
sudo dnf module enable nginx:1.20  # Enable specific version stream
sudo dnf install nginx             # Install from enabled stream
```

</div>
</details>

---

<details>
<summary><strong>4. Repositories — Where Packages Live</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Repositories are servers hosting packages. Your system is configured to know about certain repositories, and package managers query them to find software.

### Default repositories

Distributions ship with official repositories:

- **Ubuntu**: main, universe, restricted, multiverse
- **Debian**: main, contrib, non-free
- **RHEL/Rocky/Alma**: BaseOS, AppStream

These contain thousands of packages tested to work together.

### Adding repositories — Debian/Ubuntu

Third-party repositories expand your options. The modern approach uses signed repository files:

```bash
# Add Docker's official repository (example)
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list

sudo apt update
```

Repository configurations live in:
- `/etc/apt/sources.list` — Main file
- `/etc/apt/sources.list.d/*.list` — Additional repositories

### Adding repositories — RHEL/DNF

```bash
# Add EPEL repository (Extra Packages for Enterprise Linux)
sudo dnf install epel-release

# Or add a repo file directly
sudo dnf config-manager --add-repo https://example.com/repo.repo
```

Repository configurations live in:
- `/etc/yum.repos.d/*.repo`

### PPAs (Ubuntu)

Personal Package Archives are Ubuntu-specific shortcuts for third-party repos:

```bash
sudo add-apt-repository ppa:ondrej/php
sudo apt update
```

Convenient but less scrutinized than official repos. Use with caution in production.

### Repository priorities

When multiple repositories provide the same package, priority determines which wins. On RHEL/DNF, set `priority=` in repo files. On Debian/Ubuntu, use apt pinning in `/etc/apt/preferences.d/`.

### Security considerations

Only add repositories you trust. Third-party repos can:
- Push malicious packages
- Break your system with incompatible versions
- Disappear, leaving you unable to update

For production servers, stick to official repos plus well-established third-party sources (Docker, Nginx, PostgreSQL official repos).

</div>
</details>

---

<details>
<summary><strong>5. Searching and Inspecting Packages</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Before installing, you often need to find the right package or understand what it contains.

### Searching

**Debian/Ubuntu:**

```bash
apt search nginx                   # Search names and descriptions
apt-cache search nginx             # Same, older command
apt search --names-only nginx      # Search only package names
```

**RHEL/DNF:**

```bash
dnf search nginx                   # Search names and descriptions
dnf search --all nginx             # Search everything including summaries
```

### Package information

**Debian/Ubuntu:**

```bash
apt show nginx                     # Detailed info (version, deps, size)
apt-cache policy nginx             # Show available versions and sources
apt depends nginx                  # Show dependencies
apt rdepends nginx                 # Show reverse dependencies (what depends on it)
```

**RHEL/DNF:**

```bash
dnf info nginx                     # Detailed info
dnf repoquery --depends nginx      # Show dependencies
dnf repoquery --whatrequires nginx # Show reverse dependencies
```

### Listing files

See what a package installs — even before installing:

**Debian/Ubuntu:**

```bash
dpkg -L nginx                      # Files from installed package
apt-file list nginx                # Files from any package (install apt-file first)
```

**RHEL/DNF:**

```bash
rpm -ql nginx                      # Files from installed package
dnf repoquery -l nginx             # Files from repo package
```

### Finding which package owns a file

When you find a file and want to know its source:

**Debian/Ubuntu:**

```bash
dpkg -S /usr/sbin/nginx
```

Output: `nginx-core: /usr/sbin/nginx`

**RHEL/DNF:**

```bash
rpm -qf /usr/sbin/nginx
```

Output: `nginx-1.20.1-1.el8.x86_64`

### Checking if a package is installed

**Debian/Ubuntu:**

```bash
dpkg -l | grep nginx
apt list --installed | grep nginx
```

**RHEL/DNF:**

```bash
rpm -q nginx
dnf list installed nginx
```

</div>
</details>

---

<details>
<summary><strong>6. Installing and Removing Software</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The core operations — getting software on and off your system.

### Installing

**Debian/Ubuntu:**

```bash
sudo apt install nginx                     # Single package
sudo apt install nginx postgresql redis    # Multiple packages
sudo apt install nginx=1.18.0-0ubuntu1     # Specific version
sudo apt install ./local-package.deb       # Local file
```

**RHEL/DNF:**

```bash
sudo dnf install nginx                     # Single package
sudo dnf install nginx postgresql redis    # Multiple packages
sudo dnf install nginx-1.20.1              # Specific version
sudo dnf install ./local-package.rpm       # Local file
```

### Non-interactive installation

For scripts and automation, avoid prompts:

```bash
sudo apt install -y nginx                  # Assume yes
sudo dnf install -y nginx                  # Assume yes

# Or set environment variable
export DEBIAN_FRONTEND=noninteractive
sudo apt install nginx
```

### Removing

**Debian/Ubuntu:**

```bash
sudo apt remove nginx              # Remove package, keep config files
sudo apt purge nginx               # Remove package and config files
sudo apt autoremove                # Remove orphaned dependencies
```

**RHEL/DNF:**

```bash
sudo dnf remove nginx              # Remove package
sudo dnf autoremove                # Remove orphaned dependencies
```

The distinction between remove and purge matters. After `apt remove nginx`, config files in `/etc/nginx` remain. After `apt purge nginx`, they're gone. If you're reinstalling, keeping configs is convenient. If you're cleaning up, purge is cleaner.

### Reinstalling

Force reinstallation of an already-installed package:

**Debian/Ubuntu:**

```bash
sudo apt reinstall nginx
```

**RHEL/DNF:**

```bash
sudo dnf reinstall nginx
```

Useful when package files are corrupted or missing.

### Simulating operations

See what would happen without doing it:

**Debian/Ubuntu:**

```bash
apt install --simulate nginx       # Show what would be installed
apt install -s nginx               # Same thing
```

**RHEL/DNF:**

```bash
dnf install --assumeno nginx       # Show plan, don't execute
```

</div>
</details>

---

<details>
<summary><strong>7. Updating and Upgrading</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Keeping software updated is essential for security and stability. Unpatched systems are vulnerable systems.

### Regular updates — Debian/Ubuntu

```bash
sudo apt update                    # Refresh package lists
sudo apt upgrade                   # Upgrade all packages
sudo apt full-upgrade              # Upgrade, allowing package removal if needed
```

`upgrade` is conservative — it won't remove packages or install new ones unless required. `full-upgrade` handles more complex upgrade scenarios.

### Regular updates — RHEL/DNF

```bash
sudo dnf check-update              # See what's available
sudo dnf upgrade                   # Upgrade all packages
sudo dnf upgrade --security        # Only security updates
```

### Security updates only

On production systems, you might want only security patches:

**Ubuntu:**

```bash
sudo apt install unattended-upgrades
sudo dpkg-reconfigure -plow unattended-upgrades
```

This enables automatic security updates.

**RHEL/DNF:**

```bash
sudo dnf upgrade --security
```

### Holding packages

Prevent specific packages from being upgraded:

**Debian/Ubuntu:**

```bash
sudo apt-mark hold nginx           # Don't upgrade nginx
sudo apt-mark unhold nginx         # Allow upgrades again
apt-mark showhold                  # List held packages
```

**RHEL/DNF:**

```bash
sudo dnf install dnf-plugin-versionlock
sudo dnf versionlock add nginx     # Lock version
sudo dnf versionlock delete nginx  # Unlock
dnf versionlock list               # List locked packages
```

### Checking what changed

After upgrading, see what was updated:

**Debian/Ubuntu:**

```bash
cat /var/log/apt/history.log       # Recent apt operations
zcat /var/log/apt/history.log.*.gz # Older operations
```

**RHEL/DNF:**

```bash
dnf history                        # Transaction history
dnf history info 15                # Details of transaction 15
```

### Rolling back

If an update breaks something:

**RHEL/DNF:**

```bash
sudo dnf history undo 15           # Undo transaction 15
```

DNF makes rollback straightforward.

**Debian/Ubuntu:**

Rollback is harder. You'd need to install the specific older version manually or restore from backup. This is one area where DNF excels.

</div>
</details>

---

<details>
<summary><strong>8. Handling Dependencies</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Dependencies are packages required by other packages. When you install nginx, it needs libpcre and libssl. Those might need other libraries. The package manager builds this tree and installs everything.

### Dependency problems

Occasionally, dependencies conflict or break:

**Debian/Ubuntu:**

```bash
# Fix broken dependencies
sudo apt --fix-broken install

# Force install despite issues (dangerous)
sudo dpkg --configure -a

# Check for issues
sudo apt-get check
```

**RHEL/DNF:**

```bash
# Check for problems
sudo dnf check

# Rebuild dependency database
sudo dnf clean all
sudo dnf makecache
```

### Dependency hell

This term describes situations where:
- Package A needs library version 1.0
- Package B needs library version 2.0
- Both versions can't coexist

Modern package managers handle most cases, but conflicts still occur. Solutions:

1. **Remove conflicting package** — If you don't need both
2. **Use containers** — Each app gets its own isolated dependencies
3. **Use language-specific managers** — pip, npm, gem isolate from system packages
4. **Compile from source** — Install to a custom location

### Orphaned packages

When you remove a package, its dependencies might become unused. Clean them up:

```bash
sudo apt autoremove                # Debian/Ubuntu
sudo dnf autoremove                # RHEL/DNF
```

### Pinning versions

For stability, pin to specific versions in production:

**Debian/Ubuntu** — Create `/etc/apt/preferences.d/nginx`:

```
Package: nginx
Pin: version 1.18.*
Pin-Priority: 1000
```

**RHEL/DNF** — Use versionlock as shown earlier.

</div>
</details>

---

<details>
<summary><strong>9. Building from Source</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Sometimes you need software that's not in repositories, or you need a specific version or custom compile options. Building from source is the fallback.

### The general process

1. Install build tools
2. Download source code
3. Configure the build
4. Compile
5. Install

### Install build essentials

**Debian/Ubuntu:**

```bash
sudo apt install build-essential
```

**RHEL/DNF:**

```bash
sudo dnf groupinstall "Development Tools"
```

This gives you `gcc`, `make`, and other compilation tools.

### A typical build

```bash
# Download and extract
wget https://example.com/software-1.2.3.tar.gz
tar xzf software-1.2.3.tar.gz
cd software-1.2.3

# Configure (check for dependencies, set options)
./configure --prefix=/usr/local

# Compile
make

# Install
sudo make install
```

The `--prefix` flag sets where files install. `/usr/local` is standard for manually compiled software, keeping it separate from package-managed files.

### Managing source-built software

Software built from source bypasses the package manager. The package database doesn't know about it. This means:

- No automatic updates
- Manual tracking of what's installed
- Potential conflicts with packaged versions

For production, prefer packages when possible. If you must build from source, consider:

- **checkinstall** — Creates a .deb or .rpm from `make install`, so the package manager tracks it
- **Containers** — Build in a container image where dependencies are controlled
- **FPM** — Tool to convert various formats into system packages

### When to build from source

- Software not in any repository
- Need bleeding-edge version
- Need custom compile flags (security hardening, modules)
- Need to patch the source
- Embedded systems with unusual requirements

For ChillSpot, if you needed nginx with a custom module:

```bash
./configure --prefix=/usr/local/nginx \
            --with-http_ssl_module \
            --add-module=/path/to/custom-module
make
sudo make install
```

But this nginx won't update automatically and won't integrate with systemd like the packaged version. Trade-offs.

</div>
</details>

---

## 10. Where We Go From Here

You now control how software enters your system. Repositories provide packages, package managers resolve dependencies, and you can install, update, remove, and troubleshoot with confidence. When packages aren't enough, you can build from source.

This software communicates over networks. Web servers listen on ports. Databases accept connections. Applications talk to APIs. Containers download images. Understanding Linux networking is essential for DevOps — configuring interfaces, managing firewall rules, debugging connectivity issues.

File 06 covers **Networking** — how Linux handles network interfaces, IP addresses, routing, DNS, firewalls, and the diagnostic tools you'll use when things don't connect.

Software is installed. Let's get it talking to the world.
